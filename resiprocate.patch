diff --git a/CMakeLists.txt b/CMakeLists.txt
old mode 100644
new mode 100755
index 4e55b5c3e..2bae4ffda
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 3.21 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/build/cmake_modules")
 
 # For Visual Studio Solution Generation
@@ -48,8 +48,8 @@ add_definitions(-DHAVE_VERSION_H)
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/version.h.cmake
                ${CMAKE_CURRENT_BINARY_DIR}/version.h)
 include_directories(${CMAKE_CURRENT_BINARY_DIR})
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/version.h
-        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/resip/)
+#install(FILES ${CMAKE_CURRENT_BINARY_DIR}/version.h
+#        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/resip/)
 
 option(ENABLE_LOG_REPOSITORY_DETAILS "Log repository revision and branch" TRUE)
 if(ENABLE_LOG_REPOSITORY_DETAILS)
@@ -100,14 +100,14 @@ endif()
 # Top-level user-settable variables (with defaults)
 # Those can be queried from the command line using "cmake -LH" and can be
 # specified on the command line, using cmake-gui or ccmake.
-option(WITH_SSL "Link against SSL libraries" TRUE)
-option(USE_POPT "Link against POPT libraries" TRUE)
+option(WITH_SSL "Link against SSL libraries" FALSE)
+option(USE_POPT "Link against POPT libraries" FALSE)
 option(USE_SIGCOMP "Use OpenSigComp" FALSE)
 option(USE_FMT "Link against fmt library" FALSE)
-option(VERSIONED_SONAME "Include Major.Minor version in SONAME" TRUE)
+option(VERSIONED_SONAME "Include Major.Minor version in SONAME" FALSE)
 option(ENABLE_ANDROID "Enable Android build" FALSE)
-option(USE_IPV6 "Enable IPv6" TRUE)
-option(USE_DTLS "Enable DTLS" TRUE)
+option(USE_IPV6 "Enable IPv6" FALSE)
+option(USE_DTLS "Enable DTLS" FALSE)
 option(PEDANTIC_STACK "Enable pedantic behavior (fully parse all messages)" FALSE)
 option(USE_MYSQL "Link against MySQL client libraries" FALSE)
 # some systems may have a newer version of libpq that is not
@@ -117,18 +117,18 @@ option(USE_SOCI_POSTGRESQL "Build recon with SOCI PostgreSQL support" FALSE)
 # time in some environments, e.g. CentOS 8.1
 option(USE_SOCI_MYSQL "Build recon with SOCI MySQL support" FALSE)
 option(USE_POSTGRESQL "Link against PostgreSQL client libraries" FALSE)
-option(USE_MAXMIND_GEOIP "Link against MaxMind GeoIP libraries" TRUE)
+option(USE_MAXMIND_GEOIP "Link against MaxMind GeoIP libraries" FALSE)
 option(RESIP_HAVE_RADCLI "Link against radcli RADIUS client library" FALSE)
 option(USE_NETSNMP "Link against NetSNMP client libraries" FALSE)
-option(BUILD_REPRO "Build repro SIP proxy" TRUE)
-option(BUILD_RETURN "Build reTurn server" TRUE)
-option(BUILD_REFLOW "Build reflow library" TRUE)
-option(BUILD_REND "Build rend" TRUE)
-option(BUILD_TFM "Build TFM, requires Netxx and cppunit" TRUE)
+option(BUILD_REPRO "Build repro SIP proxy" FALSE)
+option(BUILD_RETURN "Build reTurn server" FALSE)
+option(BUILD_REFLOW "Build reflow library" FALSE)
+option(BUILD_REND "Build rend" FALSE)
+option(BUILD_TFM "Build TFM, requires Netxx and cppunit" FALSE)
 option(BUILD_CLICKTOCALL "Build Click to call application" FALSE)
 option(BUILD_ICHAT_GW "Build iChat gateway, requires gloox" FALSE)
 option(BUILD_TELEPATHY_CM "Build Telepathy connection manager" FALSE)
-option(BUILD_RECON "Build reCon Conversation Manager library" TRUE)
+option(BUILD_RECON "Build reCon Conversation Manager library" FALSE)
 option(USE_SRTP1 "Use srtp 1.x instead of current version" FALSE)
 option(BUILD_RECONSERVER "Build reConServer" FALSE)
 option(USE_SIPXTAPI "Link against sipXtapi" FALSE)
@@ -139,7 +139,7 @@ option(USE_LIBWEBRTC "Link against LibWebRTC" FALSE)
 option(RECON_LOCAL_HW_TESTS "Attempt to use local audio hardware in unit tests" FALSE)
 option(BUILD_P2P "Build P2P, links against S2C and SSL, unfinished" FALSE)
 option(BUILD_PYTHON "Build components requiring Python" FALSE)
-option(BUILD_TESTING "Build manual & unit tests" TRUE)
+option(BUILD_TESTING "Build manual & unit tests" FALSE)
 
 # Enable/disable linux based settings appropriately
 if(WIN32)
@@ -149,11 +149,11 @@ if(WIN32)
    set(REGENERATE_MEDIA_SAMPLES_DEFAULT OFF)
    set(BUILD_DSO_PLUGINS_DEFAULT OFF)
 else()
-   set(WITH_C_ARES_DEFAULT ON)  # Needed for TFM to build correctly on linux
-   set(BUILD_QPID_PROTON_DEFAULT ON)
-   set(RESIP_ASSERT_SYSLOG_DEFAULT ON)
-   set(REGENERATE_MEDIA_SAMPLES_DEFAULT ON)
-   set(BUILD_DSO_PLUGINS_DEFAULT ON)
+   set(WITH_C_ARES_DEFAULT OFF)  # Needed for TFM to build correctly on linux
+   set(BUILD_QPID_PROTON_DEFAULT OFF)
+   set(RESIP_ASSERT_SYSLOG_DEFAULT OFF)
+   set(REGENERATE_MEDIA_SAMPLES_DEFAULT OFF)
+   set(BUILD_DSO_PLUGINS_DEFAULT OFF)
 endif()
 option(WITH_C_ARES "Link against libc-ares (rather than rutil/dns/ares)" ${WITH_C_ARES_DEFAULT})
 option(BUILD_QPID_PROTON "Build components requiring qpid-proton (AMQP)" ${BUILD_QPID_PROTON_DEFAULT})
@@ -201,7 +201,7 @@ if(WIN32)
    set(USE_CONTRIB_DEFAULT ON)
    set(USE_NUGET_DEFAULT ON)
 else()
-   set(BUILD_SHARED_LIBS_DEFAULT ON)
+   set(BUILD_SHARED_LIBS_DEFAULT OFF)
    set(USE_CONTRIB_DEFAULT OFF)
    set(USE_NUGET_DEFAULT OFF)
 endif()
diff --git a/resip/dum/AppDialog.cxx b/resip/dum/AppDialog.cxx
old mode 100644
new mode 100755
index 279949297..7ad479bda
--- a/resip/dum/AppDialog.cxx
+++ b/resip/dum/AppDialog.cxx
@@ -20,17 +20,17 @@ AppDialog::getHandle()
    return AppDialogHandle(mHam, mId);
 }
 
-vector<ClientSubscriptionHandle> 
-AppDialog::getClientSubscriptions()
-{
-   return mDialog->getClientSubscriptions();
-}
+// vector<ClientSubscriptionHandle> 
+// AppDialog::getClientSubscriptions()
+// {
+//    return mDialog->getClientSubscriptions();
+// }
 
-vector<ClientSubscriptionHandle> 
-AppDialog::findClientSubscriptions(const Data& event)
-{
-   return mDialog->findClientSubscriptions(event);
-}
+// vector<ClientSubscriptionHandle> 
+// AppDialog::findClientSubscriptions(const Data& event)
+// {
+//    return mDialog->findClientSubscriptions(event);
+// }
 
 vector<ServerSubscriptionHandle> 
 AppDialog::getServerSubscriptions()
diff --git a/resip/dum/AppDialog.hxx b/resip/dum/AppDialog.hxx
old mode 100644
new mode 100755
index 934bef438..e81f8fadf
--- a/resip/dum/AppDialog.hxx
+++ b/resip/dum/AppDialog.hxx
@@ -27,8 +27,8 @@ class AppDialog : public Handled
 
       //?dcm? -- further evidence that this should possbily be a dialog
       //subclass(cancel gets tricky). List vs vector?(here and in Dialog)
-      std::vector<ClientSubscriptionHandle> getClientSubscriptions();
-      std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
+      // std::vector<ClientSubscriptionHandle> getClientSubscriptions();
+      // std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
 
       std::vector<ServerSubscriptionHandle> getServerSubscriptions();
       std::vector<ServerSubscriptionHandle> findServerSubscriptions(const Data& event);
diff --git a/resip/dum/CMakeLists.txt b/resip/dum/CMakeLists.txt
old mode 100644
new mode 100755
index c4d5e3ff9..de90ca602
--- a/resip/dum/CMakeLists.txt
+++ b/resip/dum/CMakeLists.txt
@@ -9,15 +9,15 @@ set(INCLUDES
    ChallengeInfo.hxx
    ClientAuthExtension.hxx
    ClientAuthManager.hxx
-   ClientInviteSession.hxx
-   ClientOutOfDialogReq.hxx
+   #ClientInviteSession.hxx
+   #ClientOutOfDialogReq.hxx
    ClientPagerMessage.hxx
    ClientPublication.hxx
    ClientRegistration.hxx
-   ClientSubscriptionFunctor.hxx
-   ClientSubscription.hxx
-   ContactInstanceRecord.hxx
-   DefaultServerReferHandler.hxx
+   #ClientSubscriptionFunctor.hxx
+   #ClientSubscription.hxx
+   #ContactInstanceRecord.hxx
+   #DefaultServerReferHandler.hxx
    DestroyUsage.hxx
    DialogEventHandler.hxx
    DialogEventInfo.hxx
@@ -36,7 +36,7 @@ set(INCLUDES
    DumFeature.hxx
    DumFeatureMessage.hxx
    DumHelper.hxx
-   DumProcessHandler.hxx
+   #DumProcessHandler.hxx
    DumShutdownHandler.hxx
    DumThread.hxx
    DumTimeout.hxx
@@ -53,56 +53,56 @@ set(INCLUDES
    HttpGetMessage.hxx
    HttpProvider.hxx
    IdentityHandler.hxx
-   InMemoryRegistrationDatabase.hxx
-   InMemorySyncPubDb.hxx
-   InMemorySyncRegDb.hxx
-   InviteDialogs.hxx
-   InviteSessionCreator.hxx
+   #InMemoryRegistrationDatabase.hxx
+   #InMemorySyncPubDb.hxx
+   #InMemorySyncRegDb.hxx
+   #InviteDialogs.hxx
+   #InviteSessionCreator.hxx
    InviteSessionHandler.hxx
    InviteSession.hxx
-   KeepAliveManager.hxx
-   KeepAliveTimeout.hxx
+   #KeepAliveManager.hxx
+   #KeepAliveTimeout.hxx
    MasterProfile.hxx
    MergedRequestKey.hxx
    MergedRequestRemovalCommand.hxx
-   NetworkAssociation.hxx
+   #NetworkAssociation.hxx
    NonDialogUsage.hxx
    OutgoingEvent.hxx
    OutOfDialogHandler.hxx
-   OutOfDialogReqCreator.hxx
+   #OutOfDialogReqCreator.hxx
    PagerMessageCreator.hxx
    PagerMessageHandler.hxx
    Postable.hxx
    Profile.hxx
    PublicationCreator.hxx
    PublicationHandler.hxx
-   PublicationPersistenceManager.hxx
-   RADIUSServerAuthManager.hxx
+   #PublicationPersistenceManager.hxx
+   #RADIUSServerAuthManager.hxx
    RedirectHandler.hxx
    RedirectManager.hxx
    RefCountedDestroyer.hxx
    RegistrationCreator.hxx
    RegistrationHandler.hxx
-   RegistrationPersistenceManager.hxx
+   #RegistrationPersistenceManager.hxx
    RemoteCertStore.hxx
    RequestValidationHandler.hxx
-   ServerAuthManager.hxx
+   #ServerAuthManager.hxx
    ServerInviteSession.hxx
-   ServerOutOfDialogReq.hxx
+   #ServerOutOfDialogReq.hxx
    ServerPagerMessage.hxx
-   ServerPublication.hxx
-   ServerRegistration.hxx
+   #ServerPublication.hxx
+   #ServerRegistration.hxx
    ServerSubscriptionFunctor.hxx
    ServerSubscription.hxx
    ssl/EncryptionManager.hxx
-   SubscriptionCreator.hxx
+   #SubscriptionCreator.hxx
    SubscriptionHandler.hxx
-   SubscriptionPersistenceManager.hxx
+   #SubscriptionPersistenceManager.hxx
    SubscriptionState.hxx
    TargetCommand.hxx
    TlsPeerAuthManager.hxx
    TlsPeerIdentityInfoMessage.hxx
-   WsCookieAuthManager.hxx
+   #WsCookieAuthManager.hxx
    UsageUseException.hxx
    UserAuthInfo.hxx
    UserProfile.hxx
@@ -119,14 +119,14 @@ add_library(dum
    ChallengeInfo.cxx
    ClientAuthExtension.cxx
    ClientAuthManager.cxx
-   ClientInviteSession.cxx
-   ClientOutOfDialogReq.cxx
+   #ClientInviteSession.cxx
+   #ClientOutOfDialogReq.cxx
    ClientPagerMessage.cxx
    ClientPublication.cxx
    ClientRegistration.cxx
-   ClientSubscription.cxx
-   ContactInstanceRecord.cxx
-   DefaultServerReferHandler.cxx
+   #ClientSubscription.cxx
+   #ContactInstanceRecord.cxx
+   #DefaultServerReferHandler.cxx
    DestroyUsage.cxx
    Dialog.cxx
    DialogEventInfo.cxx
@@ -141,7 +141,7 @@ add_library(dum
    DumFeatureChain.cxx
    DumFeatureMessage.cxx
    DumHelper.cxx
-   DumProcessHandler.cxx
+   #DumProcessHandler.cxx
    DumThread.cxx
    DumTimeout.cxx
    EncryptionRequest.cxx
@@ -152,36 +152,36 @@ add_library(dum
    HttpGetMessage.cxx
    HttpProvider.cxx
    IdentityHandler.cxx
-   InMemoryRegistrationDatabase.cxx
-   InMemorySyncPubDb.cxx
-   InMemorySyncRegDb.cxx
+   #InMemoryRegistrationDatabase.cxx
+   #InMemorySyncPubDb.cxx
+   #InMemorySyncRegDb.cxx
    InviteSession.cxx
-   InviteSessionCreator.cxx
+   #InviteSessionCreator.cxx
    InviteSessionHandler.cxx
-   KeepAliveManager.cxx
-   KeepAliveTimeout.cxx
+   #KeepAliveManager.cxx
+   #KeepAliveTimeout.cxx
    MasterProfile.cxx
    MergedRequestKey.cxx
    MergedRequestRemovalCommand.cxx
-   NetworkAssociation.cxx
+   #NetworkAssociation.cxx
    NonDialogUsage.cxx
-   OutOfDialogReqCreator.cxx
+   #OutOfDialogReqCreator.cxx
    OutgoingEvent.cxx
    PagerMessageCreator.cxx
    Profile.cxx
    PublicationCreator.cxx
-   RADIUSServerAuthManager.cxx
+   #RADIUSServerAuthManager.cxx
    RedirectManager.cxx
    RegistrationCreator.cxx
    RegistrationHandler.cxx
-   ServerAuthManager.cxx
+   #ServerAuthManager.cxx
    ServerInviteSession.cxx
-   ServerOutOfDialogReq.cxx
+   #ServerOutOfDialogReq.cxx
    ServerPagerMessage.cxx
-   ServerPublication.cxx
-   ServerRegistration.cxx
+   #ServerPublication.cxx
+   #ServerRegistration.cxx
    ServerSubscription.cxx
-   SubscriptionCreator.cxx
+   #SubscriptionCreator.cxx
    SubscriptionHandler.cxx
    SubscriptionState.cxx
    TargetCommand.cxx
@@ -189,7 +189,7 @@ add_library(dum
    TlsPeerIdentityInfoMessage.cxx
    UserAuthInfo.cxx
    UserProfile.cxx
-   WsCookieAuthManager.cxx
+   #WsCookieAuthManager.cxx
 
    ${INCLUDES}
 )
@@ -204,7 +204,7 @@ version_libname(dum)
 set_target_properties(dum PROPERTIES FOLDER dum)
 
 install(TARGETS dum DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/dum ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/dum ${INCLUDES})
 
 if(BUILD_TESTING)
     add_subdirectory(test)
diff --git a/resip/dum/ClientRegistration.cxx b/resip/dum/ClientRegistration.cxx
old mode 100644
new mode 100755
index 6d988c394..4aca55997
--- a/resip/dum/ClientRegistration.cxx
+++ b/resip/dum/ClientRegistration.cxx
@@ -65,7 +65,7 @@ ClientRegistration::ClientRegistration(DialogUsageManager& dum,
       mRegistrationTime = mLastRequest->header(h_Expires).value();
    }
 
-   mNetworkAssociation.setDum(&dum);
+   // mNetworkAssociation.setDum(&dum);
 }
 
 ClientRegistration::~ClientRegistration()
@@ -457,7 +457,7 @@ ClientRegistration::dispatch(const SipMessage& msg)
 
          if(keepAliveTime > 0)
          {
-            mNetworkAssociation.update(msg, keepAliveTime, nextHopSupportsOutbound);
+            // mNetworkAssociation.update(msg, keepAliveTime, nextHopSupportsOutbound);
          }
       }
 
@@ -1013,7 +1013,7 @@ void
 ClientRegistration::flowTerminated()
 {
    // Clear the network association
-   mNetworkAssociation.clear();
+   // mNetworkAssociation.clear();
 
    // Notify application - not default handler implementation is to immediately attempt
    // a re-registration in order to form a new flow
diff --git a/resip/dum/ClientRegistration.hxx b/resip/dum/ClientRegistration.hxx
old mode 100644
new mode 100755
index 5f420af8b..480622084
--- a/resip/dum/ClientRegistration.hxx
+++ b/resip/dum/ClientRegistration.hxx
@@ -4,7 +4,7 @@
 #include "resip/dum/NonDialogUsage.hxx"
 #include "resip/stack/NameAddr.hxx"
 #include "resip/stack/SipMessage.hxx"
-#include "resip/dum/NetworkAssociation.hxx"
+// #include "resip/dum/NetworkAssociation.hxx"
 
 namespace resip
 {
@@ -125,7 +125,7 @@ class ClientRegistration: public NonDialogUsage
       State mQueuedState;
       std::shared_ptr<SipMessage> mQueuedRequest;
 
-      NetworkAssociation mNetworkAssociation;
+      // NetworkAssociation mNetworkAssociation;
 };
  
 }
diff --git a/resip/dum/Dialog.cxx b/resip/dum/Dialog.cxx
old mode 100644
new mode 100755
index 60dd869ca..ca77e3c0e
--- a/resip/dum/Dialog.cxx
+++ b/resip/dum/Dialog.cxx
@@ -4,8 +4,8 @@
 #include "resip/dum/AppDialog.hxx"
 #include "resip/dum/BaseCreator.hxx"
 #include "resip/dum/ClientAuthManager.hxx"
-#include "resip/dum/ClientInviteSession.hxx"
-#include "resip/dum/ClientSubscription.hxx"
+// #include "resip/dum/ClientInviteSession.hxx"
+// #include "resip/dum/ClientSubscription.hxx"
 #include "resip/dum/Dialog.hxx"
 #include "resip/dum/DialogUsageManager.hxx"
 #include "resip/dum/MasterProfile.hxx"
@@ -30,7 +30,7 @@ Dialog::Dialog(DialogUsageManager& dum, const SipMessage& msg, DialogSet& ds)
    : mDum(dum),
      mDialogSet(ds),
      mId("INVALID", "INVALID", "INVALID"),
-     mClientSubscriptions(),
+   //   mClientSubscriptions(),
      mServerSubscriptions(),
      mInviteSession(0),
      mType(Fake),
@@ -53,7 +53,7 @@ Dialog::Dialog(DialogUsageManager& dum, const SipMessage& msg, DialogSet& ds)
    resip_assert(msg.header(h_CSeq).method() != REGISTER);
    resip_assert(msg.header(h_CSeq).method() != PUBLISH);
 
-   mNetworkAssociation.setDum(&dum);
+   // mNetworkAssociation.setDum(&dum);
 
    if (msg.isRequest()) // UAS
    {
@@ -281,10 +281,10 @@ Dialog::~Dialog()
 
    mDestroying = true;
 
-   while (!mClientSubscriptions.empty())
-   {
-      delete *mClientSubscriptions.begin();
-   }
+   // while (!mClientSubscriptions.empty())
+   // {
+   //    delete *mClientSubscriptions.begin();
+   // }
 
    while (!mServerSubscriptions.empty())
    {
@@ -345,11 +345,11 @@ Dialog::getRouteSet() const noexcept
 void
 Dialog::cancel()
 {
-   ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
-   if (uac)
-   {
-      uac->cancel();
-   }
+   // ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
+   // if (uac)
+   // {
+   //    uac->cancel();
+   // }
 }
 
 void
@@ -376,13 +376,13 @@ Dialog::end(const Data& endReason, const ParserContainer<Token>& endReasons)
    // End Subscriptions
    // !jrm! WARN ClientSubscription and ServerSubscription have access to this dialog and will remove themselves
    // from the m<client|server>Subscriptions collections in the call to end().
-   for (list<ClientSubscription*>::iterator it(mClientSubscriptions.begin());
-        it != mClientSubscriptions.end();)
-   {
-	   ClientSubscription* c = *it;
-       it++;       
-	   c->end();
-   }
+   // for (list<ClientSubscription*>::iterator it(mClientSubscriptions.begin());
+   //      it != mClientSubscriptions.end();)
+   // {
+	//    ClientSubscription* c = *it;
+   //     it++;       
+	//    c->end();
+   // }
 
    for (list<ServerSubscription*>::iterator it2(mServerSubscriptions.begin());
         it2 != mServerSubscriptions.end();)
@@ -475,7 +475,7 @@ Dialog::dispatch(const SipMessage& msg)
 
       if(keepAliveTime > 0)
       {
-         mNetworkAssociation.update(msg, keepAliveTime, false /* targetSupportsOutbound */); // target supports outbound is detected in registration responses only
+         // mNetworkAssociation.update(msg, keepAliveTime, false /* targetSupportsOutbound */); // target supports outbound is detected in registration responses only
       }
    }
    
@@ -506,15 +506,15 @@ Dialog::dispatch(const SipMessage& msg)
             }
             break;
          case UPDATE:
-            if (mInviteSession == 0)
-            {
-               InfoLog ( << "Spurious UPDATE" );
-               return;
-            }
-            else
-            {
-               mInviteSession->dispatch(request);
-            }
+            // if (mInviteSession == 0)
+            // {
+            //    InfoLog ( << "Spurious UPDATE" );
+            //    return;
+            // }
+            // else
+            // {
+            //    mInviteSession->dispatch(request);
+            // }
             break;
          case INFO:
             if (mInviteSession == 0)
@@ -528,26 +528,26 @@ Dialog::dispatch(const SipMessage& msg)
             }
             break;
          case MESSAGE:
-            if (mInviteSession == 0)
-            {
-               InfoLog ( << "Spurious MESSAGE" );
-               return;
-            }
-            else
-            {
-               mInviteSession->dispatch(request);
-            }
+            // if (mInviteSession == 0)
+            // {
+            //    InfoLog ( << "Spurious MESSAGE" );
+            //    return;
+            // }
+            // else
+            // {
+            //    mInviteSession->dispatch(request);
+            // }
             break;
          case PRACK:
-            if (mInviteSession == 0)
-            {
-               InfoLog ( << "Spurious PRACK" );
-               return;
-            }
-            else
-            {
-               mInviteSession->dispatch(request);
-            }
+            // if (mInviteSession == 0)
+            // {
+            //    InfoLog ( << "Spurious PRACK" );
+            //    return;
+            // }
+            // else
+            // {
+            //    mInviteSession->dispatch(request);
+            // }
             break;
          case ACK:
          case CANCEL:
@@ -591,98 +591,98 @@ Dialog::dispatch(const SipMessage& msg)
          }
          break;
          case REFER:
-         {
-            if (!request.exists(h_ReferTo))
-            {
-               InfoLog (<< "Received refer w/out a Refer-To: " << request.brief());
-               SipMessage failure;
-               makeResponse(failure, request, 400);
-               mDum.sendResponse(failure);
-               return;
-            }
-            else
-            {
-               if ((request.exists(h_ReferSub) && 
-                     request.header(h_ReferSub).isWellFormed() &&
-                     request.header(h_ReferSub).value()=="false") ||
-                     (request.exists(h_Requires) &&
-                     request.header(h_Requires).find(Token("norefersub"))))
-               {
-                  if (mInviteSession == 0)
-                  {
-                     InfoLog(<< "Received an in dialog refer with no subscription in a non-invite dialog: " << request.brief());
-                     SipMessage failure;
-                     makeResponse(failure, request, 603);
-                     mDum.sendResponse(failure);
-                     return;
-                  }
-                  mInviteSession->referNoSub(msg);
-               }
-               else  // else we need a subscription
-               {
-                  ServerSubscription* server = findMatchingServerSub(request);
-                  ServerSubscriptionHandle serverHandle;
-                  if (server)
-                  {
-                     serverHandle = server->getHandle();
-                     server->dispatch(request);
-                  }
-                  else
-                  {
-                     server = makeServerSubscription(request);
-                     mServerSubscriptions.push_back(server);
-                     serverHandle = server->getHandle();
-                     server->dispatch(request);
-                  }
-
-                  if (mInviteSession)
-                  {
-                     mDum.mInviteSessionHandler->onRefer(mInviteSession->getSessionHandle(), serverHandle, msg);
-                  }
+         // {
+         //    if (!request.exists(h_ReferTo))
+         //    {
+         //       InfoLog (<< "Received refer w/out a Refer-To: " << request.brief());
+         //       SipMessage failure;
+         //       makeResponse(failure, request, 400);
+         //       mDum.sendResponse(failure);
+         //       return;
+         //    }
+         //    else
+         //    {
+         //       if ((request.exists(h_ReferSub) && 
+         //             request.header(h_ReferSub).isWellFormed() &&
+         //             request.header(h_ReferSub).value()=="false") ||
+         //             (request.exists(h_Requires) &&
+         //             request.header(h_Requires).find(Token("norefersub"))))
+         //       {
+         //          if (mInviteSession == 0)
+         //          {
+         //             InfoLog(<< "Received an in dialog refer with no subscription in a non-invite dialog: " << request.brief());
+         //             SipMessage failure;
+         //             makeResponse(failure, request, 603);
+         //             mDum.sendResponse(failure);
+         //             return;
+         //          }
+         //          mInviteSession->referNoSub(msg);
+         //       }
+         //       else  // else we need a subscription
+         //       {
+         //          ServerSubscription* server = findMatchingServerSub(request);
+         //          ServerSubscriptionHandle serverHandle;
+         //          if (server)
+         //          {
+         //             serverHandle = server->getHandle();
+         //             server->dispatch(request);
+         //          }
+         //          else
+         //          {
+         //             server = makeServerSubscription(request);
+         //             mServerSubscriptions.push_back(server);
+         //             serverHandle = server->getHandle();
+         //             server->dispatch(request);
+         //          }
+
+         //          if (mInviteSession)
+         //          {
+         //             mDum.mInviteSessionHandler->onRefer(mInviteSession->getSessionHandle(), serverHandle, msg);
+         //          }
                   
-               }
-            }
-         }
+         //       }
+         //    }
+         // }
          break;
          case NOTIFY:
-            {
-               ClientSubscription* client = findMatchingClientSub(request);
-               if (client)
-               {
-                  client->dispatch(request);
-               }
-               else
-               {
-                  BaseCreator* creator = mDialogSet.getCreator();
-                  if (creator && (creator->getLastRequest()->header(h_RequestLine).method() == SUBSCRIBE ||
-                     creator->getLastRequest()->header(h_RequestLine).method() == REFER))  
-                  {
-                     DebugLog (<< "Making subscription (from creator) request: " << *creator->getLastRequest());
-                     ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
-                     mClientSubscriptions.push_back(sub);
-                     sub->dispatch(request);
-                  }
-                  else
-                  {
-                     if (mInviteSession != 0 && (!msg.exists(h_Event) || msg.header(h_Event).value() == "refer") && 
-                         mDum.getClientSubscriptionHandler("refer")!=0) 
-                     {
-                        DebugLog (<< "Making subscription from NOTIFY: " << msg);
-                        ClientSubscription* sub = makeClientSubscription(msg);
-                        mClientSubscriptions.push_back(sub);
-                        ClientSubscriptionHandle client = sub->getHandle();
-                        mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), client, msg);				      
-                        sub->dispatch(request);
-                     }
-                     else
-                     {
-                        auto response = std::make_shared<SipMessage>();
-                        makeResponse(*response, msg, 406);
-                        send(response);
-                     }
-                  }
-               }
-            }
+            // {
+            //    ClientSubscription* client = findMatchingClientSub(request);
+            //    if (client)
+            //    {
+            //       client->dispatch(request);
+            //    }
+            //    else
+            //    {
+            //       BaseCreator* creator = mDialogSet.getCreator();
+            //       if (creator && (creator->getLastRequest()->header(h_RequestLine).method() == SUBSCRIBE ||
+            //          creator->getLastRequest()->header(h_RequestLine).method() == REFER))  
+            //       {
+            //          DebugLog (<< "Making subscription (from creator) request: " << *creator->getLastRequest());
+            //          ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
+            //          mClientSubscriptions.push_back(sub);
+            //          sub->dispatch(request);
+            //       }
+            //       else
+            //       {
+            //          if (mInviteSession != 0 && (!msg.exists(h_Event) || msg.header(h_Event).value() == "refer") && 
+            //              mDum.getClientSubscriptionHandler("refer")!=0) 
+            //          {
+            //             DebugLog (<< "Making subscription from NOTIFY: " << msg);
+            //             ClientSubscription* sub = makeClientSubscription(msg);
+            //             mClientSubscriptions.push_back(sub);
+            //             ClientSubscriptionHandle client = sub->getHandle();
+            //             mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), client, msg);				      
+            //             sub->dispatch(request);
+            //          }
+            //          else
+            //          {
+            //             auto response = std::make_shared<SipMessage>();
+            //             makeResponse(*response, msg, 406);
+            //             send(response);
+            //          }
+            //       }
+            //    }
+            // }
             break;
         default:
            resip_assert(0);
@@ -751,24 +751,24 @@ Dialog::dispatch(const SipMessage& msg)
       switch (response.header(h_CSeq).method())
       {
          case INVITE:
-            if (mInviteSession == 0)
-            {
-               DebugLog ( << "Dialog::dispatch  --  Created new client invite session" << msg.brief());
-
-               mInviteSession = makeClientInviteSession(response);
-               if (mInviteSession)
-               {
-                  mInviteSession->dispatch(response);
-               }
-               else
-               {
-                  ErrLog( << "Dialog::dispatch  --  Unable to create invite session from response" << msg.brief());
-               }
-            }
-            else
-            {
-               mInviteSession->dispatch(response);
-            }
+            // if (mInviteSession == 0)
+            // {
+            //    DebugLog ( << "Dialog::dispatch  --  Created new client invite session" << msg.brief());
+
+            //    mInviteSession = makeClientInviteSession(response);
+            //    if (mInviteSession)
+            //    {
+            //       mInviteSession->dispatch(response);
+            //    }
+            //    else
+            //    {
+            //       ErrLog( << "Dialog::dispatch  --  Unable to create invite session from response" << msg.brief());
+            //    }
+            // }
+            // else
+            // {
+            //    mInviteSession->dispatch(response);
+            // }
             break;
          case BYE:
          case ACK:
@@ -777,67 +777,67 @@ Dialog::dispatch(const SipMessage& msg)
          case MESSAGE:
          case UPDATE:
          case PRACK:
-            if (mInviteSession)
-            {
-               mInviteSession->dispatch(response);
-            }
+            // if (mInviteSession)
+            // {
+            //    mInviteSession->dispatch(response);
+            // }
             // else drop on the floor
             break;       
 
          case REFER:
-            if(mInviteSession)
-            {
-               if (code >= 300)
-               {
-                  mDum.mInviteSessionHandler->onReferRejected(mInviteSession->getSessionHandle(), msg);
-               }
-               else
-               {
-                  //!dys! the OR condition below is not draft compliant.
-                  if (!mInviteSession->mReferSub && 
-                      ((msg.exists(h_ReferSub) && msg.header(h_ReferSub).value()=="false") || 
-                       !msg.exists(h_ReferSub)))
-                  {
-                     DebugLog(<< "refer accepted with norefersub");
-                     mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), ClientSubscriptionHandle::NotValid(), msg);
-                  }
-                  // else no need for action - first Notify will cause onReferAccepted to be called
-               }
-               mInviteSession->nitComplete();
-               break;
-            }
+            // if(mInviteSession)
+            // {
+            //    if (code >= 300)
+            //    {
+            //       mDum.mInviteSessionHandler->onReferRejected(mInviteSession->getSessionHandle(), msg);
+            //    }
+            //    else
+            //    {
+            //       //!dys! the OR condition below is not draft compliant.
+            //       if (!mInviteSession->mReferSub && 
+            //           ((msg.exists(h_ReferSub) && msg.header(h_ReferSub).value()=="false") || 
+            //            !msg.exists(h_ReferSub)))
+            //       {
+            //          DebugLog(<< "refer accepted with norefersub");
+            //          mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), ClientSubscriptionHandle::NotValid(), msg);
+            //       }
+            //       // else no need for action - first Notify will cause onReferAccepted to be called
+            //    }
+            //    mInviteSession->nitComplete();
+            //    break;
+            // }
             // fall through, out of dialog refer was sent.
 
          case SUBSCRIBE:
-         {
-            ClientSubscription* client = findMatchingClientSub(response);
-            if (client)
-            {
-               client->dispatch(response);
-            }
-            else
-            {
-               //!dcm! -- can't subscribe in an existing Dialog, this is all
-               //a bit of a hack; currently, spurious failure messages may cause callbacks
-               BaseCreator* creator = mDialogSet.getCreator();
-               if (!creator || !creator->getLastRequest()->exists(h_Event))
-               {
-                  return;
-               }
-               else
-               {
-                  ClientSubscriptionHandler* handler =
-                     mDum.getClientSubscriptionHandler(creator->getLastRequest()->header(h_Event).value());
-                  if (handler)
-                  {
-                     ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
-                     mClientSubscriptions.push_back(sub);
-                     sub->dispatch(response);
-                  }
-               }
-            }
-
-         }
+         // {
+         //    ClientSubscription* client = findMatchingClientSub(response);
+         //    if (client)
+         //    {
+         //       client->dispatch(response);
+         //    }
+         //    else
+         //    {
+         //       //!dcm! -- can't subscribe in an existing Dialog, this is all
+         //       //a bit of a hack; currently, spurious failure messages may cause callbacks
+         //       BaseCreator* creator = mDialogSet.getCreator();
+         //       if (!creator || !creator->getLastRequest()->exists(h_Event))
+         //       {
+         //          return;
+         //       }
+         //       else
+         //       {
+         //          ClientSubscriptionHandler* handler =
+         //             mDum.getClientSubscriptionHandler(creator->getLastRequest()->header(h_Event).value());
+         //          if (handler)
+         //          {
+         //             ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
+         //             mClientSubscriptions.push_back(sub);
+         //             sub->dispatch(response);
+         //          }
+         //       }
+         //    }
+
+         // }
          break;
          case NOTIFY:
          {
@@ -890,19 +890,19 @@ Dialog::findMatchingServerSub(const SipMessage& msg)
    return 0;
 }
 
-ClientSubscription*
-Dialog::findMatchingClientSub(const SipMessage& msg)
-{
-   for (std::list<ClientSubscription*>::iterator i=mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      if ((*i)->matches(msg))
-      {
-         return *i;
-      }
-   }
-   return 0;
-}
+// ClientSubscription*
+// Dialog::findMatchingClientSub(const SipMessage& msg)
+// {
+//    for (std::list<ClientSubscription*>::iterator i=mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       if ((*i)->matches(msg))
+//       {
+//          return *i;
+//       }
+//    }
+//    return 0;
+// }
 
 InviteSessionHandle
 Dialog::getInviteSession()
@@ -917,21 +917,21 @@ Dialog::getInviteSession()
    }
 }
 
-std::vector<ClientSubscriptionHandle>
-Dialog::findClientSubscriptions(const Data& event)
-{
-   std::vector<ClientSubscriptionHandle> handles;
-
-   for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      if ( (*i)->getEventType() == event)
-      {
-         handles.push_back((*i)->getHandle());
-      }
-   }
-   return handles;
-}
+// std::vector<ClientSubscriptionHandle>
+// Dialog::findClientSubscriptions(const Data& event)
+// {
+//    std::vector<ClientSubscriptionHandle> handles;
+
+//    for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       if ( (*i)->getEventType() == event)
+//       {
+//          handles.push_back((*i)->getHandle());
+//       }
+//    }
+//    return handles;
+// }
 
 std::vector<ServerSubscriptionHandle>
 Dialog::findServerSubscriptions(const Data& event)
@@ -949,19 +949,19 @@ Dialog::findServerSubscriptions(const Data& event)
    return handles;
 }
 
-std::vector<ClientSubscriptionHandle>
-Dialog::getClientSubscriptions()
-{
-   std::vector<ClientSubscriptionHandle> handles;
+// std::vector<ClientSubscriptionHandle>
+// Dialog::getClientSubscriptions()
+// {
+//    std::vector<ClientSubscriptionHandle> handles;
 
-   for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      handles.push_back((*i)->getHandle());
-   }
+//    for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       handles.push_back((*i)->getHandle());
+//    }
 
-   return handles;
-}
+//    return handles;
+// }
 
 std::vector<ServerSubscriptionHandle>
 Dialog::getServerSubscriptions()
@@ -981,18 +981,18 @@ void
 Dialog::redirected(const SipMessage& msg)
 {
    //Established dialogs are not destroyed by a redirect
-   if (!mClientSubscriptions.empty() || !mServerSubscriptions.empty())
+   if (/* !mClientSubscriptions.empty() ||  */!mServerSubscriptions.empty())
    {
       return;
    }
    if (mInviteSession)
    {
-      ClientInviteSession* cInv = dynamic_cast<ClientInviteSession*>(mInviteSession);
-      if (cInv)
-      {
-         cInv->handleRedirect(msg);
-         mReUseDialogSet = true;  // Set flag so that DialogSet will not be destroyed and new Request can use it
-      }
+      // ClientInviteSession* cInv = dynamic_cast<ClientInviteSession*>(mInviteSession);
+      // if (cInv)
+      // {
+      //    cInv->handleRedirect(msg);
+      //    mReUseDialogSet = true;  // Set flag so that DialogSet will not be destroyed and new Request can use it
+      // }
    }
 }
 
@@ -1123,25 +1123,25 @@ Dialog::setRequestNextCSeq(SipMessage& request)
    request.header(h_CSeq).sequence() = ++mLocalCSeq;
 }
 
-ClientInviteSession*
-Dialog::makeClientInviteSession(const SipMessage& response)
-{
-   InviteSessionCreator* creator = dynamic_cast<InviteSessionCreator*>(mDialogSet.getCreator());
-   if (!creator)
-   {
-      resip_assert(0); // !jf! this maybe can assert by evil UAS
-      return 0;
-   }
-   //return mDum.createAppClientInviteSession(*this, *creator);
-   return new ClientInviteSession(mDum, *this, creator->getLastRequest(),
-                                  creator->getInitialOffer(), creator->getEncryptionLevel(), creator->getServerSubscription());
-}
-
-ClientSubscription*
-Dialog::makeClientSubscription(const SipMessage& request)
-{
-   return new ClientSubscription(mDum, *this, request);
-}
+// ClientInviteSession*
+// Dialog::makeClientInviteSession(const SipMessage& response)
+// {
+//    InviteSessionCreator* creator = dynamic_cast<InviteSessionCreator*>(mDialogSet.getCreator());
+//    if (!creator)
+//    {
+//       resip_assert(0); // !jf! this maybe can assert by evil UAS
+//       return 0;
+//    }
+//    //return mDum.createAppClientInviteSession(*this, *creator);
+//    return new ClientInviteSession(mDum, *this, creator->getLastRequest(),
+//                                   creator->getInitialOffer(), creator->getEncryptionLevel(), creator->getServerSubscription());
+// }
+
+// ClientSubscription*
+// Dialog::makeClientSubscription(const SipMessage& request)
+// {
+//    return new ClientSubscription(mDum, *this, request);
+// }
 
 ServerInviteSession*
 Dialog::makeServerInviteSession(const SipMessage& request)
@@ -1175,11 +1175,11 @@ Dialog::send(std::shared_ptr<SipMessage> msg)
 void
 Dialog::onForkAccepted()
 {
-   ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
-   if (uac)
-   {
-      uac->onForkAccepted();
-   }
+   // ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
+   // if (uac)
+   // {
+   //    uac->onForkAccepted();
+   // }
 }
 
 void 
@@ -1187,7 +1187,7 @@ Dialog::possiblyDie()
 {
    if (!mDestroying)
    {
-      if (mClientSubscriptions.empty() &&
+      if (/* mClientSubscriptions.empty() && */
           mServerSubscriptions.empty() &&
           !mInviteSession)
       {
@@ -1201,7 +1201,7 @@ void
 Dialog::flowTerminated()
 {
    // Clear the network association
-   mNetworkAssociation.clear();
+   // mNetworkAssociation.clear();
    
    // notify server subscirption dialogs
    std::list<ServerSubscription*> tempServerList = mServerSubscriptions;  // Create copy since subscription can be deleted
@@ -1212,12 +1212,12 @@ Dialog::flowTerminated()
    }
 
    // notify client subscription dialogs
-   std::list<ClientSubscription*> tempClientList = mClientSubscriptions;  // Create copy since subscription can be deleted
-   for (std::list<ClientSubscription*>::iterator ic=tempClientList.begin();
-        ic != tempClientList.end(); ++ic)
-   {
-      (*ic)->flowTerminated();
-   }
+   // std::list<ClientSubscription*> tempClientList = mClientSubscriptions;  // Create copy since subscription can be deleted
+   // for (std::list<ClientSubscription*>::iterator ic=tempClientList.begin();
+   //      ic != tempClientList.end(); ++ic)
+   // {
+   //    (*ic)->flowTerminated();
+   // }
 
    // notify invite session dialog
    if (mInviteSession)
@@ -1230,9 +1230,9 @@ EncodeStream&
 resip::operator<<(EncodeStream& strm, const Dialog& dialog)
 {
    strm
-      << "mClientSubscriptions("
-      << dialog.mClientSubscriptions.size()
-      << "), "
+      // << "mClientSubscriptions("
+      // << dialog.mClientSubscriptions.size()
+      // << "), "
       << "mServerSubscriptions("
       << dialog.mServerSubscriptions.size()
       << ")";
diff --git a/resip/dum/Dialog.hxx b/resip/dum/Dialog.hxx
old mode 100644
new mode 100755
index 3c63eb323..d2a8d8c0f
--- a/resip/dum/Dialog.hxx
+++ b/resip/dum/Dialog.hxx
@@ -12,7 +12,7 @@
 #include "resip/stack/NameAddr.hxx"
 #include "resip/stack/CallId.hxx"
 #include "resip/stack/SipMessage.hxx"
-#include "resip/dum/NetworkAssociation.hxx"
+// #include "resip/dum/NetworkAssociation.hxx"
 #include "resip/dum/DialogUsageManager.hxx"
 
 namespace resip
@@ -59,8 +59,8 @@ class Dialog
       //void setLocalContact(const NameAddr& localContact);
       //void setRemoteTarget(const NameAddr& remoteTarget);
       
-      std::vector<ClientSubscriptionHandle> getClientSubscriptions();
-      std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
+      // std::vector<ClientSubscriptionHandle> getClientSubscriptions();
+      // std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
 
       std::vector<ServerSubscriptionHandle> getServerSubscriptions();
       std::vector<ServerSubscriptionHandle> findServerSubscriptions(const Data& event);
@@ -102,12 +102,12 @@ class Dialog
       friend class AppDialog;
       void possiblyDie();
 
-      ClientSubscription* findMatchingClientSub(const SipMessage& msg);
+      // ClientSubscription* findMatchingClientSub(const SipMessage& msg);
       ServerSubscription* findMatchingServerSub(const SipMessage& msg);
 
       void addUsage(BaseUsage* usage);
-      ClientInviteSession* makeClientInviteSession(const SipMessage& msg);
-      ClientSubscription*  makeClientSubscription(const SipMessage& msg);
+      // ClientInviteSession* makeClientInviteSession(const SipMessage& msg);
+      // ClientSubscription*  makeClientSubscription(const SipMessage& msg);
       
       ServerInviteSession* makeServerInviteSession(const SipMessage& msg);
       ServerSubscription*  makeServerSubscription(const SipMessage& msg);
@@ -123,11 +123,11 @@ class Dialog
       DialogSet& mDialogSet;
       DialogId mId;  
 
-      std::list<ClientSubscription*> mClientSubscriptions;
+      // std::list<ClientSubscription*> mClientSubscriptions;
       std::list<ServerSubscription*> mServerSubscriptions;
       InviteSession* mInviteSession;
 
-      NetworkAssociation mNetworkAssociation;
+      // NetworkAssociation mNetworkAssociation;
 
       //invariants
       typedef enum // need to add
diff --git a/resip/dum/DialogSet.cxx b/resip/dum/DialogSet.cxx
old mode 100644
new mode 100755
index e6e920d96..8f80b1c24
--- a/resip/dum/DialogSet.cxx
+++ b/resip/dum/DialogSet.cxx
@@ -42,10 +42,10 @@ DialogSet::DialogSet(BaseCreator* creator, DialogUsageManager& dum) :
    mAppDialogSet(0),
    mState(Initial),
    mClientRegistration(0),
-   mServerRegistration(0),
+   // mServerRegistration(0),
    mClientPublication(0),
-   mClientOutOfDialogRequests(),
-   mServerOutOfDialogRequest(0),
+   // mClientOutOfDialogRequests(),
+   // mServerOutOfDialogRequest(0),
    mClientPagerMessage(0),
    mServerPagerMessage(0)
 {
@@ -64,10 +64,10 @@ DialogSet::DialogSet(const SipMessage& request, DialogUsageManager& dum) :
    mAppDialogSet(0),
    mState(Established),
    mClientRegistration(0),
-   mServerRegistration(0),
+   // mServerRegistration(0),
    mClientPublication(0),
-   mClientOutOfDialogRequests(),
-   mServerOutOfDialogRequest(0),
+   // mClientOutOfDialogRequests(),
+   // mServerOutOfDialogRequest(0),
    mClientPagerMessage(0),
    mServerPagerMessage(0)
 {
@@ -116,16 +116,16 @@ DialogSet::~DialogSet()
    }
 
    delete mClientRegistration;
-   delete mServerRegistration;
+   // delete mServerRegistration;
    delete mClientPublication;
-   delete mServerOutOfDialogRequest;
+   // delete mServerOutOfDialogRequest;
    delete mClientPagerMessage;
    delete mServerPagerMessage;
 
-   while (!mClientOutOfDialogRequests.empty())
-   {
-      delete *mClientOutOfDialogRequests.begin();
-   }
+   // while (!mClientOutOfDialogRequests.empty())
+   // {
+   //    delete *mClientOutOfDialogRequests.begin();
+   // }
 
    DebugLog ( << " ********** DialogSet::~DialogSet: " << mId << "*************" );
    // !dcm! -- very delicate code, change the order things go horribly wrong
@@ -148,13 +148,13 @@ void DialogSet::possiblyDie()
       //       for which we have not created any Dialogs yet - in this case
       //       we don't want the dialogset to die, since the UAC usage is not complete.     
       (getCreator() == 0 || (mState != Initial && mState != ReceivedProvisional)) &&
-      mClientOutOfDialogRequests.empty() &&
+      // mClientOutOfDialogRequests.empty() &&
       !(mClientPublication ||
-        mServerOutOfDialogRequest ||
+      //   mServerOutOfDialogRequest ||
         mClientPagerMessage ||
         mServerPagerMessage ||
-        mClientRegistration ||
-        mServerRegistration))
+        mClientRegistration/*  ||
+        mServerRegistration */))
    {
       mState = Destroying;
       mDum.destroy(this);
@@ -325,62 +325,62 @@ DialogSet::dispatch(const SipMessage& msg)
          switch(method)
          {
             case INVITE:
-               if (code / 100 == 1)
-               {
-                  mState = ReceivedProvisional;
-                  end();
-               }
-               else if (code / 100 == 2)
-               {
-                  Dialog dialog(mDum, msg, *this);
-
-                  auto ack = std::make_shared<SipMessage>();
-                  dialog.makeRequest(*ack, ACK);
-                  ack->header(h_CSeq).sequence() = msg.header(h_CSeq).sequence();
-                  dialog.send(ack);
+               // if (code / 100 == 1)
+               // {
+               //    mState = ReceivedProvisional;
+               //    end();
+               // }
+               // else if (code / 100 == 2)
+               // {
+               //    Dialog dialog(mDum, msg, *this);
+
+               //    auto ack = std::make_shared<SipMessage>();
+               //    dialog.makeRequest(*ack, ACK);
+               //    ack->header(h_CSeq).sequence() = msg.header(h_CSeq).sequence();
+               //    dialog.send(ack);
                   
-                  auto bye = std::make_shared<SipMessage>();
-                  dialog.makeRequest(*bye, BYE);
-                  addEndReasonToMessage(*bye);
-                  dialog.send(bye);
+               //    auto bye = std::make_shared<SipMessage>();
+               //    dialog.makeRequest(*bye, BYE);
+               //    addEndReasonToMessage(*bye);
+               //    dialog.send(bye);
                   
-                  if (mDum.mDialogEventStateManager)
-                  {
-                     mDum.mDialogEventStateManager->onTerminated(dialog, *bye, InviteSessionHandler::LocalBye);
-                  }
-                  // Note:  Destruction of this dialog object will cause DialogSet::possiblyDie to be called thus invoking mDum.destroy
-               }
-               else
-               {
-                  if (mDum.mDialogEventStateManager)
-                  {
-                     mDum.mDialogEventStateManager->onTerminated(*this, msg, InviteSessionHandler::Rejected);
-                  }           
-                  mState = Destroying;
-                  mDum.destroy(this);
-               }
+               //    if (mDum.mDialogEventStateManager)
+               //    {
+               //       mDum.mDialogEventStateManager->onTerminated(dialog, *bye, InviteSessionHandler::LocalBye);
+               //    }
+               //    // Note:  Destruction of this dialog object will cause DialogSet::possiblyDie to be called thus invoking mDum.destroy
+               // }
+               // else
+               // {
+               //    if (mDum.mDialogEventStateManager)
+               //    {
+               //       mDum.mDialogEventStateManager->onTerminated(*this, msg, InviteSessionHandler::Rejected);
+               //    }           
+               //    mState = Destroying;
+               //    mDum.destroy(this);
+               // }
                break;
             case SUBSCRIBE:
-               if (code / 100 == 1)
-               {
-                  // do nothing - wait for final response
-               }
-               else if ((code / 100 == 2) && getCreator())
-               {
-                  Dialog dialog(mDum, msg, *this);
-
-                  auto unsubscribe = std::make_shared<SipMessage>(*getCreator()->getLastRequest());  // create message from initial request so we get proper headers
-                  dialog.makeRequest(*unsubscribe, SUBSCRIBE);
-                  unsubscribe->header(h_Expires).value() = 0;
-                  dialog.send(unsubscribe);
+               // if (code / 100 == 1)
+               // {
+               //    // do nothing - wait for final response
+               // }
+               // else if ((code / 100 == 2) && getCreator())
+               // {
+               //    Dialog dialog(mDum, msg, *this);
+
+               //    auto unsubscribe = std::make_shared<SipMessage>(*getCreator()->getLastRequest());  // create message from initial request so we get proper headers
+               //    dialog.makeRequest(*unsubscribe, SUBSCRIBE);
+               //    unsubscribe->header(h_Expires).value() = 0;
+               //    dialog.send(unsubscribe);
                   
-                  // Note:  Destruction of this dialog object will cause DialogSet::possiblyDie to be called thus invoking mDum.destroy
-               }
-               else
-               {
-                  mState = Destroying;
-                  mDum.destroy(this);
-               }
+               //    // Note:  Destruction of this dialog object will cause DialogSet::possiblyDie to be called thus invoking mDum.destroy
+               // }
+               // else
+               // {
+               //    mState = Destroying;
+               //    mDum.destroy(this);
+               // }
                break;
             case PUBLISH:
                if (code / 100 == 1)
@@ -554,38 +554,38 @@ DialogSet::dispatch(const SipMessage& msg)
             break;
             
          case REFER:
-            if (dialog)
-            {
-               DebugLog(<< "in dialog refer request");
-               break; // in dialog
-            }
-            else if (request.header(h_To).exists(p_tag))
-            {
-                // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
-                auto response = std::make_shared<SipMessage>();
-                mDum.makeResponse(*response, msg, 481);
-                mDum.send(response);
-                return;
-            }
-            // We have an out-of-dialog request, check if it needs an implied subscription dialog
-            else if((request.exists(h_ReferSub) && 
-                     request.header(h_ReferSub).isWellFormed() &&
-                     request.header(h_ReferSub).value()=="false") ||
-                     (request.exists(h_Requires) &&
-                     request.header(h_Requires).find(Token("norefersub"))))// out of dialog & noReferSub=true
-            {
-               // No dialog needed here
-               DebugLog(<< "out of dialog refer request with norefersub");
-               resip_assert(mServerOutOfDialogRequest == 0);
-               mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-               mServerOutOfDialogRequest->dispatch(request);
-               return;
-            }
-            else
-            {
-               DebugLog(<< "out of dialog refer request with refer sub");
-               break; // dialog creating
-            }
+            // if (dialog)
+            // {
+            //    DebugLog(<< "in dialog refer request");
+            //    break; // in dialog
+            // }
+            // else if (request.header(h_To).exists(p_tag))
+            // {
+            //     // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
+            //     auto response = std::make_shared<SipMessage>();
+            //     mDum.makeResponse(*response, msg, 481);
+            //     mDum.send(response);
+            //     return;
+            // }
+            // // We have an out-of-dialog request, check if it needs an implied subscription dialog
+            // else if((request.exists(h_ReferSub) && 
+            //          request.header(h_ReferSub).isWellFormed() &&
+            //          request.header(h_ReferSub).value()=="false") ||
+            //          (request.exists(h_Requires) &&
+            //          request.header(h_Requires).find(Token("norefersub"))))// out of dialog & noReferSub=true
+            // {
+            //    // No dialog needed here
+            //    DebugLog(<< "out of dialog refer request with norefersub");
+            //    // resip_assert(mServerOutOfDialogRequest == 0);
+            //    // mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+            //    // mServerOutOfDialogRequest->dispatch(request);
+            //    return;
+            // }
+            // else
+            // {
+            //    DebugLog(<< "out of dialog refer request with refer sub");
+            //    break; // dialog creating
+            // }
             break;
 
          case NOTIFY:
@@ -605,9 +605,9 @@ DialogSet::dispatch(const SipMessage& msg)
             {
                // unsolicited - not allowed but commonly implemented
                // by large companies with a bridge as their logo
-               resip_assert(mServerOutOfDialogRequest == 0);
-               mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-               mServerOutOfDialogRequest->dispatch(request);
+               // resip_assert(mServerOutOfDialogRequest == 0);
+               // mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+               // mServerOutOfDialogRequest->dispatch(request);
                return;
             }
             break;
@@ -618,11 +618,11 @@ DialogSet::dispatch(const SipMessage& msg)
             
          case REGISTER:
             // !jf! move this to DialogUsageManager
-            if (mServerRegistration == 0)
-            {
-               mServerRegistration = makeServerRegistration(request);
-            }
-            mServerRegistration->dispatch(request);
+            // if (mServerRegistration == 0)
+            // {
+            //    mServerRegistration = makeServerRegistration(request);
+            // }
+            // mServerRegistration->dispatch(request);
             return;
 
          case MESSAGE:
@@ -639,9 +639,9 @@ DialogSet::dispatch(const SipMessage& msg)
             // !jf! move this to DialogUsageManager
             DebugLog ( << "In DialogSet::dispatch, default(ServerOutOfDialogRequest), msg: " << msg );
             // only can be one ServerOutOfDialogReq at a time
-            resip_assert(mServerOutOfDialogRequest == 0);
-            mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-            mServerOutOfDialogRequest->dispatch(request);
+            // resip_assert(mServerOutOfDialogRequest == 0);
+            // mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+            // mServerOutOfDialogRequest->dispatch(request);
             return;
       }
    }
@@ -795,19 +795,19 @@ DialogSet::dispatch(const SipMessage& msg)
             
          default:
          {
-            ClientOutOfDialogReq* req = findMatchingClientOutOfDialogReq(response);
-            if (req == 0)
-            {
-               // We should only create a new ClientOutOfDialogReq if this is a response to our initial request
-               if (!getCreator() || !(msg.header(h_CSeq) == getCreator()->getLastRequest()->header(h_CSeq)))
-               {
-                  InfoLog(<< "Cannot create a ClientOutOfDialogReq, initial dialog request is missing or cseq does not match, ignoring.");
-                  return;
-               }
-               req = makeClientOutOfDialogReq(response);
-               mClientOutOfDialogRequests.push_back(req);
-            }
-            req->dispatch(response);
+            // ClientOutOfDialogReq* req = findMatchingClientOutOfDialogReq(response);
+            // if (req == 0)
+            // {
+            //    // We should only create a new ClientOutOfDialogReq if this is a response to our initial request
+            //    if (!getCreator() || !(msg.header(h_CSeq) == getCreator()->getLastRequest()->header(h_CSeq)))
+            //    {
+            //       InfoLog(<< "Cannot create a ClientOutOfDialogReq, initial dialog request is missing or cseq does not match, ignoring.");
+            //       return;
+            //    }
+            //    req = makeClientOutOfDialogReq(response);
+            //    mClientOutOfDialogRequests.push_back(req);
+            // }
+            // req->dispatch(response);
             return;
          }
       }
@@ -935,19 +935,19 @@ DialogSet::dispatch(const SipMessage& msg)
 }
 
 
-ClientOutOfDialogReq*
-DialogSet::findMatchingClientOutOfDialogReq(const SipMessage& msg)
-{
-   for (std::list<ClientOutOfDialogReq*>::iterator i=mClientOutOfDialogRequests.begin();
-        i != mClientOutOfDialogRequests.end(); ++i)
-   {
-      if ((*i)->matches(msg))
-      {
-         return *i;
-      }
-   }
-   return 0;
-}
+// ClientOutOfDialogReq*
+// DialogSet::findMatchingClientOutOfDialogReq(const SipMessage& msg)
+// {
+//    for (std::list<ClientOutOfDialogReq*>::iterator i=mClientOutOfDialogRequests.begin();
+//         i != mClientOutOfDialogRequests.end(); ++i)
+//    {
+//       if ((*i)->matches(msg))
+//       {
+//          return *i;
+//       }
+//    }
+//    return 0;
+// }
 
 Dialog*
 DialogSet::findDialog(const DialogId id)
@@ -1110,18 +1110,18 @@ DialogSet::getClientRegistration()
    }
 }
 
-ServerRegistrationHandle
-DialogSet::getServerRegistration()
-{
-   if (mServerRegistration)
-   {
-      return mServerRegistration->getHandle();
-   }
-   else
-   {
-      return ServerRegistrationHandle::NotValid();
-   }
-}
+// ServerRegistrationHandle
+// DialogSet::getServerRegistration()
+// {
+//    if (mServerRegistration)
+//    {
+//       return mServerRegistration->getHandle();
+//    }
+//    else
+//    {
+//       return ServerRegistrationHandle::NotValid();
+//    }
+// }
 
 ClientPublicationHandle
 DialogSet::getClientPublication()
@@ -1152,25 +1152,25 @@ DialogSet::makeClientPublication(const SipMessage& response)
    return new ClientPublication(mDum, *this, creator->getLastRequest());
 }
 
-ClientOutOfDialogReq*
-DialogSet::makeClientOutOfDialogReq(const SipMessage& response)
-{
-   BaseCreator* creator = getCreator();
-   resip_assert(creator);
-   return new ClientOutOfDialogReq(mDum, *this, *creator->getLastRequest());
-}
-
-ServerRegistration*
-DialogSet::makeServerRegistration(const SipMessage& request)
-{
-   return new ServerRegistration(mDum, *this, request);
-}
-
-ServerOutOfDialogReq*
-DialogSet::makeServerOutOfDialog(const SipMessage& request)
-{
-   return new ServerOutOfDialogReq(mDum, *this, request);
-}
+// ClientOutOfDialogReq*
+// DialogSet::makeClientOutOfDialogReq(const SipMessage& response)
+// {
+//    BaseCreator* creator = getCreator();
+//    resip_assert(creator);
+//    return new ClientOutOfDialogReq(mDum, *this, *creator->getLastRequest());
+// }
+
+// ServerRegistration*
+// DialogSet::makeServerRegistration(const SipMessage& request)
+// {
+//    return new ServerRegistration(mDum, *this, request);
+// }
+
+// ServerOutOfDialogReq*
+// DialogSet::makeServerOutOfDialog(const SipMessage& request)
+// {
+//    return new ServerOutOfDialogReq(mDum, *this, request);
+// }
 
 ServerPagerMessage*
 DialogSet::makeServerPagerMessage(const SipMessage& request)
@@ -1178,18 +1178,18 @@ DialogSet::makeServerPagerMessage(const SipMessage& request)
    return new ServerPagerMessage(mDum, *this, request);
 }
 
-ServerOutOfDialogReqHandle
-DialogSet::getServerOutOfDialog()
-{
-   if (mServerOutOfDialogRequest)
-   {
-      return mServerOutOfDialogRequest->getHandle();
-   }
-   else
-   {
-      return ServerOutOfDialogReqHandle::NotValid();
-   }
-}
+// ServerOutOfDialogReqHandle
+// DialogSet::getServerOutOfDialog()
+// {
+//    if (mServerOutOfDialogRequest)
+//    {
+//       return mServerOutOfDialogRequest->getHandle();
+//    }
+//    else
+//    {
+//       return ServerOutOfDialogReqHandle::NotValid();
+//    }
+// }
 
 void DialogSet::dispatchToAllDialogs(const SipMessage& msg)
 {
diff --git a/resip/dum/DialogSet.hxx b/resip/dum/DialogSet.hxx
old mode 100644
new mode 100755
index 71fbcd4cb..81b885d7e
--- a/resip/dum/DialogSet.hxx
+++ b/resip/dum/DialogSet.hxx
@@ -43,10 +43,10 @@ class DialogSet
       void dispatch(const SipMessage& msg);
       
       ClientRegistrationHandle getClientRegistration();
-      ServerRegistrationHandle getServerRegistration();
+      // ServerRegistrationHandle getServerRegistration();
       ClientPublicationHandle getClientPublication();
-      ClientOutOfDialogReqHandle getClientOutOfDialog();
-      ServerOutOfDialogReqHandle getServerOutOfDialog();
+      // ClientOutOfDialogReqHandle getClientOutOfDialog();
+      // ServerOutOfDialogReqHandle getServerOutOfDialog();
 
       bool isDestroying() const noexcept { return mState == Destroying; };
 
@@ -92,14 +92,14 @@ class DialogSet
       Dialog* findDialog(const SipMessage& msg);
       Dialog* findDialog(const DialogId id);
 
-      ClientOutOfDialogReq* findMatchingClientOutOfDialogReq(const SipMessage& msg);
+      // ClientOutOfDialogReq* findMatchingClientOutOfDialogReq(const SipMessage& msg);
 
       ClientRegistration* makeClientRegistration(const SipMessage& msg);
       ClientPublication* makeClientPublication( const SipMessage& msg);
-      ClientOutOfDialogReq* makeClientOutOfDialogReq(const SipMessage& msg);
+      // ClientOutOfDialogReq* makeClientOutOfDialogReq(const SipMessage& msg);
 
-      ServerRegistration* makeServerRegistration(const SipMessage& msg);
-      ServerOutOfDialogReq* makeServerOutOfDialog(const SipMessage& msg);
+      // ServerRegistration* makeServerRegistration(const SipMessage& msg);
+      // ServerOutOfDialogReq* makeServerOutOfDialog(const SipMessage& msg);
       
       ServerPagerMessage* makeServerPagerMessage(const SipMessage& request);      
 
@@ -117,10 +117,10 @@ class DialogSet
       AppDialogSet* mAppDialogSet;
       State mState;
       ClientRegistration* mClientRegistration;
-      ServerRegistration* mServerRegistration;
+      // ServerRegistration* mServerRegistration;
       ClientPublication* mClientPublication;
-      std::list<ClientOutOfDialogReq*> mClientOutOfDialogRequests;
-      ServerOutOfDialogReq* mServerOutOfDialogRequest;
+      // std::list<ClientOutOfDialogReq*> mClientOutOfDialogRequests;
+      // ServerOutOfDialogReq* mServerOutOfDialogRequest;
 
       ClientPagerMessage* mClientPagerMessage;
       ServerPagerMessage* mServerPagerMessage;
diff --git a/resip/dum/DialogSetId.cxx b/resip/dum/DialogSetId.cxx
old mode 100644
new mode 100755
index 266a2bf95..33e067971
--- a/resip/dum/DialogSetId.cxx
+++ b/resip/dum/DialogSetId.cxx
@@ -31,7 +31,7 @@ DialogSetId::DialogSetId(const SipMessage& msg) :
          }
          else
          {
-            //DebugLog ( <<  "********** Generated Local Tag *********** " );            
+            DebugLog ( <<  "********** Generated Local Tag *********** " );
             mTag = Helper::computeTag(Helper::tagSize);
          }
       }
diff --git a/resip/dum/DialogUsageManager.cxx b/resip/dum/DialogUsageManager.cxx
old mode 100644
new mode 100755
index e905fc28e..284bbd0d7
--- a/resip/dum/DialogUsageManager.cxx
+++ b/resip/dum/DialogUsageManager.cxx
@@ -5,24 +5,24 @@
 
 #include "resip/stack/SecurityAttributes.hxx"
 #include "resip/stack/ShutdownMessage.hxx"
-#include "resip/stack/SipFrag.hxx"
+// #include "resip/stack/SipFrag.hxx"
 #include "resip/stack/SipMessage.hxx"
 #include "resip/stack/SipStack.hxx"
 #include "resip/stack/Helper.hxx"
 #include "resip/stack/TransactionUserMessage.hxx"
 #include "resip/stack/ConnectionTerminated.hxx"
-#include "resip/stack/KeepAlivePong.hxx"
+// #include "resip/stack/KeepAlivePong.hxx"
 #include "resip/dum/AppDialog.hxx"
 #include "resip/dum/AppDialogSet.hxx"
 #include "resip/dum/AppDialogSetFactory.hxx"
 #include "resip/dum/BaseUsage.hxx"
 #include "resip/dum/ClientAuthManager.hxx"
-#include "resip/dum/ClientInviteSession.hxx"
-#include "resip/dum/ClientOutOfDialogReq.hxx"
+// #include "resip/dum/ClientInviteSession.hxx"
+// #include "resip/dum/ClientOutOfDialogReq.hxx"
 #include "resip/dum/ClientPublication.hxx"
 #include "resip/dum/ClientRegistration.hxx"
-#include "resip/dum/ClientSubscription.hxx"
-#include "resip/dum/DefaultServerReferHandler.hxx"
+// #include "resip/dum/ClientSubscription.hxx"
+// #include "resip/dum/DefaultServerReferHandler.hxx"
 #include "resip/dum/DestroyUsage.hxx"
 #include "resip/dum/Dialog.hxx"
 #include "resip/dum/DialogEventStateManager.hxx"
@@ -36,19 +36,19 @@
 #include "resip/dum/ExternalMessageHandler.hxx"
 #include "resip/dum/InviteSessionCreator.hxx"
 #include "resip/dum/InviteSessionHandler.hxx"
-#include "resip/dum/KeepAliveManager.hxx"
-#include "resip/dum/KeepAliveTimeout.hxx"
+// #include "resip/dum/KeepAliveManager.hxx"
+// #include "resip/dum/KeepAliveTimeout.hxx"
 #include "resip/dum/MasterProfile.hxx"
-#include "resip/dum/OutOfDialogReqCreator.hxx"
+// #include "resip/dum/OutOfDialogReqCreator.hxx"
 #include "resip/dum/PagerMessageCreator.hxx"
 #include "resip/dum/PublicationCreator.hxx"
 #include "resip/dum/RedirectManager.hxx"
 #include "resip/dum/RegistrationCreator.hxx"
 #include "resip/dum/RemoteCertStore.hxx"
 #include "resip/dum/RequestValidationHandler.hxx"
-#include "resip/dum/ServerAuthManager.hxx"
+// #include "resip/dum/ServerAuthManager.hxx"
 #include "resip/dum/ServerInviteSession.hxx"
-#include "resip/dum/ServerPublication.hxx"
+// #include "resip/dum/ServerPublication.hxx"
 #include "resip/dum/ServerSubscription.hxx"
 #include "resip/dum/SubscriptionCreator.hxx"
 #include "resip/dum/SubscriptionHandler.hxx"
@@ -102,12 +102,12 @@ DialogUsageManager::DialogUsageManager(SipStack& stack, bool createDefaultFeatur
    mRedirectManager(new RedirectManager()),
    mInviteSessionHandler(0),
    mClientRegistrationHandler(0),
-   mServerRegistrationHandler(0),
+   // mServerRegistrationHandler(0),
    mRedirectHandler(0),
    mDialogSetHandler(0),
    mRequestValidationHandler(0),
-   mRegistrationPersistenceManager(0),
-   mPublicationPersistenceManager(0),
+   // mRegistrationPersistenceManager(0),
+   // mPublicationPersistenceManager(0),
    mIsDefaultServerReferHandler(true),
    mClientPagerMessageHandler(0),
    mServerPagerMessageHandler(0),
@@ -121,7 +121,7 @@ DialogUsageManager::DialogUsageManager(SipStack& stack, bool createDefaultFeatur
 {
    //TODO -- create default features
    mStack.registerTransactionUser(*this);
-   addServerSubscriptionHandler("refer", new DefaultServerReferHandler());
+   // addServerSubscriptionHandler("refer", new DefaultServerReferHandler());
 
    mFifo.setDescription("DialogUsageManager::mFifo");
 
@@ -186,10 +186,10 @@ DialogUsageManager::~DialogUsageManager()
    delete mOutgoingTarget;
 
    // Delete Server Publications
-   while (!mServerPublications.empty())
-   {
-       delete mServerPublications.begin()->second;  // Deleting a ServerPublication removes itself from the map
-   }
+   // while (!mServerPublications.empty())
+   // {
+   //     delete mServerPublications.begin()->second;  // Deleting a ServerPublication removes itself from the map
+   // }
 
    // Remove any lingering incoming feature chain memory
    for(FeatureChainMap::iterator it = mIncomingFeatureChainMap.begin(); it != mIncomingFeatureChainMap.end(); it++)
@@ -325,11 +325,11 @@ void DialogUsageManager::setMasterProfile(const std::shared_ptr<MasterProfile>&
    mMasterUserProfile = masterProfile; // required so that we can return a reference to std::shared_ptr<UserProfile> in getMasterUserProfile
 }
 
-void DialogUsageManager::setKeepAliveManager(std::unique_ptr<KeepAliveManager> manager) noexcept
-{
-   mKeepAliveManager = std::move(manager);
-   mKeepAliveManager->setDialogUsageManager(this);
-}
+// void DialogUsageManager::setKeepAliveManager(std::unique_ptr<KeepAliveManager> manager) noexcept
+// {
+//    mKeepAliveManager = std::move(manager);
+//    mKeepAliveManager->setDialogUsageManager(this);
+// }
 
 void DialogUsageManager::setRedirectManager(std::unique_ptr<RedirectManager> manager) noexcept
 {
@@ -352,11 +352,11 @@ DialogUsageManager::setClientAuthManager(std::unique_ptr<ClientAuthManager> mana
    mClientAuthManager = std::move(manager);
 }
 
-void
-DialogUsageManager::setServerAuthManager(std::shared_ptr<ServerAuthManager> manager)
-{
-   mIncomingFeatureList.emplace(std::begin(mIncomingFeatureList), manager);
-}
+// void
+// DialogUsageManager::setServerAuthManager(std::shared_ptr<ServerAuthManager> manager)
+// {
+//    mIncomingFeatureList.emplace(std::begin(mIncomingFeatureList), manager);
+// }
 
 void
 DialogUsageManager::setClientRegistrationHandler(ClientRegistrationHandler* handler)
@@ -365,12 +365,12 @@ DialogUsageManager::setClientRegistrationHandler(ClientRegistrationHandler* hand
    mClientRegistrationHandler = handler;
 }
 
-void
-DialogUsageManager::setServerRegistrationHandler(ServerRegistrationHandler* handler)
-{
-   resip_assert(!mServerRegistrationHandler);
-   mServerRegistrationHandler = handler;
-}
+// void
+// DialogUsageManager::setServerRegistrationHandler(ServerRegistrationHandler* handler)
+// {
+//    resip_assert(!mServerRegistrationHandler);
+//    mServerRegistrationHandler = handler;
+// }
 
 void
 DialogUsageManager::setDialogSetHandler(DialogSetHandler* handler) noexcept
@@ -392,19 +392,19 @@ DialogUsageManager::setRequestValidationHandler(RequestValidationHandler* handle
    mRequestValidationHandler = handler;
 }
 
-void
-DialogUsageManager::setRegistrationPersistenceManager(RegistrationPersistenceManager* manager)
-{
-   resip_assert(!mRegistrationPersistenceManager);
-   mRegistrationPersistenceManager = manager;
-}
+// void
+// DialogUsageManager::setRegistrationPersistenceManager(RegistrationPersistenceManager* manager)
+// {
+//    resip_assert(!mRegistrationPersistenceManager);
+//    mRegistrationPersistenceManager = manager;
+// }
 
-void
-DialogUsageManager::setPublicationPersistenceManager(PublicationPersistenceManager* manager)
-{
-   resip_assert(!mPublicationPersistenceManager);
-   mPublicationPersistenceManager = manager;
-}
+// void
+// DialogUsageManager::setPublicationPersistenceManager(PublicationPersistenceManager* manager)
+// {
+//    resip_assert(!mPublicationPersistenceManager);
+//    mPublicationPersistenceManager = manager;
+// }
 
 void
 DialogUsageManager::addTimer(DumTimeout::Type type, unsigned long duration,
@@ -423,13 +423,13 @@ DialogUsageManager::addTimerMs(DumTimeout::Type type, unsigned long duration,
    mStack.postMS(t, duration, this);
 }
 
-void
-DialogUsageManager::addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mClientSubscriptionHandlers.find(eventType) == mClientSubscriptionHandlers.end());
-   mClientSubscriptionHandlers[eventType] = handler;
-}
+// void
+// DialogUsageManager::addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mClientSubscriptionHandlers.find(eventType) == mClientSubscriptionHandlers.end());
+//    mClientSubscriptionHandlers[eventType] = handler;
+// }
 
 void
 DialogUsageManager::addServerSubscriptionHandler(const Data& eventType, ServerSubscriptionHandler* handler)
@@ -458,21 +458,21 @@ DialogUsageManager::addClientPublicationHandler(const Data& eventType, ClientPub
    mClientPublicationHandlers[eventType] = handler;
 }
 
-void
-DialogUsageManager::addServerPublicationHandler(const Data& eventType, ServerPublicationHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mServerPublicationHandlers.find(eventType) == mServerPublicationHandlers.end());
-   mServerPublicationHandlers[eventType] = handler;
-}
+// void
+// DialogUsageManager::addServerPublicationHandler(const Data& eventType, ServerPublicationHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mServerPublicationHandlers.find(eventType) == mServerPublicationHandlers.end());
+//    mServerPublicationHandlers[eventType] = handler;
+// }
 
-void
-DialogUsageManager::addOutOfDialogHandler(MethodTypes type, OutOfDialogHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mOutOfDialogHandlers.find(type) == mOutOfDialogHandlers.end());
-   mOutOfDialogHandlers[type] = handler;
-}
+// void
+// DialogUsageManager::addOutOfDialogHandler(MethodTypes type, OutOfDialogHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mOutOfDialogHandlers.find(type) == mOutOfDialogHandlers.end());
+//    mOutOfDialogHandlers[type] = handler;
+// }
 
 void
 DialogUsageManager::setClientPagerMessageHandler(ClientPagerMessageHandler* handler) noexcept
@@ -486,32 +486,32 @@ DialogUsageManager::setServerPagerMessageHandler(ServerPagerMessageHandler* hand
    mServerPagerMessageHandler = handler;
 }
 
-void
-DialogUsageManager::addExternalMessageHandler(ExternalMessageHandler* handler)
-{
-   std::vector<ExternalMessageHandler*>::iterator found = std::find(mExternalMessageHandlers.begin(), mExternalMessageHandlers.end(), handler);
-   if (found == mExternalMessageHandlers.end())
-   {
-      mExternalMessageHandlers.push_back(handler);
-   }
-}
+// void
+// DialogUsageManager::addExternalMessageHandler(ExternalMessageHandler* handler)
+// {
+//    std::vector<ExternalMessageHandler*>::iterator found = std::find(mExternalMessageHandlers.begin(), mExternalMessageHandlers.end(), handler);
+//    if (found == mExternalMessageHandlers.end())
+//    {
+//       mExternalMessageHandlers.push_back(handler);
+//    }
+// }
 
-void 
-DialogUsageManager::removeExternalMessageHandler(ExternalMessageHandler* handler)
-{
-   std::vector<ExternalMessageHandler*>::iterator found = std::find(mExternalMessageHandlers.begin(), mExternalMessageHandlers.end(), handler);
-   if (found != mExternalMessageHandlers.end())
-   {
-      mExternalMessageHandlers.erase(found);
-   }
-}
+// void 
+// DialogUsageManager::removeExternalMessageHandler(ExternalMessageHandler* handler)
+// {
+//    std::vector<ExternalMessageHandler*>::iterator found = std::find(mExternalMessageHandlers.begin(), mExternalMessageHandlers.end(), handler);
+//    if (found != mExternalMessageHandlers.end())
+//    {
+//       mExternalMessageHandlers.erase(found);
+//    }
+// }
 
-void 
-DialogUsageManager::clearExternalMessageHandler()
-{
-   std::vector<ExternalMessageHandler*> empty;
-   empty.swap(mExternalMessageHandlers);
-}
+// void 
+// DialogUsageManager::clearExternalMessageHandler()
+// {
+//    std::vector<ExternalMessageHandler*> empty;
+//    empty.swap(mExternalMessageHandlers);
+// }
 
 
 DialogSet*
@@ -563,262 +563,262 @@ DialogUsageManager::sendResponse(const SipMessage& response)
    mStack.send(response, this);
 }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* appDs)
-{
-   return makeInviteSession(target, userProfile, initialOffer, None, nullptr, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* appDs)
-{
-   return makeInviteSession(target, getMasterUserProfile(), initialOffer, None, nullptr, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative, 
-                                      AppDialogSet* appDs)
-{
-   auto inv = makeNewSession(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative), appDs);
-   DumHelper::setOutgoingEncryptionLevel(*inv, level);
-   return inv;
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative,
-                                      AppDialogSet* appDs)
-{
-   return makeInviteSession(target, getMasterUserProfile(), initialOffer, level, alternative, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target,
-    const DialogSetId& dialogSetId,
-    const std::shared_ptr<UserProfile>& userProfile,
-    const Contents* initialOffer,
-    EncryptionLevel level,
-    const Contents* alternative,
-    AppDialogSet* appDs)
-{
-    resip_assert(mDialogSetMap.find(dialogSetId) == mDialogSetMap.end());
-    BaseCreator* baseCreator(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative));
-    baseCreator->getLastRequest()->header(h_CallID).value() = dialogSetId.getCallId();
-    baseCreator->getLastRequest()->header(h_From).param(p_tag) = dialogSetId.getLocalTag();
-    auto inv = makeNewSession(baseCreator, appDs);
-    DumHelper::setOutgoingEncryptionLevel(*inv, level);
-    return inv;
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, userProfile, initialOffer, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, userProfile, initialOffer, None, nullptr, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative, 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, userProfile, initialOffer, level, alternative, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, getMasterUserProfile(), initialOffer, None, nullptr, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative , 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, initialOffer, level, alternative, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative, 
+//                                       AppDialogSet* appDs)
+// {
+//    auto inv = makeNewSession(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative), appDs);
+//    DumHelper::setOutgoingEncryptionLevel(*inv, level);
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               AppDialogSet* appDs)
-{
-   return makeInviteSessionFromRefer(refer, serverSub, initialOffer, None, 0, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative,
+//                                       AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, getMasterUserProfile(), initialOffer, level, alternative, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               const std::shared_ptr<UserProfile>& userProfile,
-                                               const Contents* initialOffer,
-                                               AppDialogSet* appDs)
-{
-   ServerSubscriptionHandle empty;
-   return makeInviteSessionFromRefer(refer, userProfile, empty, initialOffer, None, 0, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target,
+//     const DialogSetId& dialogSetId,
+//     const std::shared_ptr<UserProfile>& userProfile,
+//     const Contents* initialOffer,
+//     EncryptionLevel level,
+//     const Contents* alternative,
+//     AppDialogSet* appDs)
+// {
+//     resip_assert(mDialogSetMap.find(dialogSetId) == mDialogSetMap.end());
+//     BaseCreator* baseCreator(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative));
+//     baseCreator->getLastRequest()->header(h_CallID).value() = dialogSetId.getCallId();
+//     baseCreator->getLastRequest()->header(h_From).param(p_tag) = dialogSetId.getLocalTag();
+//     auto inv = makeNewSession(baseCreator, appDs);
+//     DumHelper::setOutgoingEncryptionLevel(*inv, level);
+//     return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               EncryptionLevel level,
-                                               const Contents* alternative,
-                                               AppDialogSet* appDs)
-{
-   return makeInviteSessionFromRefer(refer, serverSub.isValid() ? serverSub->mDialog.mDialogSet.getUserProfile() : getMasterUserProfile(), serverSub, initialOffer, level, alternative, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, userProfile, initialOffer, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               const std::shared_ptr<UserProfile>& userProfile,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               EncryptionLevel level,
-                                               const Contents* alternative,
-                                               AppDialogSet* appDs)
-{
-   if (serverSub.isValid())
-   {
-      DebugLog(<< "implicit subscription");
-      //generate and send 100
-      SipFrag contents;
-      contents.message().header(h_StatusLine).statusCode() = 100;
-      contents.message().header(h_StatusLine).reason() = "Trying";
-      //will be cloned...ServerSub may not have the most efficient API possible
-      serverSub->setSubscriptionState(Active);
-      auto notify = serverSub->update(&contents);
-//   mInviteSessionHandler->onReadyToSend(InviteSessionHandle::NotValid(), notify);
-      serverSub->send(notify);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative, 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, userProfile, initialOffer, level, alternative, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-   //19.1.5
-   NameAddr target = refer.header(h_ReferTo);
-   target.uri().removeEmbedded();
-   target.uri().remove(p_method);
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative , 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, initialOffer, level, alternative, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-   // !jf! this code assumes you have a UserProfile
-   auto inv = makeNewSession(new InviteSessionCreator(*this,
-                                                      target,
-                                                      userProfile,
-                                                      initialOffer, level, alternative, serverSub), appDs);
-   DumHelper::setOutgoingEncryptionLevel(*inv, level);
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                AppDialogSet* appDs)
+// {
+//    return makeInviteSessionFromRefer(refer, serverSub, initialOffer, None, 0, appDs);
+// }
 
-   //could pass dummy target, then apply merge rules from 19.1.5...or
-   //makeNewSession would use rules from 19.1.5
-   if (refer.exists(h_ReferredBy))
-   {
-      inv->header(h_ReferredBy) = refer.header(h_ReferredBy);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                const std::shared_ptr<UserProfile>& userProfile,
+//                                                const Contents* initialOffer,
+//                                                AppDialogSet* appDs)
+// {
+//    ServerSubscriptionHandle empty;
+//    return makeInviteSessionFromRefer(refer, userProfile, empty, initialOffer, None, 0, appDs);
+// }
 
-   const Uri& referTo = refer.header(h_ReferTo).uri();
-   //19.1.5
-   if (referTo.hasEmbedded() && referTo.embedded().exists(h_Replaces))
-   {
-      inv->header(h_Replaces) = referTo.embedded().header(h_Replaces);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                EncryptionLevel level,
+//                                                const Contents* alternative,
+//                                                AppDialogSet* appDs)
+// {
+//    return makeInviteSessionFromRefer(refer, serverSub.isValid() ? serverSub->mDialog.mDialogSet.getUserProfile() : getMasterUserProfile(), serverSub, initialOffer, level, alternative, appDs);
+// }
 
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                const std::shared_ptr<UserProfile>& userProfile,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                EncryptionLevel level,
+//                                                const Contents* alternative,
+//                                                AppDialogSet* appDs)
+// {
+//    if (serverSub.isValid())
+//    {
+//       DebugLog(<< "implicit subscription");
+//       //generate and send 100
+//       SipFrag contents;
+//       contents.message().header(h_StatusLine).statusCode() = 100;
+//       contents.message().header(h_StatusLine).reason() = "Trying";
+//       //will be cloned...ServerSub may not have the most efficient API possible
+//       serverSub->setSubscriptionState(Active);
+//       auto notify = serverSub->update(&contents);
+// //   mInviteSessionHandler->onReadyToSend(InviteSessionHandle::NotValid(), notify);
+//       serverSub->send(notify);
+//    }
+
+//    //19.1.5
+//    NameAddr target = refer.header(h_ReferTo);
+//    target.uri().removeEmbedded();
+//    target.uri().remove(p_method);
+
+//    // !jf! this code assumes you have a UserProfile
+//    auto inv = makeNewSession(new InviteSessionCreator(*this,
+//                                                       target,
+//                                                       userProfile,
+//                                                       initialOffer, level, alternative, serverSub), appDs);
+//    DumHelper::setOutgoingEncryptionLevel(*inv, level);
+
+//    //could pass dummy target, then apply merge rules from 19.1.5...or
+//    //makeNewSession would use rules from 19.1.5
+//    if (refer.exists(h_ReferredBy))
+//    {
+//       inv->header(h_ReferredBy) = refer.header(h_ReferredBy);
+//    }
+
+//    const Uri& referTo = refer.header(h_ReferTo).uri();
+//    //19.1.5
+//    if (referTo.hasEmbedded() && referTo.embedded().exists(h_Replaces))
+//    {
+//       inv->header(h_Replaces) = referTo.embedded().header(h_Replaces);
+//    }
+
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, referTo), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, referTo), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), referTo), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), referTo), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* appDs)
-{
-   resip_assert(userProfile.get());
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, userProfile->getDefaultSubscriptionTime()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* appDs)
+// {
+//    resip_assert(userProfile.get());
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, userProfile->getDefaultSubscriptionTime()), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                     uint32_t subscriptionTime, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+//                                      uint32_t subscriptionTime, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                     uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime, refreshInterval), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+//                                      uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime, refreshInterval), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, getMasterProfile()->getDefaultSubscriptionTime()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, getMasterProfile()->getDefaultSubscriptionTime()), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
-                                     uint32_t subscriptionTime, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
+//                                      uint32_t subscriptionTime, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
-                                     uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime, refreshInterval), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
+//                                      uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime, refreshInterval), appDs);
+// }
 
 std::shared_ptr<SipMessage>
 DialogUsageManager::makeRegistration(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* appDs)
@@ -866,17 +866,17 @@ DialogUsageManager::makePublication(const NameAddr& targetDocument,
    return makeNewSession(new PublicationCreator(*this, targetDocument, getMasterUserProfile(), body, eventType, expiresSeconds), appDs);
 }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const MethodTypes meth, AppDialogSet* appDs)
-{
-   return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, userProfile), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const MethodTypes meth, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, userProfile), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const MethodTypes meth, AppDialogSet* appDs)
-{
-   return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, getMasterUserProfile()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const MethodTypes meth, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, getMasterUserProfile()), appDs);
+// }
 
 ClientPagerMessageHandle
 DialogUsageManager::makePagerMessage(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* appDs)
@@ -1380,18 +1380,18 @@ DialogUsageManager::internalProcess(std::unique_ptr<Message> msg)
       }
    }
    
-   {
-      KeepAlivePong* pong = dynamic_cast<KeepAlivePong*>(msg.get());
-      if (pong)
-      {
-         DebugLog(<< "keepalive pong received from " << pong->getFlow());
-         if (mKeepAliveManager.get())
-         {
-            mKeepAliveManager->receivedPong(pong->getFlow());
-         }
-         return;
-      }
-   }
+   // {
+   //    KeepAlivePong* pong = dynamic_cast<KeepAlivePong*>(msg.get());
+   //    if (pong)
+   //    {
+   //       DebugLog(<< "keepalive pong received from " << pong->getFlow());
+   //       if (mKeepAliveManager.get())
+   //       {
+   //          mKeepAliveManager->receivedPong(pong->getFlow());
+   //       }
+   //       return;
+   //    }
+   // }
 
    {
       DestroyUsage* destroyUsage = dynamic_cast<DestroyUsage*>(msg.get());
@@ -1417,31 +1417,31 @@ DialogUsageManager::internalProcess(std::unique_ptr<Message> msg)
       }
    }
 
-   {
-      KeepAliveTimeout* keepAliveMsg = dynamic_cast<KeepAliveTimeout*>(msg.get());
-      if (keepAliveMsg)
-      {
-         //DebugLog(<< "Keep Alive Message" );
-         if (mKeepAliveManager.get())
-         {
-            mKeepAliveManager->process(*keepAliveMsg);
-         }
-         return;
-      }
-   }
-
-   {
-      KeepAlivePongTimeout* keepAlivePongMsg = dynamic_cast<KeepAlivePongTimeout*>(msg.get());
-      if (keepAlivePongMsg)
-      {
-         //DebugLog(<< "Keep Alive Pong Message" );
-         if (mKeepAliveManager.get())
-         {
-            mKeepAliveManager->process(*keepAlivePongMsg);
-         }
-         return;
-      }
-   }
+   // {
+   //    KeepAliveTimeout* keepAliveMsg = dynamic_cast<KeepAliveTimeout*>(msg.get());
+   //    if (keepAliveMsg)
+   //    {
+   //       //DebugLog(<< "Keep Alive Message" );
+   //       if (mKeepAliveManager.get())
+   //       {
+   //          mKeepAliveManager->process(*keepAliveMsg);
+   //       }
+   //       return;
+   //    }
+   // }
+
+   // {
+   //    KeepAlivePongTimeout* keepAlivePongMsg = dynamic_cast<KeepAlivePongTimeout*>(msg.get());
+   //    if (keepAlivePongMsg)
+   //    {
+   //       //DebugLog(<< "Keep Alive Pong Message" );
+   //       if (mKeepAliveManager.get())
+   //       {
+   //          mKeepAliveManager->process(*keepAlivePongMsg);
+   //       }
+   //       return;
+   //    }
+   // }
 
    {
       ConnectionTerminated* terminated = dynamic_cast<ConnectionTerminated*>(msg.get());
@@ -1496,32 +1496,32 @@ DialogUsageManager::internalProcess(std::unique_ptr<Message> msg)
       }
    }
 
-   {
-      ExternalMessageBase* externalMessage = dynamic_cast<ExternalMessageBase*>(msg.get());
-      if (externalMessage)
-      {
-         processExternalMessage(externalMessage);
-         return;
-      }
-   }
+   // {
+   //    ExternalMessageBase* externalMessage = dynamic_cast<ExternalMessageBase*>(msg.get());
+   //    if (externalMessage)
+   //    {
+   //       processExternalMessage(externalMessage);
+   //       return;
+   //    }
+   // }
 
    incomingProcess(std::move(msg));
 }
 
-void
-DialogUsageManager::processExternalMessage(ExternalMessageBase* externalMessage)
-{
-   bool handled = false;
-   for(std::vector<ExternalMessageHandler*>::iterator i = mExternalMessageHandlers.begin(); 
-      i != mExternalMessageHandlers.end(); ++i)
-   {
-      (*i)->onMessage(externalMessage, handled);
-      if (handled)
-      {
-         break;
-      }
-   }
-}
+// void
+// DialogUsageManager::processExternalMessage(ExternalMessageBase* externalMessage)
+// {
+//    bool handled = false;
+//    for(std::vector<ExternalMessageHandler*>::iterator i = mExternalMessageHandlers.begin(); 
+//       i != mExternalMessageHandlers.end(); ++i)
+//    {
+//       (*i)->onMessage(externalMessage, handled);
+//       if (handled)
+//       {
+//          break;
+//       }
+//    }
+// }
 
 void 
 DialogUsageManager::incomingProcess(std::unique_ptr<Message> msg)
@@ -1676,10 +1676,45 @@ DialogUsageManager::incomingProcess(std::unique_ptr<Message> msg)
             }
             if (sipMsg->header(h_From).exists(p_tag))
             {
-               if (mergeRequest(*sipMsg) )
+               // if (mergeRequest(*sipMsg) )
+               // {
+               //    InfoLog (<< "Merged request: " << *sipMsg);
+               //    return;
+               // }
+            }
+            if (sipMsg->header(h_RequestLine).method() == ACK
+               && ((!sipMsg->header(h_To).exists(p_tag))
+                     || (sipMsg->header(h_To).exists(p_tag) && sipMsg->header(h_To).param(p_tag) == "1533684873")
+                  )
+               )
+            {
+               auto it = mDialogSetMap.begin();
+               for (; it != mDialogSetMap.end(); it++)
                {
-                  InfoLog (<< "Merged request: " << *sipMsg);
-                  return;
+                  if (it->first.getCallId() == sipMsg->header(h_CallId).value())
+                  {
+                     break;
+                  }
+               }
+               if (it != mDialogSetMap.end())
+               {
+                  sipMsg->header(h_To).param(p_tag) = it->first.getLocalTag();
+               }
+            }
+            if (sipMsg->header(h_RequestLine).method() == INFO
+               && !sipMsg->header(h_To).exists(p_tag))
+            {
+               auto it = mDialogSetMap.begin();
+               for (; it != mDialogSetMap.end(); it++)
+               {
+                  if (it->first.getCallId() == sipMsg->header(h_CallId).value())
+                  {
+                     break;
+                  }
+               }
+               if (it != mDialogSetMap.end())
+               {
+                  sipMsg->header(h_To).param(p_tag) = it->first.getLocalTag();
                }
             }
             processRequest(*sipMsg);
@@ -2056,7 +2091,7 @@ DialogUsageManager::processRequest(const SipMessage& request)
 
    if (request.header(h_RequestLine).method() == PUBLISH)
    {
-      processPublish(request);
+      // processPublish(request);
       return;
    }
 
@@ -2244,65 +2279,65 @@ DialogUsageManager::processResponse(const SipMessage& response)
    }
 }
 
-void
-DialogUsageManager::processPublish(const SipMessage& request)
-{
-   if (!checkEventPackage(request))
-   {
-      InfoLog(<< "Rejecting request (unsupported package) " << request.brief());
-      return;
-   }
-
-   if (request.exists(h_SIPIfMatch))
-   {
-      ServerPublications::iterator i = mServerPublications.find(request.header(h_SIPIfMatch).value());
-      if (i != mServerPublications.end())
-      {
-         i->second->dispatch(request);
-      }
-      else
-      {
-         // Check if publication exists in PublicationDb - may have been sync'd over,
-         // or exists from a restart.  In this case, fabricate a new ServerSubcription 
-         // to handle this request.
-         if (mPublicationPersistenceManager &&
-             mPublicationPersistenceManager->documentExists(request.header(h_Event).value(), request.header(h_RequestLine).uri().getAor(), request.header(h_SIPIfMatch).value()))
-         {
-            ServerPublication* sp = new ServerPublication(*this, request.header(h_SIPIfMatch).value(), request);
-            mServerPublications[request.header(h_SIPIfMatch).value()] = sp;
-            sp->dispatch(request);
-         }
-         else
-         {
-            auto response = std::make_shared<SipMessage>();
-            makeResponse(*response, request, 412);
-            send(response);
-         }
-      }
-   }
-   else
-   {
-      Data etag = Random::getCryptoRandomHex(8);
-      while (mServerPublications.find(etag) != mServerPublications.end())
-      {
-         etag = Random::getCryptoRandomHex(8);
-      }
-
-      if (request.getContents())
-      {
-         ServerPublication* sp = new ServerPublication(*this, etag, request);
-         mServerPublications[etag] = sp;
-         sp->dispatch(request);
-      }
-      else
-      {
-         // per 3903 (sec 6.5), a PUB w/ no SIPIfMatch must have contents. .mjf.
-         auto response = std::make_shared<SipMessage>();
-         makeResponse(*response, request, 400);
-         send(response);
-      }
-   }
-}
+// void
+// DialogUsageManager::processPublish(const SipMessage& request)
+// {
+//    if (!checkEventPackage(request))
+//    {
+//       InfoLog(<< "Rejecting request (unsupported package) " << request.brief());
+//       return;
+//    }
+
+//    if (request.exists(h_SIPIfMatch))
+//    {
+//       ServerPublications::iterator i = mServerPublications.find(request.header(h_SIPIfMatch).value());
+//       if (i != mServerPublications.end())
+//       {
+//          i->second->dispatch(request);
+//       }
+//       else
+//       {
+//          // Check if publication exists in PublicationDb - may have been sync'd over,
+//          // or exists from a restart.  In this case, fabricate a new ServerSubcription 
+//          // to handle this request.
+//          if (mPublicationPersistenceManager &&
+//              mPublicationPersistenceManager->documentExists(request.header(h_Event).value(), request.header(h_RequestLine).uri().getAor(), request.header(h_SIPIfMatch).value()))
+//          {
+//             ServerPublication* sp = new ServerPublication(*this, request.header(h_SIPIfMatch).value(), request);
+//             mServerPublications[request.header(h_SIPIfMatch).value()] = sp;
+//             sp->dispatch(request);
+//          }
+//          else
+//          {
+//             auto response = std::make_shared<SipMessage>();
+//             makeResponse(*response, request, 412);
+//             send(response);
+//          }
+//       }
+//    }
+//    else
+//    {
+//       Data etag = Random::getCryptoRandomHex(8);
+//       while (mServerPublications.find(etag) != mServerPublications.end())
+//       {
+//          etag = Random::getCryptoRandomHex(8);
+//       }
+
+//       if (request.getContents())
+//       {
+//          ServerPublication* sp = new ServerPublication(*this, etag, request);
+//          mServerPublications[etag] = sp;
+//          sp->dispatch(request);
+//       }
+//       else
+//       {
+//          // per 3903 (sec 6.5), a PUB w/ no SIPIfMatch must have contents. .mjf.
+//          auto response = std::make_shared<SipMessage>();
+//          makeResponse(*response, request, 400);
+//          send(response);
+//       }
+//    }
+// }
 
 bool
 DialogUsageManager::checkEventPackage(const SipMessage& request)
@@ -2330,7 +2365,7 @@ DialogUsageManager::checkEventPackage(const SipMessage& request)
             }
             break;
          case NOTIFY:
-            if (!getClientSubscriptionHandler(request.header(h_Event).value()))
+            // if (!getClientSubscriptionHandler(request.header(h_Event).value()))
             {
                InfoLog (<< "No handler for event package for NOTIFY: " 
                         << request.header(h_Event).value());
@@ -2338,7 +2373,7 @@ DialogUsageManager::checkEventPackage(const SipMessage& request)
             }
             break;
          case PUBLISH:
-            if (!getServerPublicationHandler(request.header(h_Event).value()))
+            // if (!getServerPublicationHandler(request.header(h_Event).value()))
             {
                InfoLog (<< "No handler for event package for PUBLISH: " 
                         << request.header(h_Event).value());
@@ -2419,19 +2454,19 @@ DialogUsageManager::removeDialogSet(const DialogSetId& dsId)
    }
 }
 
-ClientSubscriptionHandler*
-DialogUsageManager::getClientSubscriptionHandler(const Data& eventType)
-{
-   map<Data, ClientSubscriptionHandler*>::iterator res = mClientSubscriptionHandlers.find(eventType);
-   if (res != mClientSubscriptionHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// ClientSubscriptionHandler*
+// DialogUsageManager::getClientSubscriptionHandler(const Data& eventType)
+// {
+//    map<Data, ClientSubscriptionHandler*>::iterator res = mClientSubscriptionHandlers.find(eventType);
+//    if (res != mClientSubscriptionHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
 ServerSubscriptionHandler*
 DialogUsageManager::getServerSubscriptionHandler(const Data& eventType)
@@ -2461,33 +2496,33 @@ DialogUsageManager::getClientPublicationHandler(const Data& eventType)
    }
 }
 
-ServerPublicationHandler*
-DialogUsageManager::getServerPublicationHandler(const Data& eventType)
-{
-   map<Data, ServerPublicationHandler*>::iterator res = mServerPublicationHandlers.find(eventType);
-   if (res != mServerPublicationHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// ServerPublicationHandler*
+// DialogUsageManager::getServerPublicationHandler(const Data& eventType)
+// {
+//    map<Data, ServerPublicationHandler*>::iterator res = mServerPublicationHandlers.find(eventType);
+//    if (res != mServerPublicationHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
-OutOfDialogHandler*
-DialogUsageManager::getOutOfDialogHandler(const MethodTypes type)
-{
-   map<MethodTypes, OutOfDialogHandler*>::iterator res = mOutOfDialogHandlers.find(type);
-   if (res != mOutOfDialogHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// OutOfDialogHandler*
+// DialogUsageManager::getOutOfDialogHandler(const MethodTypes type)
+// {
+//    map<MethodTypes, OutOfDialogHandler*>::iterator res = mOutOfDialogHandlers.find(type);
+//    if (res != mOutOfDialogHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
 void 
 DialogUsageManager::addIncomingFeature(std::shared_ptr<DumFeature> feat)
@@ -2525,22 +2560,22 @@ DialogUsageManager::applyToAllServerSubscriptions(ServerSubscriptionFunctor* fun
    }
 }
 
-void
-DialogUsageManager::applyToAllClientSubscriptions(ClientSubscriptionFunctor* functor)
-{
-   resip_assert(functor);
-   for (DialogSetMap::iterator it = mDialogSetMap.begin(); it != mDialogSetMap.end(); ++it)
-   {
-      for (DialogSet::DialogMap::iterator i = it->second->mDialogs.begin(); i != it->second->mDialogs.end(); ++i)
-      {
-         std::vector<ClientSubscriptionHandle> clientSubs = i->second->getClientSubscriptions();
-         for (std::vector<ClientSubscriptionHandle>::iterator ics = clientSubs.begin(); ics != clientSubs.end(); ++ics)
-         {
-            functor->apply(*ics);
-         }
-      }
-   }
-}
+// void
+// DialogUsageManager::applyToAllClientSubscriptions(ClientSubscriptionFunctor* functor)
+// {
+//    resip_assert(functor);
+//    for (DialogSetMap::iterator it = mDialogSetMap.begin(); it != mDialogSetMap.end(); ++it)
+//    {
+//       for (DialogSet::DialogMap::iterator i = it->second->mDialogs.begin(); i != it->second->mDialogs.end(); ++i)
+//       {
+//          std::vector<ClientSubscriptionHandle> clientSubs = i->second->getClientSubscriptions();
+//          for (std::vector<ClientSubscriptionHandle>::iterator ics = clientSubs.begin(); ics != clientSubs.end(); ++ics)
+//          {
+//             functor->apply(*ics);
+//          }
+//       }
+//    }
+// }
 
 void 
 DialogUsageManager::endAllServerSubscriptions(TerminateReason reason)
@@ -2555,18 +2590,18 @@ DialogUsageManager::endAllServerSubscriptions(TerminateReason reason)
    }
 }
 
-void 
-DialogUsageManager::endAllServerPublications()
-{
-   // Make a copy of the map - since calling end can cause an immediate delete this on the publication and thus cause
-   // the object to remove itself from the mServerPublications map, messing up our iterator
-   ServerPublications tempPublications = mServerPublications;
-   ServerPublications::iterator it = tempPublications.begin();
-   for (; it != tempPublications.end(); it++)
-   {
-      it->second->end();
-   }
-}
+// void 
+// DialogUsageManager::endAllServerPublications()
+// {
+//    // Make a copy of the map - since calling end can cause an immediate delete this on the publication and thus cause
+//    // the object to remove itself from the mServerPublications map, messing up our iterator
+//    ServerPublications tempPublications = mServerPublications;
+//    ServerPublications::iterator it = tempPublications.begin();
+//    for (; it != tempPublications.end(); it++)
+//    {
+//       it->second->end();
+//    }
+// }
 
 void
 DialogUsageManager::registerForConnectionTermination(Postable* listener)
diff --git a/resip/dum/DialogUsageManager.hxx b/resip/dum/DialogUsageManager.hxx
old mode 100644
new mode 100755
index d6ea6207e..3539448ad
--- a/resip/dum/DialogUsageManager.hxx
+++ b/resip/dum/DialogUsageManager.hxx
@@ -14,8 +14,8 @@
 #include "resip/dum/HandleManager.hxx"
 #include "resip/dum/Handles.hxx"
 #include "resip/dum/MergedRequestKey.hxx"
-#include "resip/dum/RegistrationPersistenceManager.hxx"
-#include "resip/dum/PublicationPersistenceManager.hxx"
+// #include "resip/dum/RegistrationPersistenceManager.hxx"
+// #include "resip/dum/PublicationPersistenceManager.hxx"
 #include "resip/dum/ServerSubscription.hxx"
 #include "rutil/BaseException.hxx"
 #include "rutil/ThreadIf.hxx"
@@ -25,7 +25,7 @@
 #include "resip/dum/DumFeatureChain.hxx"
 #include "resip/dum/DumFeatureMessage.hxx"
 #include "resip/dum/TargetCommand.hxx"
-#include "resip/dum/ClientSubscriptionFunctor.hxx"
+// #include "resip/dum/ClientSubscriptionFunctor.hxx"
 #include "resip/dum/ServerSubscriptionFunctor.hxx"
 
 #include <memory>
@@ -39,20 +39,20 @@ class FdSet;
 class MasterProfile;
 class RedirectManager;
 class ClientAuthManager;
-class ServerAuthManager;
+// class ServerAuthManager;
 class Uri;
 class Contents;
 
 class ClientRegistrationHandler;
-class ServerRegistrationHandler;
+// class ServerRegistrationHandler;
 class InviteSessionHandler;
-class ClientSubscriptionHandler;
+// class ClientSubscriptionHandler;
 class ServerSubscriptionHandler;
 class ClientPublicationHandler;
-class ServerPublicationHandler;
+// class ServerPublicationHandler;
 class ClientPagerMessageHandler;
 class ServerPagerMessageHandler;
-class OutOfDialogHandler;
+// class OutOfDialogHandler;
 class RedirectHandler;
 class DialogSetHandler;
 class RequestValidationHandler;
@@ -139,7 +139,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       //optional handler to track the progress of DialogSets
       void setDialogSetHandler(DialogSetHandler* handler) noexcept;
 
-      void setKeepAliveManager(std::unique_ptr<KeepAliveManager> keepAlive) noexcept;
+      // void setKeepAliveManager(std::unique_ptr<KeepAliveManager> keepAlive) noexcept;
 
       //There is a default RedirectManager.  Setting one may cause the old one
       //to be deleted. 
@@ -153,7 +153,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       void setClientAuthManager(std::unique_ptr<ClientAuthManager> client) noexcept;
 
       /// If there is no ServerAuthManager, the server does not authenticate requests
-      void setServerAuthManager(std::shared_ptr<ServerAuthManager> server);
+      // void setServerAuthManager(std::shared_ptr<ServerAuthManager> server);
 
       /// If there is no such handler, calling makeInviteSession will throw and
       /// receiving an INVITE as a UAS will respond with 405 Method Not Allowed.
@@ -163,18 +163,18 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       void setClientRegistrationHandler(ClientRegistrationHandler*);
 
       /// If no such handler, UAS will respond to REGISTER with 405 Method Not Allowed
-      void setServerRegistrationHandler(ServerRegistrationHandler*);
+      // void setServerRegistrationHandler(ServerRegistrationHandler*);
 
       /// If there is no such handler, calling makeSubscription will throw
-      void addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler*);
+      // void addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler*);
 
       /// If there is no such handler, calling makePublication will throw
       void addClientPublicationHandler(const Data& eventType, ClientPublicationHandler*);
       
       void addServerSubscriptionHandler(const Data& eventType, ServerSubscriptionHandler*);
-      void addServerPublicationHandler(const Data& eventType, ServerPublicationHandler*);
+      // void addServerPublicationHandler(const Data& eventType, ServerPublicationHandler*);
       
-      void addOutOfDialogHandler(MethodTypes, OutOfDialogHandler*);
+      // void addOutOfDialogHandler(MethodTypes, OutOfDialogHandler*);
 
       void setRequestValidationHandler(RequestValidationHandler*);
 
@@ -183,54 +183,54 @@ class DialogUsageManager : public HandleManager, public TransactionUser
 
       /// Add/Remove External Message Handler
       /// do following op when processing thread in not running
-      void addExternalMessageHandler(ExternalMessageHandler* handler);
-      void removeExternalMessageHandler(ExternalMessageHandler* handler);
-      void clearExternalMessageHandler();
+      // void addExternalMessageHandler(ExternalMessageHandler* handler);
+      // void removeExternalMessageHandler(ExternalMessageHandler* handler);
+      // void clearExternalMessageHandler();
 
       /// Sets a manager to handle storage of registration or publication state
-      void setRegistrationPersistenceManager(RegistrationPersistenceManager*);
-      RegistrationPersistenceManager* getRegistrationPersistenceManager() { return mRegistrationPersistenceManager; }
-      void setPublicationPersistenceManager(PublicationPersistenceManager*);
-      PublicationPersistenceManager* getPublicationPersistenceManager() { return mPublicationPersistenceManager; }
+      // void setRegistrationPersistenceManager(RegistrationPersistenceManager*);
+      // RegistrationPersistenceManager* getRegistrationPersistenceManager() { return mRegistrationPersistenceManager; }
+      // void setPublicationPersistenceManager(PublicationPersistenceManager*);
+      // PublicationPersistenceManager* getPublicationPersistenceManager() { return mPublicationPersistenceManager; }
       
       // The message is owned by the underlying datastructure and may go away in
       // the future. If the caller wants to keep it, it should make a copy. The
       // memory will exist at least up until the point where the application
       // calls DialogUsageManager::send(msg);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const DialogSetId& dialogSetId, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const DialogSetId& dialogSetId, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
       // Versions that add a replaces header
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
       
       //will send a Notify(100)...currently can be decorated through the
       //OnReadyToSend callback.  Probably will change it's own callback/handler soon
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile,
-                                                       const Contents* initialOffer, AppDialogSet* appDs = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile,
+      //                                                  const Contents* initialOffer, AppDialogSet* appDs = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
       
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                             uint32_t subscriptionTime, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                             uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, uint32_t subscriptionTime, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType,
-                                             uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+      //                                        uint32_t subscriptionTime, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+      //                                        uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, uint32_t subscriptionTime, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType,
+      //                                        uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
 
       //unsolicited refer
-      std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
 
       std::shared_ptr<SipMessage> makePublication(const NameAddr& target,
                                             const std::shared_ptr<UserProfile>& userProfile,
@@ -249,8 +249,8 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, AppDialogSet* = nullptr);
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, uint32_t registrationTime, AppDialogSet* = nullptr);
 
-      std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, MethodTypes meth, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, MethodTypes meth, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, MethodTypes meth, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, MethodTypes meth, AppDialogSet* = nullptr);
 
       ClientPagerMessageHandle makePagerMessage(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* = nullptr);
       ClientPagerMessageHandle makePagerMessage(const NameAddr& target, AppDialogSet* = nullptr);
@@ -306,9 +306,9 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       std::pair<InviteSessionHandle, int> findInviteSession(const CallId& replaces);
 
       ClientPublicationHandler* getClientPublicationHandler(const Data& eventType);
-      ServerPublicationHandler* getServerPublicationHandler(const Data& eventType);
+      // ServerPublicationHandler* getServerPublicationHandler(const Data& eventType);
 
-      ClientSubscriptionHandler* getClientSubscriptionHandler(const Data& eventType);
+      // ClientSubscriptionHandler* getClientSubscriptionHandler(const Data& eventType);
       ServerSubscriptionHandler* getServerSubscriptionHandler(const Data& eventType);
 
       // will apply the specified functor(which takes a
@@ -350,11 +350,11 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       void internalProcess(std::unique_ptr<Message> msg);
       bool messageAvailable(void) { return mFifo.messageAvailable(); }
 
-      void applyToAllClientSubscriptions(ClientSubscriptionFunctor*);
+      // void applyToAllClientSubscriptions(ClientSubscriptionFunctor*);
       void applyToAllServerSubscriptions(ServerSubscriptionFunctor*);
 
       void endAllServerSubscriptions(TerminateReason reason = Deactivated);
-      void endAllServerPublications();
+      // void endAllServerPublications();
 
       /// Note:  Implementations of Postable must delete the message passed via post
       void registerForConnectionTermination(Postable*);
@@ -477,7 +477,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       
       bool mergeRequest(const SipMessage& request);
 
-      void processPublish(const SipMessage& publish);
+      // void processPublish(const SipMessage& publish);
 
       void removeDialogSet(const DialogSetId& );      
 
@@ -488,7 +488,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
 
       void incomingProcess(std::unique_ptr<Message> msg);
       void outgoingProcess(std::unique_ptr<Message> msg);
-      void processExternalMessage(ExternalMessageBase* externalMessage);
+      // void processExternalMessage(ExternalMessageBase* externalMessage);
 
       // For delayed delete of a Usage
       void destroy(const BaseUsage* usage);
@@ -515,27 +515,27 @@ class DialogUsageManager : public HandleManager, public TransactionUser
     
       InviteSessionHandler* mInviteSessionHandler;
       ClientRegistrationHandler* mClientRegistrationHandler;
-      ServerRegistrationHandler* mServerRegistrationHandler;      
+      // ServerRegistrationHandler* mServerRegistrationHandler;      
       RedirectHandler* mRedirectHandler;
       DialogSetHandler* mDialogSetHandler;      
       RequestValidationHandler* mRequestValidationHandler;
 
-      RegistrationPersistenceManager *mRegistrationPersistenceManager;
-      PublicationPersistenceManager *mPublicationPersistenceManager;
+      // RegistrationPersistenceManager *mRegistrationPersistenceManager;
+      // PublicationPersistenceManager *mPublicationPersistenceManager;
 
-      OutOfDialogHandler* getOutOfDialogHandler(MethodTypes type);
+      // OutOfDialogHandler* getOutOfDialogHandler(MethodTypes type);
 
-      std::map<Data, ClientSubscriptionHandler*> mClientSubscriptionHandlers;
+      // std::map<Data, ClientSubscriptionHandler*> mClientSubscriptionHandlers;
       std::map<Data, ServerSubscriptionHandler*> mServerSubscriptionHandlers;
       std::map<Data, ClientPublicationHandler*> mClientPublicationHandlers;
-      std::map<Data, ServerPublicationHandler*> mServerPublicationHandlers;
-      std::map<MethodTypes, OutOfDialogHandler*> mOutOfDialogHandlers;
-      std::unique_ptr<KeepAliveManager> mKeepAliveManager;
+      // std::map<Data, ServerPublicationHandler*> mServerPublicationHandlers;
+      // std::map<MethodTypes, OutOfDialogHandler*> mOutOfDialogHandlers;
+      // std::unique_ptr<KeepAliveManager> mKeepAliveManager;
       bool mIsDefaultServerReferHandler;
 
       ClientPagerMessageHandler* mClientPagerMessageHandler;
       ServerPagerMessageHandler* mServerPagerMessageHandler;
-      std::vector<ExternalMessageHandler*> mExternalMessageHandlers;
+      // std::vector<ExternalMessageHandler*> mExternalMessageHandlers;
 
       // a pointer because we'll only initialize if we add a
       // server subscription handler for the 'dialog' event...
@@ -556,8 +556,8 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       ShutdownState mShutdownState;
 
       // from ETag -> ServerPublication
-      typedef std::map<Data, ServerPublication*> ServerPublications;
-      ServerPublications mServerPublications;
+      // typedef std::map<Data, ServerPublication*> ServerPublications;
+      // ServerPublications mServerPublications;
       typedef std::map<Data, SipMessage*> RequiresCerts;
       RequiresCerts mRequiresCerts;      
       // from Event-Type+document-aor -> ServerSubscription
diff --git a/resip/dum/InviteSession.cxx b/resip/dum/InviteSession.cxx
old mode 100644
new mode 100755
index e4a4f23c4..8769d332a
--- a/resip/dum/InviteSession.cxx
+++ b/resip/dum/InviteSession.cxx
@@ -1,5 +1,5 @@
-#include "resip/stack/MultipartMixedContents.hxx"
-#include "resip/stack/MultipartAlternativeContents.hxx"
+// #include "resip/stack/MultipartMixedContents.hxx"
+// #include "resip/stack/MultipartAlternativeContents.hxx"
 #include "resip/stack/SdpContents.hxx"
 #include "resip/stack/SipMessage.hxx"
 #include "resip/stack/Helper.hxx"
@@ -9,9 +9,9 @@
 #include "resip/dum/DialogUsageManager.hxx"
 #include "resip/dum/InviteSession.hxx"
 #include "resip/dum/ServerInviteSession.hxx"
-#include "resip/dum/ClientSubscription.hxx"
+// #include "resip/dum/ClientSubscription.hxx"
 #include "resip/dum/ServerSubscription.hxx"
-#include "resip/dum/ClientInviteSession.hxx"
+// #include "resip/dum/ClientInviteSession.hxx"
 #include "resip/dum/InviteSessionHandler.hxx"
 #include "resip/dum/MasterProfile.hxx"
 #include "resip/dum/UsageUseException.hxx"
@@ -554,57 +554,57 @@ InviteSession::provideAnswer(const Contents& answer)
 {
    switch (mState)
    {
-      case ReceivedReinvite:
-         transition(Connected);
-         mDialog.makeResponse(*mInvite200, *mLastRemoteSessionModification, 200);
-         handleSessionTimerRequest(*mInvite200, *mLastRemoteSessionModification);
-         InviteSession::setOfferAnswer(*mInvite200, answer, 0);
-         mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
-         mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
-         InfoLog (<< "Sending " << mInvite200->brief());
-         DumHelper::setOutgoingEncryptionLevel(*mInvite200, mCurrentEncryptionLevel);
-         send(mInvite200);
-         startRetransmit200Timer();
-         if (mDum.mDialogEventStateManager)
-         {
-             // New Offer/Answer - generate a new confirmed callback with updated SDP
-             mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-         }
-         break;
-
-      case ReceivedUpdate: // same as ReceivedReinvite case.
-      {
-         transition(Connected);
-
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, *mLastRemoteSessionModification, 200);
-         handleSessionTimerRequest(*response, *mLastRemoteSessionModification);
-         InviteSession::setOfferAnswer(*response, answer, 0);
-         mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
-         mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
-         InfoLog (<< "Sending " << response->brief());
-         DumHelper::setOutgoingEncryptionLevel(*response, mCurrentEncryptionLevel);
-         send(response);
-         if (mDum.mDialogEventStateManager)
-         {
-             // New Offer/Answer - generate a new confirmed callback with updated SDP
-             mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-         }
-         break;
-      }
-
-      case SentReinviteAnswered:
-         transition(Connected);
-         sendAck(&answer);
-
-         mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
-         mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
-         if (mDum.mDialogEventStateManager)
-         {
-             // New Offer/Answer - generate a new confirmed callback with updated SDP
-             mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-         }
-         break;
+      // case ReceivedReinvite:
+      //    transition(Connected);
+      //    mDialog.makeResponse(*mInvite200, *mLastRemoteSessionModification, 200);
+      //    handleSessionTimerRequest(*mInvite200, *mLastRemoteSessionModification);
+      //    InviteSession::setOfferAnswer(*mInvite200, answer, 0);
+      //    mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
+      //    mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
+      //    InfoLog (<< "Sending " << mInvite200->brief());
+      //    DumHelper::setOutgoingEncryptionLevel(*mInvite200, mCurrentEncryptionLevel);
+      //    send(mInvite200);
+      //    startRetransmit200Timer();
+      //    if (mDum.mDialogEventStateManager)
+      //    {
+      //        // New Offer/Answer - generate a new confirmed callback with updated SDP
+      //        mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+      //    }
+      //    break;
+
+      // case ReceivedUpdate: // same as ReceivedReinvite case.
+      // {
+      //    transition(Connected);
+
+      //    auto response = std::make_shared<SipMessage>();
+      //    mDialog.makeResponse(*response, *mLastRemoteSessionModification, 200);
+      //    handleSessionTimerRequest(*response, *mLastRemoteSessionModification);
+      //    InviteSession::setOfferAnswer(*response, answer, 0);
+      //    mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
+      //    mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
+      //    InfoLog (<< "Sending " << response->brief());
+      //    DumHelper::setOutgoingEncryptionLevel(*response, mCurrentEncryptionLevel);
+      //    send(response);
+      //    if (mDum.mDialogEventStateManager)
+      //    {
+      //        // New Offer/Answer - generate a new confirmed callback with updated SDP
+      //        mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+      //    }
+      //    break;
+      // }
+
+      // case SentReinviteAnswered:
+      //    transition(Connected);
+      //    sendAck(&answer);
+
+      //    mCurrentRemoteOfferAnswer = std::move(mProposedRemoteOfferAnswer);
+      //    mCurrentLocalOfferAnswer = InviteSession::makeOfferAnswer(answer);
+      //    if (mDum.mDialogEventStateManager)
+      //    {
+      //        // New Offer/Answer - generate a new confirmed callback with updated SDP
+      //        mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+      //    }
+      //    break;
 
       default:
          WarningLog (<< "Incorrect state to provideAnswer: " << toData(mState));
@@ -895,56 +895,56 @@ InviteSession::targetRefresh(const NameAddr& localUri)
    }
 }
 
-void
-InviteSession::refer(const NameAddr& referTo, bool referSub)
-{
-   refer(referTo, myAddr(), nullptr, referSub);
-}
-void
-InviteSession::refer(const NameAddr& referTo, const NameAddr& referredBy, bool referSub)
-{
-   refer(referTo, referredBy, nullptr, referSub);
-}
-void
-InviteSession::refer(const NameAddr& referTo, std::unique_ptr<resip::Contents> contents, bool referSub)
-{
-   refer(referTo, myAddr(), std::move(contents), referSub);
-}
-void
-InviteSession::refer(const NameAddr& referTo, const NameAddr& referredBy, std::unique_ptr<resip::Contents> contents, bool referSub)
-{
-   if (isConnected()) // ?slg? likely not safe in any state except Connected - what should behaviour be if state is ReceivedReinvite?
-   {
-      auto refer = std::make_shared<SipMessage>();
-      mDialog.makeRequest(*refer, REFER, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
-      refer->header(h_ReferTo) = referTo;
-      refer->header(h_ReferredBy) = referredBy;
-      refer->header(h_ReferredBy).remove(p_tag);   // tag-param not permitted in rfc3892; not the same as generic-param
-      refer->setContents(std::move(contents));
-      if (!referSub)
-      {
-         refer->header(h_ReferSub).value() = "false";
-         refer->header(h_Supporteds).push_back(Token(Symbols::NoReferSub));
-      }
-
-      if(mNitState == NitComplete)
-      {
-         mNitState = NitProceeding;
-         mReferSub = referSub;
-         mLastSentNITRequest = refer;
-         send(refer);
-         return;
-      }
-      mNITQueue.push(new QueuedNIT(refer,referSub));
-      InfoLog(<< "refer - queuing NIT:" << refer->brief());
-      return;
-   }
-   else
-   {
-      WarningLog (<< "Can't refer before Connected");
-      throw UsageUseException("REFER not allowed in this context", __FILE__, __LINE__);
-   }
-}
+// void
+// InviteSession::refer(const NameAddr& referTo, bool referSub)
+// {
+//    refer(referTo, myAddr(), nullptr, referSub);
+// }
+// void
+// InviteSession::refer(const NameAddr& referTo, const NameAddr& referredBy, bool referSub)
+// {
+//    refer(referTo, referredBy, nullptr, referSub);
+// }
+// void
+// InviteSession::refer(const NameAddr& referTo, std::unique_ptr<resip::Contents> contents, bool referSub)
+// {
+//    refer(referTo, myAddr(), std::move(contents), referSub);
+// }
+// void
+// InviteSession::refer(const NameAddr& referTo, const NameAddr& referredBy, std::unique_ptr<resip::Contents> contents, bool referSub)
+// {
+//    if (isConnected()) // ?slg? likely not safe in any state except Connected - what should behaviour be if state is ReceivedReinvite?
+//    {
+//       auto refer = std::make_shared<SipMessage>();
+//       mDialog.makeRequest(*refer, REFER, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
+//       refer->header(h_ReferTo) = referTo;
+//       refer->header(h_ReferredBy) = referredBy;
+//       refer->header(h_ReferredBy).remove(p_tag);   // tag-param not permitted in rfc3892; not the same as generic-param
+//       refer->setContents(std::move(contents));
+//       if (!referSub)
+//       {
+//          refer->header(h_ReferSub).value() = "false";
+//          refer->header(h_Supporteds).push_back(Token(Symbols::NoReferSub));
+//       }
+
+//       if(mNitState == NitComplete)
+//       {
+//          mNitState = NitProceeding;
+//          mReferSub = referSub;
+//          mLastSentNITRequest = refer;
+//          send(refer);
+//          return;
+//       }
+//       mNITQueue.push(new QueuedNIT(refer,referSub));
+//       InfoLog(<< "refer - queuing NIT:" << refer->brief());
+//       return;
+//    }
+//    else
+//    {
+//       WarningLog (<< "Can't refer before Connected");
+//       throw UsageUseException("REFER not allowed in this context", __FILE__, __LINE__);
+//    }
+// }
 
 std::shared_ptr<SipMessage>
 InviteSession::getLastSentNITRequest() const
@@ -970,199 +970,199 @@ InviteSession::nitComplete()
    }
 }
 
-class InviteSessionReferCommand : public DumCommandAdapter
-{
-public:
-   InviteSessionReferCommand(const InviteSessionHandle& inviteSessionHandle, const NameAddr& referTo, bool referSub)
-      : mInviteSessionHandle(inviteSessionHandle),
-      mReferTo(referTo),
-      mReferSub(referSub)
-   {
-
-   }
-
-   void executeCommand() override
-   {
-      if(mInviteSessionHandle.isValid())
-      {
-         mInviteSessionHandle->refer(mReferTo, mReferSub);
-      }
-   }
-
-   EncodeStream& encodeBrief(EncodeStream& strm) const override
-   {
-      return strm << "InviteSessionReferCommand";
-   }
-
-private:
-   InviteSessionHandle mInviteSessionHandle;
-   NameAddr mReferTo;
-   bool mReferSub;
-};
-
-void
-InviteSession::referCommand(const NameAddr& referTo, bool referSub)
-{
-   mDum.post(new InviteSessionReferCommand(getSessionHandle(), referTo, referSub));
-}
-
-void
-InviteSession::refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
-{
-   refer(referTo, sessionToReplace, nullptr, referSub);
-}
-
-void
-InviteSession::refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, std::unique_ptr<resip::Contents> contents, bool referSub)
-{
-   if (!sessionToReplace.isValid())
-   {
-      throw UsageUseException("Attempted to make a refer w/ and invalid replacement target", __FILE__, __LINE__);
-   }
-
-   CallId replaces;
-   DialogId id = sessionToReplace->mDialog.getId();
-   replaces.value() = id.getCallId();
-   replaces.param(p_toTag) = id.getRemoteTag();
-   replaces.param(p_fromTag) = id.getLocalTag();
-
-   refer(referTo, replaces, std::move(contents), referSub);
-}
-
-void 
-InviteSession::refer(const NameAddr& referTo, const CallId& replaces, bool referSub)
-{
-   refer(referTo, replaces, nullptr, referSub);
-}
-
-void 
-InviteSession::refer(const NameAddr& referTo, const CallId& replaces, std::unique_ptr<resip::Contents> contents, bool referSub)
-{
-   if (isConnected())  // ?slg? likely not safe in any state except Connected - what should behaviour be if state is ReceivedReinvite?
-   {
-      auto refer = std::make_shared<SipMessage>();
-      mDialog.makeRequest(*refer, REFER, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
-      refer->setContents(std::move(contents));
-      refer->header(h_ReferTo) = referTo;
-      refer->header(h_ReferredBy) = myAddr();
-      refer->header(h_ReferredBy).remove(p_tag);
-
-      refer->header(h_ReferTo).uri().embedded().header(h_Replaces) = replaces;
+// class InviteSessionReferCommand : public DumCommandAdapter
+// {
+// public:
+//    InviteSessionReferCommand(const InviteSessionHandle& inviteSessionHandle, const NameAddr& referTo, bool referSub)
+//       : mInviteSessionHandle(inviteSessionHandle),
+//       mReferTo(referTo),
+//       mReferSub(referSub)
+//    {
+
+//    }
+
+//    void executeCommand() override
+//    {
+//       if(mInviteSessionHandle.isValid())
+//       {
+//          mInviteSessionHandle->refer(mReferTo, mReferSub);
+//       }
+//    }
+
+//    EncodeStream& encodeBrief(EncodeStream& strm) const override
+//    {
+//       return strm << "InviteSessionReferCommand";
+//    }
+
+// private:
+//    InviteSessionHandle mInviteSessionHandle;
+//    NameAddr mReferTo;
+//    bool mReferSub;
+// };
+
+// void
+// InviteSession::referCommand(const NameAddr& referTo, bool referSub)
+// {
+//    mDum.post(new InviteSessionReferCommand(getSessionHandle(), referTo, referSub));
+// }
+
+// void
+// InviteSession::refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
+// {
+//    refer(referTo, sessionToReplace, nullptr, referSub);
+// }
+
+// void
+// InviteSession::refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, std::unique_ptr<resip::Contents> contents, bool referSub)
+// {
+//    if (!sessionToReplace.isValid())
+//    {
+//       throw UsageUseException("Attempted to make a refer w/ and invalid replacement target", __FILE__, __LINE__);
+//    }
+
+//    CallId replaces;
+//    DialogId id = sessionToReplace->mDialog.getId();
+//    replaces.value() = id.getCallId();
+//    replaces.param(p_toTag) = id.getRemoteTag();
+//    replaces.param(p_fromTag) = id.getLocalTag();
+
+//    refer(referTo, replaces, std::move(contents), referSub);
+// }
+
+// void 
+// InviteSession::refer(const NameAddr& referTo, const CallId& replaces, bool referSub)
+// {
+//    refer(referTo, replaces, nullptr, referSub);
+// }
+
+// void 
+// InviteSession::refer(const NameAddr& referTo, const CallId& replaces, std::unique_ptr<resip::Contents> contents, bool referSub)
+// {
+//    if (isConnected())  // ?slg? likely not safe in any state except Connected - what should behaviour be if state is ReceivedReinvite?
+//    {
+//       auto refer = std::make_shared<SipMessage>();
+//       mDialog.makeRequest(*refer, REFER, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
+//       refer->setContents(std::move(contents));
+//       refer->header(h_ReferTo) = referTo;
+//       refer->header(h_ReferredBy) = myAddr();
+//       refer->header(h_ReferredBy).remove(p_tag);
+
+//       refer->header(h_ReferTo).uri().embedded().header(h_Replaces) = replaces;
       
-      if (!referSub)
-      {
-         refer->header(h_ReferSub).value() = "false";
-         refer->header(h_Supporteds).push_back(Token(Symbols::NoReferSub));
-      }
-
-      if(mNitState == NitComplete)
-      {
-         mNitState = NitProceeding;
-         mReferSub = referSub;
-         mLastSentNITRequest = refer;
-         send(refer);
-         return;
-      }
-      mNITQueue.push(new QueuedNIT(refer,referSub));
-      InfoLog(<< "refer/replace - queuing NIT:" << refer->brief());
-      return;
-   }
-   else
-   {
-      WarningLog (<< "Can't refer before Connected");
-      resip_assert(0);
-      throw UsageUseException("REFER not allowed in this context", __FILE__, __LINE__);
-   }
-}
-
-class InviteSessionReferExCommand : public DumCommandAdapter
-{
-public:
-   InviteSessionReferExCommand(const InviteSessionHandle& inviteSessionHandle, const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
-      : mInviteSessionHandle(inviteSessionHandle),
-      mSessionToReplace(sessionToReplace),
-      mReferTo(referTo),
-      mReferSub(referSub)
-   {
-   }
-
-   void executeCommand() override
-   {
-      if(mInviteSessionHandle.isValid())
-      {
-         mInviteSessionHandle->refer(mReferTo, mSessionToReplace, mReferSub);
-      }
-   }
-
-   EncodeStream& encodeBrief(EncodeStream& strm) const override
-   {
-      return strm << "InviteSessionReferExCommand";
-   }
-
-private:
-   InviteSessionHandle mInviteSessionHandle;
-   InviteSessionHandle mSessionToReplace;
-   NameAddr mReferTo;
-   bool mReferSub;
-};
-
-void
-InviteSession::referCommand(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
-{
-   mDum.post(new InviteSessionReferExCommand(getSessionHandle(), referTo, sessionToReplace, referSub));
-}
-
-void
-InviteSession::info(const Contents& contents)
-{
-   auto info = std::make_shared<SipMessage>();
-   mDialog.makeRequest(*info, INFO, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
-   // !jf! handle multipart here
-   info->setContents(&contents);
-   DumHelper::setOutgoingEncryptionLevel(*info, mCurrentEncryptionLevel);
-   if (mNitState == NitComplete)
-   {
-      mNitState = NitProceeding;
-      mLastSentNITRequest = info;
-      send(info);
-      return;
-   }
-   mNITQueue.push(new QueuedNIT(info));
-   InfoLog(<< "info - queuing NIT:" << info->brief());
-   return;
-}
-
-class InviteSessionInfoCommand : public DumCommandAdapter
-{
-public:
-   InviteSessionInfoCommand(const InviteSessionHandle& inviteSessionHandle, const Contents& contents)
-      : mInviteSessionHandle(inviteSessionHandle),
-        mContents(contents.clone())
-   {
-   }
-
-   void executeCommand() override
-   {
-      if(mInviteSessionHandle.isValid())
-      {
-         mInviteSessionHandle->info(*mContents);
-      }
-   }
-
-   EncodeStream& encodeBrief(EncodeStream& strm) const override
-   {
-      return strm << "InviteSessionInfoCommand";
-   }
-private:
-   InviteSessionHandle mInviteSessionHandle;
-   std::unique_ptr<Contents> mContents;
-};
-
-void
-InviteSession::infoCommand(const Contents& contents)
-{
-   mDum.post(new InviteSessionInfoCommand(getSessionHandle(), contents));
-}
+//       if (!referSub)
+//       {
+//          refer->header(h_ReferSub).value() = "false";
+//          refer->header(h_Supporteds).push_back(Token(Symbols::NoReferSub));
+//       }
+
+//       if(mNitState == NitComplete)
+//       {
+//          mNitState = NitProceeding;
+//          mReferSub = referSub;
+//          mLastSentNITRequest = refer;
+//          send(refer);
+//          return;
+//       }
+//       mNITQueue.push(new QueuedNIT(refer,referSub));
+//       InfoLog(<< "refer/replace - queuing NIT:" << refer->brief());
+//       return;
+//    }
+//    else
+//    {
+//       WarningLog (<< "Can't refer before Connected");
+//       resip_assert(0);
+//       throw UsageUseException("REFER not allowed in this context", __FILE__, __LINE__);
+//    }
+// }
+
+// class InviteSessionReferExCommand : public DumCommandAdapter
+// {
+// public:
+//    InviteSessionReferExCommand(const InviteSessionHandle& inviteSessionHandle, const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
+//       : mInviteSessionHandle(inviteSessionHandle),
+//       mSessionToReplace(sessionToReplace),
+//       mReferTo(referTo),
+//       mReferSub(referSub)
+//    {
+//    }
+
+//    void executeCommand() override
+//    {
+//       if(mInviteSessionHandle.isValid())
+//       {
+//          mInviteSessionHandle->refer(mReferTo, mSessionToReplace, mReferSub);
+//       }
+//    }
+
+//    EncodeStream& encodeBrief(EncodeStream& strm) const override
+//    {
+//       return strm << "InviteSessionReferExCommand";
+//    }
+
+// private:
+//    InviteSessionHandle mInviteSessionHandle;
+//    InviteSessionHandle mSessionToReplace;
+//    NameAddr mReferTo;
+//    bool mReferSub;
+// };
+
+// void
+// InviteSession::referCommand(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub)
+// {
+//    mDum.post(new InviteSessionReferExCommand(getSessionHandle(), referTo, sessionToReplace, referSub));
+// }
+
+// void
+// InviteSession::info(const Contents& contents)
+// {
+//    auto info = std::make_shared<SipMessage>();
+//    mDialog.makeRequest(*info, INFO, mNitState == NitComplete);  // only increment CSeq if not going to queue NIT
+//    // !jf! handle multipart here
+//    info->setContents(&contents);
+//    DumHelper::setOutgoingEncryptionLevel(*info, mCurrentEncryptionLevel);
+//    if (mNitState == NitComplete)
+//    {
+//       mNitState = NitProceeding;
+//       mLastSentNITRequest = info;
+//       send(info);
+//       return;
+//    }
+//    mNITQueue.push(new QueuedNIT(info));
+//    InfoLog(<< "info - queuing NIT:" << info->brief());
+//    return;
+// }
+
+// class InviteSessionInfoCommand : public DumCommandAdapter
+// {
+// public:
+//    InviteSessionInfoCommand(const InviteSessionHandle& inviteSessionHandle, const Contents& contents)
+//       : mInviteSessionHandle(inviteSessionHandle),
+//         mContents(contents.clone())
+//    {
+//    }
+
+//    void executeCommand() override
+//    {
+//       if(mInviteSessionHandle.isValid())
+//       {
+//          mInviteSessionHandle->info(*mContents);
+//       }
+//    }
+
+//    EncodeStream& encodeBrief(EncodeStream& strm) const override
+//    {
+//       return strm << "InviteSessionInfoCommand";
+//    }
+// private:
+//    InviteSessionHandle mInviteSessionHandle;
+//    std::unique_ptr<Contents> mContents;
+// };
+
+// void
+// InviteSession::infoCommand(const Contents& contents)
+// {
+//    mDum.post(new InviteSessionInfoCommand(getSessionHandle(), contents));
+// }
 
 void
 InviteSession::message(const Contents& contents)
@@ -1239,32 +1239,32 @@ InviteSession::dispatch(const SipMessage& msg)
          dispatchConnected(msg);
          break;
       case SentUpdate:
-         dispatchSentUpdate(msg);
+         // dispatchSentUpdate(msg);
          break; 
       case SentReinvite:
-         dispatchSentReinvite(msg);
+         // dispatchSentReinvite(msg);
          break;
       case SentReinviteNoOffer:
-         dispatchSentReinviteNoOffer(msg);
+         // dispatchSentReinviteNoOffer(msg);
          break;
       case SentReinviteAnswered:
-         dispatchSentReinviteAnswered(msg);
+         // dispatchSentReinviteAnswered(msg);
          break;
       case SentUpdateGlare:
       case SentReinviteGlare:
          // The behavior is the same except for timer which is handled in dispatch(Timer)
-         dispatchGlare(msg);
+         // dispatchGlare(msg);
          break;
       case SentReinviteNoOfferGlare:
-         dispatchReinviteNoOfferGlare(msg);
+         // dispatchReinviteNoOfferGlare(msg);
          break;
       case ReceivedUpdate:
       case ReceivedReinvite:
       case ReceivedReinviteNoOffer:
-         dispatchReceivedUpdateOrReinvite(msg);
+         // dispatchReceivedUpdateOrReinvite(msg);
          break;
       case ReceivedReinviteSentOffer:
-         dispatchReceivedReinviteSentOffer(msg);
+         // dispatchReceivedReinviteSentOffer(msg);
          break;
       case Answered:
          dispatchAnswered(msg);
@@ -1404,353 +1404,45 @@ InviteSession::dispatch(const DumTimeout& timeout)
             transition(Terminated);
             mDum.mInviteSessionHandler->onTerminated(getSessionHandle(), InviteSessionHandler::LocalBye, msg.get()); 
          }
-         else if(mState == SentReinvite ||
-                 mState == SentReinviteNoOffer)
-         {
-            transition(Connected);
-            mProposedLocalOfferAnswer.reset();
-            mProposedEncryptionLevel = DialogUsageManager::None;
-
-            // this is so the app can decide to ignore this. default implementation
-            // will call end next - which will send a BYE
-            mDum.mInviteSessionHandler->onStaleReInviteTimeout(getSessionHandle());
-         }
-      }
-   }
-   else if (timeout.type() == DumTimeout::SessionExpiration)
-   {
-      if(timeout.seq() == mSessionTimerSeq)
-      {
-         // this is so the app can decide to ignore this. default implementation
-         // will call end next - which will send a BYE
-         mDum.mInviteSessionHandler->onSessionExpired(getSessionHandle());
-      }
-   }
-   else if (timeout.type() == DumTimeout::SessionRefresh)
-   {
-     if(timeout.seq() == mSessionTimerSeq)
-     {
-        // Note: If not connected then we must be issueing a reinvite/update or
-        // receiving one - in either case the session timer stuff will get
-        // reset/renegotiated - thus just ignore this referesh
-        if(mState == Connected)  
-        {
-           sessionRefresh();
-        }
-     }
-   }
-}
-
-void
-InviteSession::dispatchConnected(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
-
-   switch (toEvent(msg, offerAnswer.get()))
-   {
-      case OnInvite:
-      case OnInviteReliable:
-         *mLastRemoteSessionModification = msg;
-         transition(ReceivedReinviteNoOffer);
-         handler->onOfferRequired(getSessionHandle(), msg);
-         break;
-
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
-         *mLastRemoteSessionModification = msg;
-         transition(ReceivedReinvite);
-         mCurrentEncryptionLevel = getEncryptionLevel(msg);
-         mProposedRemoteOfferAnswer = std::move(offerAnswer); 
-
-         handler->onOffer(getSessionHandle(), msg, *mProposedRemoteOfferAnswer);
-         break;
-
-      case On2xx:
-      case On2xxOffer:
-      case On2xxAnswer:
-         // retransmission of 200I
-         // !jf! Need to include the answer here.
-         sendAck(); 
-         break;
-
-      case OnUpdateOffer:
-         transition(ReceivedUpdate);
-
-         //  !kh!
-         //  Find out if it's an UPDATE requiring state change.
-         //  See rfc3311 5.2, 4th paragraph.
-         *mLastRemoteSessionModification = msg;
-         mCurrentEncryptionLevel = getEncryptionLevel(msg);
-         mProposedRemoteOfferAnswer = std::move(offerAnswer); 
-         handler->onOffer(getSessionHandle(), msg, *mProposedRemoteOfferAnswer);
-         break;
-
-      case OnUpdate:
-      {
-         // ?slg? no offerAnswer in update - just respond immediately (likely session timer) - do we need a callback?
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 200);
-         handleSessionTimerRequest(*response, msg);
-         send(response);
-         break;
-      }
-
-      case OnUpdateRejected:
-      case On200Update:
-         WarningLog (<< "DUM delivered an UPDATE response in an incorrect state " << endl << msg);
-         resip_assert(0);
-         break;
-
-      case OnAck:
-      case OnAckAnswer:
-         // Not checking for strict equality, since request may have been digest challenged
-         if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
-         {
-            InfoLog(<< "dropped stale ACK");
-         }
-         else
-         {
-            mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
-            handler->onAckReceived(getSessionHandle(), msg);
-         }
-         break;
-
-      default:
-         dispatchOthers(msg);
-         break;
-   }
-}
-
-void
-InviteSession::dispatchSentUpdate(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
-
-   switch (toEvent(msg, offerAnswer.get()))
-   {
-      case OnInvite:
-      case OnInviteReliable:
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
-      case OnUpdate:
-      case OnUpdateOffer:
-      {
-         // glare
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 491);
-         send(response);
-         break;
-      }
-
-      case On200Update:
-         transition(Connected);
-         handleSessionTimerResponse(msg);
-         if (offerAnswer && mProposedLocalOfferAnswer)
-         {
-            mCurrentEncryptionLevel = getEncryptionLevel(msg);
-            setCurrentLocalOfferAnswer(msg);
-
-            mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
-            if (mDum.mDialogEventStateManager)
-            {
-                // New Offer/Answer - generate a new confirmed callback with updated SDP
-                mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-            }
-            handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
-         }
-         else if(mProposedLocalOfferAnswer) 
-         {
-            // If we sent an offer in the Update Request and no answer is received
-            handler->onIllegalNegotiation(getSessionHandle(), msg);
-            mProposedLocalOfferAnswer.reset();
-            mProposedEncryptionLevel = DialogUsageManager::None;
-         }
-         break;
-
-      case On491Update:
-         transition(SentUpdateGlare);
-         start491Timer();
-         break;
-
-      case On422Update: // session timer
-         if(msg.exists(h_MinSE))
-         {
-            // Change interval to min from 422 response
-            mSessionInterval = msg.header(h_MinSE).value();
-            mMinSE = mSessionInterval;
-            sessionRefresh();
-         }
-         else
-         {
-            // Response must contain Min_SE - if not - just ignore
-            // ?slg? callback?
-            transition(Connected);
-            mProposedLocalOfferAnswer.reset();
-            mProposedEncryptionLevel = DialogUsageManager::None;
-         }
-         break;
-
-      case OnUpdateRejected:
-         transition(Connected);
-         mProposedLocalOfferAnswer.reset();
-         handler->onOfferRejected(getSessionHandle(), &msg);
-         break;
-
-      case OnGeneralFailure:
-         sendBye();
-         transition(Terminated);
-         handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
-         break;
-
-      default:
-         dispatchOthers(msg);
-         break;
-   }
-}
-
-void
-InviteSession::dispatchSentReinvite(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
-
-   switch (toEvent(msg, offerAnswer.get()))
-   {
-      case OnInvite:
-      case OnInviteReliable:
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
-      case OnUpdate:
-      case OnUpdateOffer:
-      {
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 491);
-         send(response);
-         break;
-      }
-
-      case On1xx:
-      case On1xxEarly:
-         // Some UA's send a 100 response to a ReInvite - just ignore it
-         break;
-
-      case On2xxAnswer:
-      case On2xxOffer:  // .slg. doesn't really make sense - should be in SentReinviteNoOffer to get this
-      {
-         mStaleReInviteTimerSeq++;
-         transition(Connected);
-         handleSessionTimerResponse(msg);
-         setCurrentLocalOfferAnswer(msg);
-
-         // !jf! I need to potentially include an answer in the ACK here
-         sendAck();
-         mCurrentEncryptionLevel = getEncryptionLevel(msg);
-         
-         if (mSessionRefreshReInvite)
-         {
-            mSessionRefreshReInvite = false;
-         
-            if (*mCurrentRemoteOfferAnswer != *offerAnswer)
-            {
-               mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
-               if (mDum.mDialogEventStateManager)
-               {
-                   // New Offer/Answer - generate a new confirmed callback with updated SDP
-                   mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-               }
-               handler->onRemoteAnswerChanged(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
-            }
-         }
-         else
-         {
-            mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
-            if (mDum.mDialogEventStateManager)
-            {
-                // New Offer/Answer - generate a new confirmed callback with updated SDP
-                mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-            }
-            handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
-         }
-         
-         // !jf! do I need to allow a reINVITE overlapping the retransmission of
-         // the ACK when a 200I is received? If yes, then I need to store all
-         // ACK messages for 64*T1
-         break;
-      }
-      case On2xx:
-         mStaleReInviteTimerSeq++;
-         sendAck();
-         transition(Connected);
-         handleSessionTimerResponse(msg);
-         handler->onIllegalNegotiation(getSessionHandle(), msg);
-         mProposedLocalOfferAnswer.reset();
-         mProposedEncryptionLevel = DialogUsageManager::None;
-         break;
-
-      case On422Invite:
-         mStaleReInviteTimerSeq++;
-         if(msg.exists(h_MinSE))
-         {
-            // Change interval to min from 422 response
-            mSessionInterval = msg.header(h_MinSE).value();
-            mMinSE = mSessionInterval;
-            sessionRefresh();
-         }
-         else
+         else if(mState == SentReinvite ||
+                 mState == SentReinviteNoOffer)
          {
-            // Response must contact Min_SE - if not - just ignore
-            // ?slg? callback?
             transition(Connected);
             mProposedLocalOfferAnswer.reset();
             mProposedEncryptionLevel = DialogUsageManager::None;
-         }
-         break;
-
-      case On491Invite:
-         mStaleReInviteTimerSeq++;
-         transition(SentReinviteGlare);
-         start491Timer();
-         break;
-
-      case OnGeneralFailure:
-         mStaleReInviteTimerSeq++;
-         sendBye();
-         transition(Terminated);
-         handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
-         break;
-
-      case OnInviteFailure:
-      case On487Invite:
-         mStaleReInviteTimerSeq++;
-         transition(Connected);
-         mProposedLocalOfferAnswer.reset();
-         handler->onOfferRejected(getSessionHandle(), &msg);
-         break;
 
-      case OnAck:
-      case OnAckAnswer:
-         // Not checking for strict equality, since request may have been digest challenged
-         if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
-         {
-            InfoLog(<< "dropped stale ACK");
-         }
-         else
-         {
-            mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
-            handler->onAckReceived(getSessionHandle(), msg);
+            // this is so the app can decide to ignore this. default implementation
+            // will call end next - which will send a BYE
+            mDum.mInviteSessionHandler->onStaleReInviteTimeout(getSessionHandle());
          }
-         break;
-
-      default:
-         dispatchOthers(msg);
-         break;
+      }
+   }
+   else if (timeout.type() == DumTimeout::SessionExpiration)
+   {
+      if(timeout.seq() == mSessionTimerSeq)
+      {
+         // this is so the app can decide to ignore this. default implementation
+         // will call end next - which will send a BYE
+         mDum.mInviteSessionHandler->onSessionExpired(getSessionHandle());
+      }
+   }
+   else if (timeout.type() == DumTimeout::SessionRefresh)
+   {
+     if(timeout.seq() == mSessionTimerSeq)
+     {
+        // Note: If not connected then we must be issueing a reinvite/update or
+        // receiving one - in either case the session timer stuff will get
+        // reset/renegotiated - thus just ignore this referesh
+        if(mState == Connected)  
+        {
+           sessionRefresh();
+        }
+     }
    }
 }
 
 void
-InviteSession::dispatchSentReinviteNoOffer(const SipMessage& msg)
+InviteSession::dispatchConnected(const SipMessage& msg)
 {
    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
@@ -1759,133 +1451,59 @@ InviteSession::dispatchSentReinviteNoOffer(const SipMessage& msg)
    {
       case OnInvite:
       case OnInviteReliable:
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
-      case OnUpdate:
-      case OnUpdateOffer:
-      {
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 491);
-         send(response);
-         break;
-      }
-
-      case On1xx:
-      case On1xxEarly:
-         // Some UA's send a 100 response to a ReInvite - just ignore it
+         *mLastRemoteSessionModification = msg;
+         transition(ReceivedReinviteNoOffer);
+         handler->onOfferRequired(getSessionHandle(), msg);
          break;
 
-      case On2xxAnswer:  // .slg. doesn't really make sense - should be in SentReinvite to get this
-      case On2xxOffer:
-      {
-         mStaleReInviteTimerSeq++;
-         transition(SentReinviteAnswered);
-         handleSessionTimerResponse(msg);
+      case OnInviteOffer:
+      case OnInviteReliableOffer:
+         *mLastRemoteSessionModification = msg;
+         transition(ReceivedReinvite);
          mCurrentEncryptionLevel = getEncryptionLevel(msg);
          mProposedRemoteOfferAnswer = std::move(offerAnswer); 
+
          handler->onOffer(getSessionHandle(), msg, *mProposedRemoteOfferAnswer);
          break;
-      }
 
       case On2xx:
-         mStaleReInviteTimerSeq++;
-         sendAck();
-         transition(Connected);
-         handleSessionTimerResponse(msg);
-         handler->onIllegalNegotiation(getSessionHandle(), msg);
-         mProposedLocalOfferAnswer.reset();
-         mProposedEncryptionLevel = DialogUsageManager::None;
-         break;
-
-      case On422Invite:
-         mStaleReInviteTimerSeq++;
-         if(msg.exists(h_MinSE))
-         {
-            // Change interval to min from 422 response
-            mSessionInterval = msg.header(h_MinSE).value();
-            mMinSE = mSessionInterval;
-            sessionRefresh();
-         }
-         else
-         {
-            // Response must contact Min_SE - if not - just ignore
-            // ?slg? callback?
-            transition(Connected);
-            mProposedLocalOfferAnswer.reset();
-            mProposedEncryptionLevel = DialogUsageManager::None;
-         }
-         break;
-
-      case On491Invite:
-         mStaleReInviteTimerSeq++;
-         transition(SentReinviteNoOfferGlare);
-         start491Timer();
-         break;
-
-      case OnGeneralFailure:
-         mStaleReInviteTimerSeq++;
-         sendBye();
-         transition(Terminated);
-         handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
+      case On2xxOffer:
+      case On2xxAnswer:
+         // retransmission of 200I
+         // !jf! Need to include the answer here.
+         // sendAck(); 
          break;
 
-      case OnInviteFailure:
-      case On487Invite:
-         mStaleReInviteTimerSeq++;
-         transition(Connected);
-         mProposedLocalOfferAnswer.reset();
-         handler->onOfferRejected(getSessionHandle(), &msg);
-         break;
+      case OnUpdateOffer:
+         transition(ReceivedUpdate);
 
-      default:
-         dispatchOthers(msg);
+         //  !kh!
+         //  Find out if it's an UPDATE requiring state change.
+         //  See rfc3311 5.2, 4th paragraph.
+         *mLastRemoteSessionModification = msg;
+         mCurrentEncryptionLevel = getEncryptionLevel(msg);
+         mProposedRemoteOfferAnswer = std::move(offerAnswer); 
+         handler->onOffer(getSessionHandle(), msg, *mProposedRemoteOfferAnswer);
          break;
-   }
-}
-
-void 
-InviteSession::dispatchReceivedReinviteSentOffer(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
 
-   switch (toEvent(msg, offerAnswer.get()))
-   {
-      case OnInvite:
-      case OnInviteReliable:
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
       case OnUpdate:
-      case OnUpdateOffer:
       {
+         // ?slg? no offerAnswer in update - just respond immediately (likely session timer) - do we need a callback?
          auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 491);
+         mDialog.makeResponse(*response, msg, 200);
+         handleSessionTimerRequest(*response, msg);
          send(response);
          break;
       }
-      case OnAckAnswer:
-         // Not checking for strict equality, since request may have been digest challenged
-         if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
-         {
-            InfoLog(<< "dropped stale ACK");
-         }
-         else
-         {
-            transition(Connected);
-            setCurrentLocalOfferAnswer(msg);
-            mCurrentRemoteOfferAnswer = std::move(offerAnswer);
-            mCurrentEncryptionLevel = getEncryptionLevel(msg);
-            mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
 
-            if (mDum.mDialogEventStateManager)
-            {
-               // New Offer/Answer - generate a new confirmed callback with updated SDP
-               mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
-            }
-            handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
-         }
+      case OnUpdateRejected:
+      case On200Update:
+         WarningLog (<< "DUM delivered an UPDATE response in an incorrect state " << endl << msg);
+         resip_assert(0);
          break;
+
       case OnAck:
+      case OnAckAnswer:
          // Not checking for strict equality, since request may have been digest challenged
          if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
          {
@@ -1893,110 +1511,492 @@ InviteSession::dispatchReceivedReinviteSentOffer(const SipMessage& msg)
          }
          else
          {
-            InfoLog(<< "Got Ack with no answer");
-            transition(Connected);
-            mProposedLocalOfferAnswer.reset();
-            mProposedEncryptionLevel = DialogUsageManager::None;
             mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
-            //!dcm! -- should this be onIllegalNegotiation?
-            handler->onOfferRejected(getSessionHandle(), &msg);
+            handler->onAckReceived(getSessionHandle(), msg);
          }
          break;
-      default:
-         dispatchOthers(msg);
-         break;
-   }
-}
-
-void
-InviteSession::dispatchGlare(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   MethodTypes method = msg.header(h_CSeq).method();
-   if (msg.isRequest() && (method == INVITE || method == UPDATE))
-   {
-      DebugLog(<< "Re-INVITE or UPDATE received when in SentReinviteGlare or SentUpdateGlare" << endl);
-      // Received inbound reinvite or update, when waiting to resend outbound reinvite or update
-      handler->onOfferRejected(getSessionHandle(), &msg);
-      if(!isTerminated())   // make sure application didn't call end()
-      {
-         dispatchConnected(msg);  // act as if we received message in Connected state
-      }
-      else
-      {
-         dispatchTerminated(msg);
-      }
-   }
-   else
-   {
-      dispatchOthers(msg);
-   }
-}
-
-void
-InviteSession::dispatchReinviteNoOfferGlare(const SipMessage& msg)
-{
-   InviteSessionHandler* handler = mDum.mInviteSessionHandler;
-   MethodTypes method = msg.header(h_CSeq).method();
-   if (msg.isRequest() && (method == INVITE || method == UPDATE))
-   {
-      // Received inbound reinvite or update, when waiting to resend outbound reinvite or update
-      handler->onOfferRequestRejected(getSessionHandle(), msg);
-      if(!isTerminated())   // make sure application didn't call end()
-      {
-         dispatchConnected(msg);  // act as if we received message in Connected state
-      }
-      else
-      {
-         dispatchTerminated(msg);
-      }
-   }
-   else
-   {
-      dispatchOthers(msg);
-   }
-}
-
-void
-InviteSession::dispatchReceivedUpdateOrReinvite(const SipMessage& msg)
-{
-   // InviteSessionHandler* handler = mDum.mInviteSessionHandler; // unused
-   std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
-
-   switch (toEvent(msg, offerAnswer.get()))
-   {
-      case OnInvite:
-      case OnInviteReliable:
-      case OnInviteOffer:
-      case OnInviteReliableOffer:
-      case OnUpdate:
-      case OnUpdateOffer:
-      {
-         // Means that the UAC has sent us a second reINVITE or UPDATE before we
-         // responded to the first one. Bastard!
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, msg, 500);
-         response->header(h_RetryAfter).value() = Random::getRandom() % 10;
-         send(response);
-         break;
-      }
-      case OnBye:
-      {
-         // BYE received after a reINVITE, terminate the reINVITE transaction.
-         auto response = std::make_shared<SipMessage>();
-         mDialog.makeResponse(*response, *mLastRemoteSessionModification, 487); // Request Terminated
-         handleSessionTimerRequest(*response, *mLastRemoteSessionModification);
-         send(response);
 
-         dispatchBye(msg);
-         break;
-      }
       default:
          dispatchOthers(msg);
          break;
    }
 }
 
+// void
+// InviteSession::dispatchSentUpdate(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
+
+//    switch (toEvent(msg, offerAnswer.get()))
+//    {
+//       case OnInvite:
+//       case OnInviteReliable:
+//       case OnInviteOffer:
+//       case OnInviteReliableOffer:
+//       case OnUpdate:
+//       case OnUpdateOffer:
+//       {
+//          // glare
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, msg, 491);
+//          send(response);
+//          break;
+//       }
+
+//       case On200Update:
+//          transition(Connected);
+//          handleSessionTimerResponse(msg);
+//          if (offerAnswer && mProposedLocalOfferAnswer)
+//          {
+//             mCurrentEncryptionLevel = getEncryptionLevel(msg);
+//             setCurrentLocalOfferAnswer(msg);
+
+//             mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
+//             if (mDum.mDialogEventStateManager)
+//             {
+//                 // New Offer/Answer - generate a new confirmed callback with updated SDP
+//                 mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+//             }
+//             handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
+//          }
+//          else if(mProposedLocalOfferAnswer) 
+//          {
+//             // If we sent an offer in the Update Request and no answer is received
+//             handler->onIllegalNegotiation(getSessionHandle(), msg);
+//             mProposedLocalOfferAnswer.reset();
+//             mProposedEncryptionLevel = DialogUsageManager::None;
+//          }
+//          break;
+
+//       case On491Update:
+//          transition(SentUpdateGlare);
+//          start491Timer();
+//          break;
+
+//       case On422Update: // session timer
+//          if(msg.exists(h_MinSE))
+//          {
+//             // Change interval to min from 422 response
+//             mSessionInterval = msg.header(h_MinSE).value();
+//             mMinSE = mSessionInterval;
+//             sessionRefresh();
+//          }
+//          else
+//          {
+//             // Response must contain Min_SE - if not - just ignore
+//             // ?slg? callback?
+//             transition(Connected);
+//             mProposedLocalOfferAnswer.reset();
+//             mProposedEncryptionLevel = DialogUsageManager::None;
+//          }
+//          break;
+
+//       case OnUpdateRejected:
+//          transition(Connected);
+//          mProposedLocalOfferAnswer.reset();
+//          handler->onOfferRejected(getSessionHandle(), &msg);
+//          break;
+
+//       case OnGeneralFailure:
+//          sendBye();
+//          transition(Terminated);
+//          handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
+//          break;
+
+//       default:
+//          dispatchOthers(msg);
+//          break;
+//    }
+// }
+
+// void
+// InviteSession::dispatchSentReinvite(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
+
+//    switch (toEvent(msg, offerAnswer.get()))
+//    {
+//       case OnInvite:
+//       case OnInviteReliable:
+//       case OnInviteOffer:
+//       case OnInviteReliableOffer:
+//       case OnUpdate:
+//       case OnUpdateOffer:
+//       {
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, msg, 491);
+//          send(response);
+//          break;
+//       }
+
+//       case On1xx:
+//       case On1xxEarly:
+//          // Some UA's send a 100 response to a ReInvite - just ignore it
+//          break;
+
+//       case On2xxAnswer:
+//       case On2xxOffer:  // .slg. doesn't really make sense - should be in SentReinviteNoOffer to get this
+//       {
+//          mStaleReInviteTimerSeq++;
+//          transition(Connected);
+//          handleSessionTimerResponse(msg);
+//          setCurrentLocalOfferAnswer(msg);
+
+//          // !jf! I need to potentially include an answer in the ACK here
+//          sendAck();
+//          mCurrentEncryptionLevel = getEncryptionLevel(msg);
+         
+//          if (mSessionRefreshReInvite)
+//          {
+//             mSessionRefreshReInvite = false;
+         
+//             if (*mCurrentRemoteOfferAnswer != *offerAnswer)
+//             {
+//                mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
+//                if (mDum.mDialogEventStateManager)
+//                {
+//                    // New Offer/Answer - generate a new confirmed callback with updated SDP
+//                    mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+//                }
+//                handler->onRemoteAnswerChanged(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
+//             }
+//          }
+//          else
+//          {
+//             mCurrentRemoteOfferAnswer = std::move(offerAnswer); 
+//             if (mDum.mDialogEventStateManager)
+//             {
+//                 // New Offer/Answer - generate a new confirmed callback with updated SDP
+//                 mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+//             }
+//             handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
+//          }
+         
+//          // !jf! do I need to allow a reINVITE overlapping the retransmission of
+//          // the ACK when a 200I is received? If yes, then I need to store all
+//          // ACK messages for 64*T1
+//          break;
+//       }
+//       case On2xx:
+//          mStaleReInviteTimerSeq++;
+//          sendAck();
+//          transition(Connected);
+//          handleSessionTimerResponse(msg);
+//          handler->onIllegalNegotiation(getSessionHandle(), msg);
+//          mProposedLocalOfferAnswer.reset();
+//          mProposedEncryptionLevel = DialogUsageManager::None;
+//          break;
+
+//       case On422Invite:
+//          mStaleReInviteTimerSeq++;
+//          if(msg.exists(h_MinSE))
+//          {
+//             // Change interval to min from 422 response
+//             mSessionInterval = msg.header(h_MinSE).value();
+//             mMinSE = mSessionInterval;
+//             sessionRefresh();
+//          }
+//          else
+//          {
+//             // Response must contact Min_SE - if not - just ignore
+//             // ?slg? callback?
+//             transition(Connected);
+//             mProposedLocalOfferAnswer.reset();
+//             mProposedEncryptionLevel = DialogUsageManager::None;
+//          }
+//          break;
+
+//       case On491Invite:
+//          mStaleReInviteTimerSeq++;
+//          transition(SentReinviteGlare);
+//          // start491Timer();
+//          break;
+
+//       case OnGeneralFailure:
+//          mStaleReInviteTimerSeq++;
+//          sendBye();
+//          transition(Terminated);
+//          handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
+//          break;
+
+//       case OnInviteFailure:
+//       case On487Invite:
+//          mStaleReInviteTimerSeq++;
+//          transition(Connected);
+//          mProposedLocalOfferAnswer.reset();
+//          handler->onOfferRejected(getSessionHandle(), &msg);
+//          break;
+
+//       case OnAck:
+//       case OnAckAnswer:
+//          // Not checking for strict equality, since request may have been digest challenged
+//          if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
+//          {
+//             InfoLog(<< "dropped stale ACK");
+//          }
+//          else
+//          {
+//             mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
+//             handler->onAckReceived(getSessionHandle(), msg);
+//          }
+//          break;
+
+//       default:
+//          dispatchOthers(msg);
+//          break;
+//    }
+// }
+
+// void
+// InviteSession::dispatchSentReinviteNoOffer(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
+
+//    switch (toEvent(msg, offerAnswer.get()))
+//    {
+//       case OnInvite:
+//       case OnInviteReliable:
+//       case OnInviteOffer:
+//       case OnInviteReliableOffer:
+//       case OnUpdate:
+//       case OnUpdateOffer:
+//       {
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, msg, 491);
+//          send(response);
+//          break;
+//       }
+
+//       case On1xx:
+//       case On1xxEarly:
+//          // Some UA's send a 100 response to a ReInvite - just ignore it
+//          break;
+
+//       case On2xxAnswer:  // .slg. doesn't really make sense - should be in SentReinvite to get this
+//       case On2xxOffer:
+//       {
+//          mStaleReInviteTimerSeq++;
+//          transition(SentReinviteAnswered);
+//          handleSessionTimerResponse(msg);
+//          mCurrentEncryptionLevel = getEncryptionLevel(msg);
+//          mProposedRemoteOfferAnswer = std::move(offerAnswer); 
+//          handler->onOffer(getSessionHandle(), msg, *mProposedRemoteOfferAnswer);
+//          break;
+//       }
+
+//       case On2xx:
+//          mStaleReInviteTimerSeq++;
+//          sendAck();
+//          transition(Connected);
+//          handleSessionTimerResponse(msg);
+//          handler->onIllegalNegotiation(getSessionHandle(), msg);
+//          mProposedLocalOfferAnswer.reset();
+//          mProposedEncryptionLevel = DialogUsageManager::None;
+//          break;
+
+//       case On422Invite:
+//          mStaleReInviteTimerSeq++;
+//          if(msg.exists(h_MinSE))
+//          {
+//             // Change interval to min from 422 response
+//             mSessionInterval = msg.header(h_MinSE).value();
+//             mMinSE = mSessionInterval;
+//             sessionRefresh();
+//          }
+//          else
+//          {
+//             // Response must contact Min_SE - if not - just ignore
+//             // ?slg? callback?
+//             transition(Connected);
+//             mProposedLocalOfferAnswer.reset();
+//             mProposedEncryptionLevel = DialogUsageManager::None;
+//          }
+//          break;
+
+//       case On491Invite:
+//          mStaleReInviteTimerSeq++;
+//          transition(SentReinviteNoOfferGlare);
+//          // start491Timer();
+//          break;
+
+//       case OnGeneralFailure:
+//          mStaleReInviteTimerSeq++;
+//          sendBye();
+//          transition(Terminated);
+//          handler->onTerminated(getSessionHandle(), InviteSessionHandler::Error, &msg);
+//          break;
+
+//       case OnInviteFailure:
+//       case On487Invite:
+//          mStaleReInviteTimerSeq++;
+//          transition(Connected);
+//          mProposedLocalOfferAnswer.reset();
+//          handler->onOfferRejected(getSessionHandle(), &msg);
+//          break;
+
+//       default:
+//          dispatchOthers(msg);
+//          break;
+//    }
+// }
+
+// void 
+// InviteSession::dispatchReceivedReinviteSentOffer(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
+
+//    switch (toEvent(msg, offerAnswer.get()))
+//    {
+//       case OnInvite:
+//       case OnInviteReliable:
+//       case OnInviteOffer:
+//       case OnInviteReliableOffer:
+//       case OnUpdate:
+//       case OnUpdateOffer:
+//       {
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, msg, 491);
+//          send(response);
+//          break;
+//       }
+//       case OnAckAnswer:
+//          // Not checking for strict equality, since request may have been digest challenged
+//          if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
+//          {
+//             InfoLog(<< "dropped stale ACK");
+//          }
+//          else
+//          {
+//             transition(Connected);
+//             setCurrentLocalOfferAnswer(msg);
+//             mCurrentRemoteOfferAnswer = std::move(offerAnswer);
+//             mCurrentEncryptionLevel = getEncryptionLevel(msg);
+//             mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
+
+//             if (mDum.mDialogEventStateManager)
+//             {
+//                // New Offer/Answer - generate a new confirmed callback with updated SDP
+//                mDum.mDialogEventStateManager->onConfirmed(mDialog, getSessionHandle());
+//             }
+//             handler->onAnswer(getSessionHandle(), msg, *mCurrentRemoteOfferAnswer);
+//          }
+//          break;
+//       case OnAck:
+//          // Not checking for strict equality, since request may have been digest challenged
+//          if (mLastRemoteSessionModification->header(h_CSeq).sequence() > msg.header(h_CSeq).sequence())
+//          {
+//             InfoLog(<< "dropped stale ACK");
+//          }
+//          else
+//          {
+//             InfoLog(<< "Got Ack with no answer");
+//             transition(Connected);
+//             mProposedLocalOfferAnswer.reset();
+//             mProposedEncryptionLevel = DialogUsageManager::None;
+//             mCurrentRetransmit200 = 0; // stop the 200 retransmit timer
+//             //!dcm! -- should this be onIllegalNegotiation?
+//             handler->onOfferRejected(getSessionHandle(), &msg);
+//          }
+//          break;
+//       default:
+//          dispatchOthers(msg);
+//          break;
+//    }
+// }
+
+// void
+// InviteSession::dispatchGlare(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    MethodTypes method = msg.header(h_CSeq).method();
+//    if (msg.isRequest() && (method == INVITE || method == UPDATE))
+//    {
+//       DebugLog(<< "Re-INVITE or UPDATE received when in SentReinviteGlare or SentUpdateGlare" << endl);
+//       // Received inbound reinvite or update, when waiting to resend outbound reinvite or update
+//       handler->onOfferRejected(getSessionHandle(), &msg);
+//       if(!isTerminated())   // make sure application didn't call end()
+//       {
+//          dispatchConnected(msg);  // act as if we received message in Connected state
+//       }
+//       else
+//       {
+//          dispatchTerminated(msg);
+//       }
+//    }
+//    else
+//    {
+//       dispatchOthers(msg);
+//    }
+// }
+
+// void
+// InviteSession::dispatchReinviteNoOfferGlare(const SipMessage& msg)
+// {
+//    InviteSessionHandler* handler = mDum.mInviteSessionHandler;
+//    MethodTypes method = msg.header(h_CSeq).method();
+//    if (msg.isRequest() && (method == INVITE || method == UPDATE))
+//    {
+//       // Received inbound reinvite or update, when waiting to resend outbound reinvite or update
+//       handler->onOfferRequestRejected(getSessionHandle(), msg);
+//       if(!isTerminated())   // make sure application didn't call end()
+//       {
+//          dispatchConnected(msg);  // act as if we received message in Connected state
+//       }
+//       else
+//       {
+//          dispatchTerminated(msg);
+//       }
+//    }
+//    else
+//    {
+//       dispatchOthers(msg);
+//    }
+// }
+
+// void
+// InviteSession::dispatchReceivedUpdateOrReinvite(const SipMessage& msg)
+// {
+//    // InviteSessionHandler* handler = mDum.mInviteSessionHandler; // unused
+//    std::unique_ptr<Contents> offerAnswer = InviteSession::getOfferAnswer(msg);
+
+//    switch (toEvent(msg, offerAnswer.get()))
+//    {
+//       case OnInvite:
+//       case OnInviteReliable:
+//       case OnInviteOffer:
+//       case OnInviteReliableOffer:
+//       case OnUpdate:
+//       case OnUpdateOffer:
+//       {
+//          // Means that the UAC has sent us a second reINVITE or UPDATE before we
+//          // responded to the first one. Bastard!
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, msg, 500);
+//          response->header(h_RetryAfter).value() = Random::getRandom() % 10;
+//          send(response);
+//          break;
+//       }
+//       case OnBye:
+//       {
+//          // BYE received after a reINVITE, terminate the reINVITE transaction.
+//          auto response = std::make_shared<SipMessage>();
+//          mDialog.makeResponse(*response, *mLastRemoteSessionModification, 487); // Request Terminated
+//          handleSessionTimerRequest(*response, *mLastRemoteSessionModification);
+//          send(response);
+
+//          dispatchBye(msg);
+//          break;
+//       }
+//       default:
+//          dispatchOthers(msg);
+//          break;
+//    }
+// }
+
 
 void
 InviteSession::dispatchAnswered(const SipMessage& msg)
@@ -2012,19 +2012,19 @@ InviteSession::dispatchAnswered(const SipMessage& msg)
    }
 }
 
-void
-InviteSession::dispatchSentReinviteAnswered(const SipMessage& msg)
-{
-   if (msg.isResponse() &&
-       msg.header(h_CSeq).method() == INVITE &&
-       msg.header(h_StatusLine).statusCode() / 200 == 1)
-   {
-      // Receiving a 200 retransmission is possible - but we don't have an ACK response yet - we are still waiting for provideAnswer to be
-      // called by the app - so just drop the retransmission
-      return;
-   }
-   dispatchOthers(msg);
-}
+// void
+// InviteSession::dispatchSentReinviteAnswered(const SipMessage& msg)
+// {
+//    if (msg.isResponse() &&
+//        msg.header(h_CSeq).method() == INVITE &&
+//        msg.header(h_StatusLine).statusCode() / 200 == 1)
+//    {
+//       // Receiving a 200 retransmission is possible - but we don't have an ACK response yet - we are still waiting for provideAnswer to be
+//       // called by the app - so just drop the retransmission
+//       return;
+//    }
+//    dispatchOthers(msg);
+// }
 
 void
 InviteSession::dispatchWaitingToOffer(const SipMessage& msg)
@@ -2507,28 +2507,28 @@ InviteSession::startRetransmit200Timer()
 //  chosen value between 2.1 and 4 seconds in units of 10 ms.
 //  2. If the UAC is not the owner of the Call-ID of the dialog ID, T has a
 //  randomly chosen value of between 0 and 2 seconds in units of 10 ms.
-void
-InviteSession::start491Timer()
-{
-   unsigned int seq = mLastLocalSessionModification->header(h_CSeq).sequence();
-
-   if (dynamic_cast<ClientInviteSession*>(this))
-   {
-      int timer = Random::getRandom() % (4000 - 2100);
-      timer += 2100;
-      timer -= timer % 10;
+// void
+// InviteSession::start491Timer()
+// {
+//    unsigned int seq = mLastLocalSessionModification->header(h_CSeq).sequence();
+
+//    if (dynamic_cast<ClientInviteSession*>(this))
+//    {
+//       int timer = Random::getRandom() % (4000 - 2100);
+//       timer += 2100;
+//       timer -= timer % 10;
       
-      DebugLog(<< "491 timer value: " << timer << "ms" << endl);
-      mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
-   }
-   else
-   {
-      int timer = Random::getRandom() % 2000;
-      timer -= timer % 10;
-      DebugLog(<< "491 timer value: " << timer << "ms" << endl);
-      mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
-   }
-}
+//       DebugLog(<< "491 timer value: " << timer << "ms" << endl);
+//       mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
+//    }
+//    else
+//    {
+//       int timer = Random::getRandom() % 2000;
+//       timer -= timer % 10;
+//       DebugLog(<< "491 timer value: " << timer << "ms" << endl);
+//       mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
+//    }
+// }
 
 void 
 InviteSession::startStaleReInviteTimer()
@@ -2629,7 +2629,7 @@ InviteSession::setSessionTimerPreferences()
       mSessionRefresher = dynamic_cast<ServerInviteSession*>(this) != NULL; // Default refresher is callee
       break;
    case Profile::PreferCallerRefreshes:
-      mSessionRefresher = dynamic_cast<ClientInviteSession*>(this) != NULL; // Default refresher is caller
+      // mSessionRefresher = dynamic_cast<ClientInviteSession*>(this) != NULL; // Default refresher is caller
       break;
    }
 }
@@ -2952,14 +2952,14 @@ std::unique_ptr<Contents>
 InviteSession::makeOfferAnswer(const Contents& offerAnswer,
                                const Contents* alternative)
 {
-   if (alternative)
-   {
-      MultipartAlternativeContents* mac = new MultipartAlternativeContents;
-      mac->parts().push_back(alternative->clone());
-      mac->parts().push_back(offerAnswer.clone());
-      return std::unique_ptr<Contents>(mac);
-   }
-   else
+   // if (alternative)
+   // {
+   //    MultipartAlternativeContents* mac = new MultipartAlternativeContents;
+   //    mac->parts().push_back(alternative->clone());
+   //    mac->parts().push_back(offerAnswer.clone());
+   //    return std::unique_ptr<Contents>(mac);
+   // }
+   // else
    {
       return std::unique_ptr<Contents>(offerAnswer.clone());
    }
@@ -2972,14 +2972,14 @@ InviteSession::setOfferAnswer(SipMessage& msg, const Contents& offerAnswer, cons
 
    // This will clone the offerAnswer since the InviteSession also wants to keep its own
    // copy of the offerAnswer around for the application to access
-   if (alternative)
-   {
-      MultipartAlternativeContents* mac = new MultipartAlternativeContents;
-      mac->parts().push_back(alternative->clone());
-      mac->parts().push_back(offerAnswer.clone());
-      msg.setContents(unique_ptr<Contents>(mac));
-   }
-   else
+   // if (alternative)
+   // {
+   //    MultipartAlternativeContents* mac = new MultipartAlternativeContents;
+   //    mac->parts().push_back(alternative->clone());
+   //    mac->parts().push_back(offerAnswer.clone());
+   //    msg.setContents(unique_ptr<Contents>(mac));
+   // }
+   // else
    {
       msg.setContents(&offerAnswer);
    }
@@ -2995,16 +2995,16 @@ InviteSession::setOfferAnswer(SipMessage& msg, const Contents* offerAnswer)
 void 
 InviteSession::provideProposedOffer()
 {
-   MultipartAlternativeContents* mp_ans =
-     dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get());
-   if (mp_ans)
-   {
-      // .kw. can cast below ever be NULL? Need assert/throw?
-      provideOffer( *(dynamic_cast<Contents*>((mp_ans)->parts().back())),
-                    mProposedEncryptionLevel,
-                    dynamic_cast<Contents*>((mp_ans)->parts().front()));
-   }
-   else
+   // MultipartAlternativeContents* mp_ans =
+   //   dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get());
+   // if (mp_ans)
+   // {
+   //    // .kw. can cast below ever be NULL? Need assert/throw?
+   //    provideOffer( *(dynamic_cast<Contents*>((mp_ans)->parts().back())),
+   //                  mProposedEncryptionLevel,
+   //                  dynamic_cast<Contents*>((mp_ans)->parts().front()));
+   // }
+   // else
    {
       // .kw. can cast below ever be NULL? Need assert/throw?
       provideOffer(*(dynamic_cast<Contents*>(mProposedLocalOfferAnswer.get())), mProposedEncryptionLevel, 0);
@@ -3298,18 +3298,18 @@ void
 InviteSession::setCurrentLocalOfferAnswer(const SipMessage& msg)
 {
    resip_assert(mProposedLocalOfferAnswer.get());
-   if (dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))
-   {
-      if (DialogUsageManager::Encrypt == getEncryptionLevel(msg) || DialogUsageManager::SignAndEncrypt == getEncryptionLevel(msg))
-      {
-         mCurrentLocalOfferAnswer = unique_ptr<Contents>(static_cast<Contents*>((dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))->parts().back()->clone()));
-      }
-      else
-      {
-         mCurrentLocalOfferAnswer = unique_ptr<Contents>(static_cast<Contents*>((dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))->parts().front()->clone()));
-      }
-   }
-   else
+   // if (dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))
+   // {
+   //    if (DialogUsageManager::Encrypt == getEncryptionLevel(msg) || DialogUsageManager::SignAndEncrypt == getEncryptionLevel(msg))
+   //    {
+   //       mCurrentLocalOfferAnswer = unique_ptr<Contents>(static_cast<Contents*>((dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))->parts().back()->clone()));
+   //    }
+   //    else
+   //    {
+   //       mCurrentLocalOfferAnswer = unique_ptr<Contents>(static_cast<Contents*>((dynamic_cast<MultipartAlternativeContents*>(mProposedLocalOfferAnswer.get()))->parts().front()->clone()));
+   //    }
+   // }
+   // else
    {
       mCurrentLocalOfferAnswer = unique_ptr<Contents>(static_cast<Contents*>(mProposedLocalOfferAnswer->clone()));
    }
diff --git a/resip/dum/InviteSession.hxx b/resip/dum/InviteSession.hxx
old mode 100644
new mode 100755
index fa20e5607..fc8820191
--- a/resip/dum/InviteSession.hxx
+++ b/resip/dum/InviteSession.hxx
@@ -85,19 +85,19 @@ class InviteSession : public DialogUsage
       // Following methods are for sending requests within a dialog
 
       /** sends a refer request */
-      virtual void refer(const NameAddr& referTo, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, const NameAddr& referredBy, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, std::unique_ptr<resip::Contents> contents, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, const NameAddr& referredBy, std::unique_ptr<resip::Contents> contents, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, const NameAddr& referredBy, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, std::unique_ptr<resip::Contents> contents, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, const NameAddr& referredBy, std::unique_ptr<resip::Contents> contents, bool referSub = true);
 
       /** sends a refer request with a replaces header */
-      virtual void refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, std::unique_ptr<resip::Contents> contents, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, const CallId& replaces, bool referSub = true);
-      virtual void refer(const NameAddr& referTo, const CallId& replaces, std::unique_ptr<resip::Contents> contents, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, InviteSessionHandle sessionToReplace, std::unique_ptr<resip::Contents> contents, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, const CallId& replaces, bool referSub = true);
+      // virtual void refer(const NameAddr& referTo, const CallId& replaces, std::unique_ptr<resip::Contents> contents, bool referSub = true);
 
       /** sends an info request */
-      virtual void info(const Contents& contents);
+      // virtual void info(const Contents& contents);
 
       /** sends a message request 
 
@@ -136,9 +136,9 @@ class InviteSession : public DialogUsage
       /** Asynchronously rejects an offer at the SIP level.  Can also be used to
           send a 488 to a reINVITE or UPDATE */
       virtual void rejectCommand(int statusCode, WarningCategory *warning = 0);
-      virtual void referCommand(const NameAddr& referTo, bool referSub = true);
-      virtual void referCommand(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub = true);
-      virtual void infoCommand(const Contents& contents);
+      // virtual void referCommand(const NameAddr& referTo, bool referSub = true);
+      // virtual void referCommand(const NameAddr& referTo, InviteSessionHandle sessionToReplace, bool referSub = true);
+      // virtual void infoCommand(const Contents& contents);
       virtual void messageCommand(const Contents& contents);
       /** Asynchronously accepts an INFO or MESSAGE request with a 2xx and an optional contents */
       virtual void acceptNITCommand(int statusCode = 200, const Contents * contents = 0);
@@ -305,14 +305,14 @@ class InviteSession : public DialogUsage
 
       // Utility methods (one for each State)
       void dispatchConnected(const SipMessage& msg);
-      void dispatchSentUpdate(const SipMessage& msg);
-      void dispatchSentReinvite(const SipMessage& msg);
-      void dispatchSentReinviteNoOffer(const SipMessage& msg);
-      void dispatchSentReinviteAnswered(const SipMessage& msg);
-      void dispatchGlare(const SipMessage& msg);
-      void dispatchReinviteNoOfferGlare(const SipMessage& msg);
-      void dispatchReceivedUpdateOrReinvite(const SipMessage& msg);
-      void dispatchReceivedReinviteSentOffer(const SipMessage& msg);
+      // void dispatchSentUpdate(const SipMessage& msg);
+      // void dispatchSentReinvite(const SipMessage& msg);
+      // void dispatchSentReinviteNoOffer(const SipMessage& msg);
+      // void dispatchSentReinviteAnswered(const SipMessage& msg);
+      // void dispatchGlare(const SipMessage& msg);
+      // void dispatchReinviteNoOfferGlare(const SipMessage& msg);
+      // void dispatchReceivedUpdateOrReinvite(const SipMessage& msg);
+      // void dispatchReceivedReinviteSentOffer(const SipMessage& msg);
       void dispatchAnswered(const SipMessage& msg);
       void dispatchWaitingToOffer(const SipMessage& msg);
       void dispatchWaitingToRequestOffer(const SipMessage& msg);
@@ -324,7 +324,7 @@ class InviteSession : public DialogUsage
       void dispatchMessage(const SipMessage& msg);
 
       void startRetransmit200Timer();
-      void start491Timer();
+      // void start491Timer();
       void startStaleReInviteTimer();
 
       void setSessionTimerHeaders(SipMessage& msg);
diff --git a/resip/dum/InviteSessionHandler.hxx b/resip/dum/InviteSessionHandler.hxx
old mode 100644
new mode 100755
index 844a79bcb..b2a5b0bcf
--- a/resip/dum/InviteSessionHandler.hxx
+++ b/resip/dum/InviteSessionHandler.hxx
@@ -45,21 +45,21 @@ class InviteSessionHandler
       virtual bool isGenericOfferAnswer() { return mGenericOfferAnswer; }
 
       /// called when an initial INVITE or the intial response to an outoing invite  
-      virtual void onNewSession(ClientInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
+      // virtual void onNewSession(ClientInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
       virtual void onNewSession(ServerInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
 
       /// Received a failure response from UAS
-      virtual void onFailure(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onFailure(ClientInviteSessionHandle, const SipMessage& msg)=0;
       
       /// called when an in-dialog provisional response is received that contains a body
-      virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const SdpContents&)=0;
+      // virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const SdpContents&)=0;
       virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const Contents&);
 
       /// called when dialog enters the Early state - typically after getting 18x
-      virtual void onProvisional(ClientInviteSessionHandle, const SipMessage&)=0;
+      // virtual void onProvisional(ClientInviteSessionHandle, const SipMessage&)=0;
 
       /// called when a dialog initiated as a UAC enters the connected state
-      virtual void onConnected(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onConnected(ClientInviteSessionHandle, const SipMessage& msg)=0;
 
       /// called when a dialog initiated as a UAS enters the connected state
       virtual void onConnected(InviteSessionHandle, const SipMessage& msg)=0;
@@ -101,7 +101,7 @@ class InviteSessionHandler
 
       /// called when a fork that was created through a 1xx never receives a 2xx
       /// because another fork answered and this fork was canceled by a proxy. 
-      virtual void onForkDestroyed(ClientInviteSessionHandle)=0;
+      // virtual void onForkDestroyed(ClientInviteSessionHandle)=0;
 
       /// called when a 3xx with valid targets is encountered in an early dialog     
       /// This is different then getting a 3xx in onTerminated, as another
@@ -109,7 +109,7 @@ class InviteSessionHandler
       /// Basically an onTermintated that conveys more information.
       /// checking for 3xx respones in onTerminated will not work as there may
       /// be no valid targets.
-      virtual void onRedirected(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onRedirected(ClientInviteSessionHandle, const SipMessage& msg)=0;
 
       /// called to allow app to adorn a message. default is to send immediately
       virtual void onReadyToSend(InviteSessionHandle, SipMessage& msg);
diff --git a/resip/dum/KeepAliveManager.cxx b/resip/dum/KeepAliveManager.cxx
old mode 100644
new mode 100755
diff --git a/resip/dum/KeepAliveManager.hxx b/resip/dum/KeepAliveManager.hxx
old mode 100644
new mode 100755
diff --git a/resip/dum/ServerInviteSession.cxx b/resip/dum/ServerInviteSession.cxx
old mode 100644
new mode 100755
index ce9e6fb64..ed9259156
--- a/resip/dum/ServerInviteSession.cxx
+++ b/resip/dum/ServerInviteSession.cxx
@@ -1,5 +1,5 @@
-#include "resip/stack/MultipartMixedContents.hxx"
-#include "resip/stack/MultipartAlternativeContents.hxx"
+// #include "resip/stack/MultipartMixedContents.hxx"
+// #include "resip/stack/MultipartAlternativeContents.hxx"
 #include "resip/dum/Dialog.hxx"
 #include "resip/dum/DialogEventStateManager.hxx"
 #include "resip/dum/DialogUsageManager.hxx"
@@ -1755,7 +1755,7 @@ ServerInviteSession::dispatchSentUpdate(const SipMessage& msg)
 
       case On491Update:
          transition(UAS_SentUpdateGlare);
-         start491Timer();
+         // start491Timer();
          break;
 
       default:
diff --git a/resip/stack/CMakeLists.txt b/resip/stack/CMakeLists.txt
old mode 100644
new mode 100755
index d7c2f4c46..9cf4df615
--- a/resip/stack/CMakeLists.txt
+++ b/resip/stack/CMakeLists.txt
@@ -22,19 +22,19 @@ set(INCLUDES
    ContentsFactoryBase.hxx
    ContentsFactory.hxx
    Contents.hxx
-   CpimContents.hxx
+   #CpimContents.hxx
    CSeqCategory.hxx
    DataParameter.hxx
    DateCategory.hxx
    DeprecatedDialog.hxx
-   DialogInfoContents.hxx
+   #DialogInfoContents.hxx
    Dispatcher.hxx
    DnsInterface.hxx
    DnsResult.hxx
    DnsResultMessage.hxx
    DomainMatcher.hxx
    DtlsMessage.hxx
-   DtmfPayloadContents.hxx
+   #DtmfPayloadContents.hxx
    Embedded.hxx
    EnableFlowTimer.hxx
    EventStackThread.hxx
@@ -44,10 +44,10 @@ set(INCLUDES
    ExtendedDomainMatcher.hxx
    ExtensionHeader.hxx
    ExtensionParameter.hxx
-   ExternalBodyContents.hxx
+   #ExternalBodyContents.hxx
    FloatParameter.hxx
-   GenericContents.hxx
-   GenericPidfContents.hxx
+   #GenericContents.hxx
+   #GenericPidfContents.hxx
    GenericUri.hxx
    HEPSipMessageLoggingHandler.hxx
    HeaderFieldValue.hxx
@@ -61,25 +61,25 @@ set(INCLUDES
    InternalTransport.hxx
    InteropHelper.hxx
    InterruptableStackThread.hxx
-   InvalidContents.hxx
+   #InvalidContents.hxx
    InvokeAfterSocketCreationFunc.hxx
-   KeepAliveMessage.hxx
-   KeepAlivePong.hxx
+   #KeepAliveMessage.hxx
+   #KeepAlivePong.hxx
    LazyParser.hxx
-   MediaControlContents.hxx
+   #MediaControlContents.hxx
    MarkListener.hxx
    MessageDecorator.hxx
    MessageFilterRule.hxx
    Message.hxx
-   MessageWaitingContents.hxx
+   #MessageWaitingContents.hxx
    MethodHash.hxx
    MethodTypes.hxx
    Mime.hxx
    MsgHeaderScanner.hxx
-   MultipartAlternativeContents.hxx
-   MultipartMixedContents.hxx
-   MultipartRelatedContents.hxx
-   MultipartSignedContents.hxx
+   #MultipartAlternativeContents.hxx
+   #MultipartMixedContents.hxx
+   #MultipartRelatedContents.hxx
+   #MultipartSignedContents.hxx
    NameAddr.hxx
    NonceHelper.hxx
    OctetContents.hxx
@@ -91,10 +91,10 @@ set(INCLUDES
    ParserCategory.hxx
    ParserContainerBase.hxx
    ParserContainer.hxx
-   Pidf.hxx
-   Pkcs7Contents.hxx
-   Pkcs8Contents.hxx
-   PlainContents.hxx
+   #Pidf.hxx
+   #Pkcs7Contents.hxx
+   #Pkcs8Contents.hxx
+   #PlainContents.hxx
    PollStatistics.hxx
    PrivacyCategory.hxx
    QuotedDataParameter.hxx
@@ -104,7 +104,7 @@ set(INCLUDES
    ReceivedParameter.hxx
    RemoveTransport.hxx
    RequestLine.hxx
-   Rlmi.hxx
+   #Rlmi.hxx
    RportParameter.hxx
    SdpContents.hxx
    SecurityAttributes.hxx
@@ -112,8 +112,8 @@ set(INCLUDES
    SendData.hxx
    SERNonceHelper.hxx
    ShutdownMessage.hxx
-   SipConfigParse.hxx
-   SipFrag.hxx
+   #SipConfigParse.hxx
+   #SipFrag.hxx
    SipMessage.hxx
    SipStack.hxx
    ssl/DtlsTransport.hxx
@@ -157,8 +157,8 @@ set(INCLUDES
    Transport.hxx
    TransportSelector.hxx
    TransportThread.hxx
-   TrickleIceContents.hxx
-   TuIM.hxx
+   #TrickleIceContents.hxx
+   #TuIM.hxx
    Tuple.hxx
    TupleMarkManager.hxx
    TuSelector.hxx
@@ -174,16 +174,16 @@ set(INCLUDES
    WarningCategory.hxx
    Worker.hxx
    WorkerThread.hxx
-   WsBaseTransport.hxx
-   WsDecorator.hxx
-   WsFrameExtractor.hxx
-   WsTransport.hxx
-   WsConnection.hxx
-   WsConnectionBase.hxx
-   WsConnectionValidator.hxx
-   WsCookieContext.hxx
-   WsCookieContextFactory.hxx
-   X509Contents.hxx
+   #WsBaseTransport.hxx
+   #WsDecorator.hxx
+   #WsFrameExtractor.hxx
+   #WsTransport.hxx
+   #WsConnection.hxx
+   #WsConnectionBase.hxx
+   #WsConnectionValidator.hxx
+   #WsCookieContext.hxx
+   #WsCookieContextFactory.hxx
+   #X509Contents.hxx
    ZeroOutStatistics.hxx
 )
 
@@ -194,7 +194,7 @@ add_library(resip
    Cookie.cxx
    DateCategory.cxx
    gen/DayOfWeekHash.cxx
-   DtmfPayloadContents.cxx
+   #DtmfPayloadContents.cxx
    ExpiresCategory.cxx
    GenericUri.cxx
    IntegerCategory.cxx
@@ -222,10 +222,10 @@ add_library(resip
    ConnectionManager.cxx
    Contents.cxx
    ContentsFactoryBase.cxx
-   CpimContents.cxx
+   #CpimContents.cxx
    DataParameter.cxx
    DeprecatedDialog.cxx
-   DialogInfoContents.cxx
+   #DialogInfoContents.cxx
    Dispatcher.cxx
    DnsInterface.cxx
    DnsResult.cxx
@@ -235,12 +235,12 @@ add_library(resip
    ExtensionHeader.cxx
    ExistsOrDataParameter.cxx
    ExistsParameter.cxx
-   ExternalBodyContents.cxx
+   #ExternalBodyContents.cxx
    ExtendedDomainMatcher.cxx
    QValue.cxx
    QValueParameter.cxx
-   GenericContents.cxx
-   GenericPidfContents.cxx
+   #GenericContents.cxx
+   #GenericPidfContents.cxx
    HEPSipMessageLoggingHandler.cxx
    HeaderFieldValue.cxx
    HeaderFieldValueList.cxx
@@ -252,17 +252,17 @@ add_library(resip
    UInt32Parameter.cxx
    InternalTransport.cxx
    LazyParser.cxx
-   MediaControlContents.cxx
+   #MediaControlContents.cxx
    Message.cxx
-   MessageWaitingContents.cxx
+   #MessageWaitingContents.cxx
    gen/MethodHash.cxx
    MethodTypes.cxx
    gen/MonthHash.cxx
    MsgHeaderScanner.cxx
-   MultipartAlternativeContents.cxx
-   MultipartMixedContents.cxx
-   MultipartRelatedContents.cxx
-   MultipartSignedContents.cxx
+   #MultipartAlternativeContents.cxx
+   #MultipartMixedContents.cxx
+   #MultipartRelatedContents.cxx
+   #MultipartSignedContents.cxx
    NonceHelper.cxx
    OctetContents.cxx
    Parameter.cxx
@@ -270,22 +270,22 @@ add_library(resip
    ParameterTypes.cxx
    ParserCategory.cxx
    ParserContainerBase.cxx
-   Pidf.cxx
-   Pkcs7Contents.cxx
-   Pkcs8Contents.cxx
-   PlainContents.cxx
+   #Pidf.cxx
+   #Pkcs7Contents.cxx
+   #Pkcs8Contents.cxx
+   #PlainContents.cxx
    PrivacyCategory.cxx
    QuotedDataParameter.cxx
    RAckCategory.cxx
    ReceivedParameter.cxx
-   Rlmi.cxx
+   #Rlmi.cxx
    RportParameter.cxx
    SERNonceHelper.cxx
    SdpContents.cxx
    SecurityAttributes.cxx
    Compression.cxx
-   SipConfigParse.cxx
-   SipFrag.cxx
+   #SipConfigParse.cxx
+   #SipFrag.cxx
    SipMessage.cxx
    SipStack.cxx
    StackThread.cxx
@@ -314,24 +314,24 @@ add_library(resip
    TransportThread.cxx
    TransportFailure.cxx
    TransportSelector.cxx
-   TrickleIceContents.cxx
-   TuIM.cxx
+   #TrickleIceContents.cxx
+   #TuIM.cxx
    TuSelector.cxx
    UdpTransport.cxx
    UnknownParameter.cxx
    Uri.cxx
-   X509Contents.cxx
-   KeepAliveMessage.cxx
+   #X509Contents.cxx
+   #KeepAliveMessage.cxx
    StatelessHandler.cxx
-   InvalidContents.cxx
+   #InvalidContents.cxx
    WorkerThread.cxx
-   WsBaseTransport.cxx
-   WsFrameExtractor.cxx
-   WsTransport.cxx
-   WsConnection.cxx
-   WsConnectionBase.cxx
-   WsCookieContext.cxx
-   WsDecorator.cxx
+   #WsBaseTransport.cxx
+   #WsFrameExtractor.cxx
+   #WsTransport.cxx
+   #WsConnection.cxx
+   #WsConnectionBase.cxx
+   #WsCookieContext.cxx
+   #WsDecorator.cxx
 
    ${INCLUDES}
 )
@@ -410,7 +410,7 @@ version_libname(resip)
 set_target_properties(resip PROPERTIES FOLDER resip)
 
 install(TARGETS resip DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/stack ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/stack ${INCLUDES})
 
 if(BUILD_TESTING)
     add_subdirectory(test)
diff --git a/resip/stack/Connection.cxx b/resip/stack/Connection.cxx
old mode 100644
new mode 100755
index 05e0dd66a..fd9a46f99
--- a/resip/stack/Connection.cxx
+++ b/resip/stack/Connection.cxx
@@ -384,21 +384,21 @@ Connection::read()
    {
       if (mReceivingTransmissionFormat == WebSocketHandshake)
       {
-         bool dropConnection = false;
-         if(wsProcessHandshake(bytesRead, dropConnection))
-         {
-            ensureWritable();
-            if(performWrites())
-            {
-               mReceivingTransmissionFormat = WebSocketData;
-            }
-            else
-            {
-               // The write failed, returning -1 to the read will cause this connection to get deleted in performReads
-               bytesRead = -1;
-            }
-         }
-         else if(dropConnection)
+         // bool dropConnection = false;
+         // if(wsProcessHandshake(bytesRead, dropConnection))
+         // {
+         //    ensureWritable();
+         //    if(performWrites())
+         //    {
+         //       mReceivingTransmissionFormat = WebSocketData;
+         //    }
+         //    else
+         //    {
+         //       // The write failed, returning -1 to the read will cause this connection to get deleted in performReads
+         //       bytesRead = -1;
+         //    }
+         // }
+         // else if(dropConnection)
          {
             bytesRead=-1;
          }
@@ -407,7 +407,7 @@ Connection::read()
       {
          if (mReceivingTransmissionFormat == WebSocketData)
          {
-            if(!wsProcessData(bytesRead))
+            // if(!wsProcessData(bytesRead))
             {
                bytesRead=-1;
             }
diff --git a/resip/stack/ConnectionBase.cxx b/resip/stack/ConnectionBase.cxx
old mode 100644
new mode 100755
index 76e245d92..79d96bf5b
--- a/resip/stack/ConnectionBase.cxx
+++ b/resip/stack/ConnectionBase.cxx
@@ -6,13 +6,13 @@
 
 #include "rutil/Logger.hxx"
 #include "resip/stack/ConnectionBase.hxx"
-#include "resip/stack/WsConnectionBase.hxx"
+// #include "resip/stack/WsConnectionBase.hxx"
 #include "resip/stack/SipMessage.hxx"
-#include "resip/stack/WsDecorator.hxx"
+// #include "resip/stack/WsDecorator.hxx"
 #include "resip/stack/Cookie.hxx"
-#include "resip/stack/WsBaseTransport.hxx"
-#include "resip/stack/WsCookieContext.hxx"
-#include "resip/stack/WsCookieContextFactory.hxx"
+// #include "resip/stack/WsBaseTransport.hxx"
+// #include "resip/stack/WsCookieContext.hxx"
+// #include "resip/stack/WsCookieContextFactory.hxx"
 #include "resip/stack/Symbols.hxx"
 #include "rutil/WinLeakCheck.hxx"
 #include "rutil/Sha1.hxx"
@@ -63,7 +63,7 @@ ConnectionBase::ConnectionBase(Transport* transport, const Tuple& who, Compressi
      mBuffer(0),
      mBufferPos(0),
      mBufferSize(0),
-     mWsFrameExtractor((Data::size_type)messageSizeMax),
+   //   mWsFrameExtractor((Data::size_type)messageSizeMax),
      mLastUsed(Timer::getTimeMs()),
      mConnState(NewMessage)
 {
@@ -584,164 +584,164 @@ ConnectionBase::preparseNewBytes(int bytesRead)
    return true;
 }
 
-void
-ConnectionBase::wsParseCookies(CookieList& cookieList, const SipMessage* message)
-{
-   Data name;
-   Data value;
-   StringCategories::const_iterator it = message->header(h_Cookies).begin();
-   for (; it != message->header(h_Cookies).end(); ++it)
-   {
-      ParseBuffer pb((*it).value());
-      while(!pb.eof())
-      {
-         const char* anchor =  pb.skipWhitespace();
-
-         pb.skipToChar(Symbols::EQUALS[0]);
-         pb.data(name, anchor);
-
-         anchor = pb.skipChar(Symbols::EQUALS[0]);
-         if(*(pb.position()) == Symbols::DOUBLE_QUOTE[0])
-         {
-            anchor = pb.skipChar(Symbols::DOUBLE_QUOTE[0]);
-            pb.skipToChar(Symbols::DOUBLE_QUOTE[0]);
-            pb.data(value, anchor);
-            pb.skipChar(Symbols::DOUBLE_QUOTE[0]);
-         }
-         else
-         {
-            pb.skipToOneOf(Symbols::SEMI_COLON, ParseBuffer::Whitespace);
-            pb.data(value, anchor);
-         }
-
-         Cookie cookie(name, value);
-         cookieList.push_back(cookie);
-         DebugLog(<< "Cookie: " << cookie);
-
-         if(!pb.eof() && *(pb.position()) == Symbols::SEMI_COLON[0])
-         {
-            pb.skipChar(Symbols::SEMI_COLON[0]);
-         }
-
-         pb.skipWhitespace();
-      }
-   }
-}
+// void
+// ConnectionBase::wsParseCookies(CookieList& cookieList, const SipMessage* message)
+// {
+//    Data name;
+//    Data value;
+//    StringCategories::const_iterator it = message->header(h_Cookies).begin();
+//    for (; it != message->header(h_Cookies).end(); ++it)
+//    {
+//       ParseBuffer pb((*it).value());
+//       while(!pb.eof())
+//       {
+//          const char* anchor =  pb.skipWhitespace();
+
+//          pb.skipToChar(Symbols::EQUALS[0]);
+//          pb.data(name, anchor);
+
+//          anchor = pb.skipChar(Symbols::EQUALS[0]);
+//          if(*(pb.position()) == Symbols::DOUBLE_QUOTE[0])
+//          {
+//             anchor = pb.skipChar(Symbols::DOUBLE_QUOTE[0]);
+//             pb.skipToChar(Symbols::DOUBLE_QUOTE[0]);
+//             pb.data(value, anchor);
+//             pb.skipChar(Symbols::DOUBLE_QUOTE[0]);
+//          }
+//          else
+//          {
+//             pb.skipToOneOf(Symbols::SEMI_COLON, ParseBuffer::Whitespace);
+//             pb.data(value, anchor);
+//          }
+
+//          Cookie cookie(name, value);
+//          cookieList.push_back(cookie);
+//          DebugLog(<< "Cookie: " << cookie);
+
+//          if(!pb.eof() && *(pb.position()) == Symbols::SEMI_COLON[0])
+//          {
+//             pb.skipChar(Symbols::SEMI_COLON[0]);
+//          }
+
+//          pb.skipWhitespace();
+//       }
+//    }
+// }
 
 /*
  * Returns true if handshake complete, false if more bytes needed
  * Sets dropConnection = true if an error occurs
  */
-bool
-ConnectionBase::wsProcessHandshake(int bytesRead, bool &dropConnection)
-{
-   mConnState = WebSocket;
-   dropConnection = false;
-
-   if(mBufferPos + bytesRead > messageSizeMax)
-   {
-      WarningLog(<<"Too many bytes received during WS handshake, dropping connection.  Max message size = " << messageSizeMax);
-      dropConnection = true;
-      return false;
-   }
-
-   resip_assert(mTransport);
-   mMessage = new SipMessage(&mTransport->getTuple());
-   resip_assert(mMessage);
-
-   mMessage->setSource(mWho);   
-   mMessage->setTlsDomain(mTransport->tlsDomain());
-
-   if (!scanMsgHeader(bytesRead)) 
-   {
-      return false;
-   }
-
-   try
-   {
-      WsConnectionBase* wsConnectionBase = dynamic_cast<WsConnectionBase*>(this);
-      CookieList cookieList;
-      if(wsConnectionBase)
-      {
-         std::shared_ptr<WsCookieContext> wsCookieContext;
-         if (mMessage->exists(h_Cookies))
-         {
-            WsBaseTransport* wst = dynamic_cast<WsBaseTransport*>(mTransport);
-            resip_assert(wst);
-            try
-            {
-               wsParseCookies(cookieList, mMessage);
-               wsConnectionBase->setCookies(cookieList);
-               // Use of resip WsCookieContext capabilities is not mandatory,
-               // only try to use it if cookieContextFactory is available
-               if(wst->cookieContextFactory().get())
-               {
-                  Uri& requestUri = mMessage->header(h_RequestLine).uri();
-                  wsCookieContext = wst->cookieContextFactory()->makeCookieContext(cookieList, requestUri);
-                  wsConnectionBase->setWsCookieContext(wsCookieContext);
-               }
-            }
-            catch(ParseException& ex)
-            {
-               WarningLog(<<"Failed to parse cookies into WsCookieContext: " << ex);
-            }
-         }
-         std::shared_ptr<WsConnectionValidator> wsConnectionValidator = wsConnectionBase->connectionValidator();
-         if(wsConnectionValidator &&
-            (!wsCookieContext || !wsConnectionValidator->validateConnection(*wsCookieContext)))
-         {
-            ErrLog(<<"WebSocket cookie validation failed, dropping connection");
-            // FIXME: should send back a HTTP error code:
-            //   400 if the cookie was not in the right syntax
-            //   403 if the cookie was well formed but rejected
-            //       due to expiry or a bad HMAC
-            delete mMessage;
-            mMessage = 0;
-            mBufferPos = 0;
-            dropConnection = true;
-            return false;
-         }
-      }
-
-      std::unique_ptr<Data> wsResponsePtr = makeWsHandshakeResponse();
-
-      if (wsResponsePtr.get())
-      {
-         DebugLog (<< "WebSocket upgrade accepted, cookie count = " << cookieList.size());
-
-         mOutstandingSends.push_back(new SendData(
-                  who(),
-                  *wsResponsePtr.get(),
-                  Data::Empty,
-                  Data::Empty,
-                  true));
-      }
-      else
-      {
-         ErrLog(<<"Failed to parse WebSocket initialization request");
-         delete mMessage;
-         mMessage = 0;
-         mBufferPos = 0;
-         dropConnection = true;
-         return false;
-      }
-   }
-   catch(resip::ParseException& e)
-   {
-      ErrLog(<<"Cannot auth request is missing " << e);
-      delete mMessage;
-      mMessage = 0;
-      mBufferPos = 0;
-      dropConnection = true;
-      return false;
-   }
-
-   delete mMessage;
-   mMessage=0;
-   mBufferPos = 0;
-
-   return true;
-}
+// bool
+// ConnectionBase::wsProcessHandshake(int bytesRead, bool &dropConnection)
+// {
+//    mConnState = WebSocket;
+//    dropConnection = false;
+
+//    if(mBufferPos + bytesRead > messageSizeMax)
+//    {
+//       WarningLog(<<"Too many bytes received during WS handshake, dropping connection.  Max message size = " << messageSizeMax);
+//       dropConnection = true;
+//       return false;
+//    }
+
+//    resip_assert(mTransport);
+//    mMessage = new SipMessage(&mTransport->getTuple());
+//    resip_assert(mMessage);
+
+//    mMessage->setSource(mWho);   
+//    mMessage->setTlsDomain(mTransport->tlsDomain());
+
+//    if (!scanMsgHeader(bytesRead)) 
+//    {
+//       return false;
+//    }
+
+//    try
+//    {
+//       WsConnectionBase* wsConnectionBase = dynamic_cast<WsConnectionBase*>(this);
+//       CookieList cookieList;
+//       if(wsConnectionBase)
+//       {
+//          std::shared_ptr<WsCookieContext> wsCookieContext;
+//          if (mMessage->exists(h_Cookies))
+//          {
+//             WsBaseTransport* wst = dynamic_cast<WsBaseTransport*>(mTransport);
+//             resip_assert(wst);
+//             try
+//             {
+//                wsParseCookies(cookieList, mMessage);
+//                wsConnectionBase->setCookies(cookieList);
+//                // Use of resip WsCookieContext capabilities is not mandatory,
+//                // only try to use it if cookieContextFactory is available
+//                if(wst->cookieContextFactory().get())
+//                {
+//                   Uri& requestUri = mMessage->header(h_RequestLine).uri();
+//                   wsCookieContext = wst->cookieContextFactory()->makeCookieContext(cookieList, requestUri);
+//                   wsConnectionBase->setWsCookieContext(wsCookieContext);
+//                }
+//             }
+//             catch(ParseException& ex)
+//             {
+//                WarningLog(<<"Failed to parse cookies into WsCookieContext: " << ex);
+//             }
+//          }
+//          std::shared_ptr<WsConnectionValidator> wsConnectionValidator = wsConnectionBase->connectionValidator();
+//          if(wsConnectionValidator &&
+//             (!wsCookieContext || !wsConnectionValidator->validateConnection(*wsCookieContext)))
+//          {
+//             ErrLog(<<"WebSocket cookie validation failed, dropping connection");
+//             // FIXME: should send back a HTTP error code:
+//             //   400 if the cookie was not in the right syntax
+//             //   403 if the cookie was well formed but rejected
+//             //       due to expiry or a bad HMAC
+//             delete mMessage;
+//             mMessage = 0;
+//             mBufferPos = 0;
+//             dropConnection = true;
+//             return false;
+//          }
+//       }
+
+//       std::unique_ptr<Data> wsResponsePtr = makeWsHandshakeResponse();
+
+//       if (wsResponsePtr.get())
+//       {
+//          DebugLog (<< "WebSocket upgrade accepted, cookie count = " << cookieList.size());
+
+//          mOutstandingSends.push_back(new SendData(
+//                   who(),
+//                   *wsResponsePtr.get(),
+//                   Data::Empty,
+//                   Data::Empty,
+//                   true));
+//       }
+//       else
+//       {
+//          ErrLog(<<"Failed to parse WebSocket initialization request");
+//          delete mMessage;
+//          mMessage = 0;
+//          mBufferPos = 0;
+//          dropConnection = true;
+//          return false;
+//       }
+//    }
+//    catch(resip::ParseException& e)
+//    {
+//       ErrLog(<<"Cannot auth request is missing " << e);
+//       delete mMessage;
+//       mMessage = 0;
+//       mBufferPos = 0;
+//       dropConnection = true;
+//       return false;
+//    }
+
+//    delete mMessage;
+//    mMessage=0;
+//    mBufferPos = 0;
+
+//    return true;
+// }
 
 bool
 ConnectionBase::scanMsgHeader(int bytesRead)
@@ -812,102 +812,102 @@ bool ConnectionBase::isUsingSecWebSocketKey()
    return mMessage->exists(h_SecWebSocketKey);
 }
 
-bool
-ConnectionBase::wsProcessData(int bytesRead)
-{
-   bool dropConnection = false;
-   // Always consumes the whole buffer:
-   std::unique_ptr<Data> msg = mWsFrameExtractor.processBytes((uint8_t*)mBuffer, bytesRead, dropConnection);
-
-   while(msg.get())
-   {
-      // mWsBuffer should now contain a discrete SIP message, let the
-      // stack go to work on it
-
-      if(msg->size() == 4 && memcmp(msg->data(), "\r\n\r\n", 4) == 0)
-      {
-         // sending a keep alive reply now
-         StackLog(<<"got a SIP ping embedded in WebSocket frame, replying");
-         onDoubleCRLF();
-         msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);
-         continue;
-      }
-
-      resip_assert(mTransport);
-      mMessage = new SipMessage(&mTransport->getTuple());
-
-      mMessage->setSource(mWho);
-      mMessage->setTlsDomain(mTransport->tlsDomain());
-
-#ifdef USE_SSL
-      // Set TlsPeerName if message is from TlsConnection
-      TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);
-      if(tlsConnection)
-      {
-         std::list<Data> peerNameList;
-         tlsConnection->getPeerNames(peerNameList);
-         mMessage->setTlsPeerNames(peerNameList);
-      }
-#endif
-
-      WsConnectionBase *wsConnectionBase = dynamic_cast<WsConnectionBase *>(this);
-      if (wsConnectionBase)
-      {
-         mMessage->setWsCookies(wsConnectionBase->getCookies());
-         mMessage->setWsCookieContext(wsConnectionBase->getWsCookieContext());
-      }
-
-      Data::size_type msg_len = msg->size();
-      // cast permitted, as it is borrowed:
-      char *sipBuffer = (char *)msg->data();
-      mMessage->addBuffer(sipBuffer);
-      mMsgHeaderScanner.prepareForMessage(mMessage);
-      char *unprocessedCharPtr;
-      if (mMsgHeaderScanner.scanChunk(sipBuffer,
-                                 (unsigned int)msg_len,
-                                 &unprocessedCharPtr) !=
-                    MsgHeaderScanner::scrEnd)
-      {
-         StackLog(<<"Scanner rejecting WebSocket SIP message as unparsable, length = " << msg_len);
-         StackLog(<< Data(sipBuffer, msg_len));
-         delete mMessage;
-         mMessage=0;
-      }
-
-      unsigned int used = (unsigned int)(unprocessedCharPtr - sipBuffer);
-      if (mMessage && (used < msg_len))
-      {
-         mMessage->setBody(sipBuffer+used, (uint32_t)msg_len-used);
-      }
-
-      if (mMessage && !transport()->basicCheck(*mMessage))
-      {
-         delete mMessage;
-         mMessage = 0;
-      }
-
-      if (mMessage)
-      {
-         Transport::stampReceived(mMessage);
-         resip_assert( mTransport );
-         mTransport->pushRxMsgUp(mMessage);
-         mMessage = 0;
-      }
-      else
-      {
-         // Something wrong...
-         ErrLog(<< "We don't have a valid SIP message, maybe drop the connection?");
-      }
-      msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);
-   }
-
-   if(dropConnection)
-   {
-      return false;
-   }
-
-   return true;
-}
+// bool
+// ConnectionBase::wsProcessData(int bytesRead)
+// {
+//    bool dropConnection = false;
+//    // Always consumes the whole buffer:
+//    std::unique_ptr<Data> msg = mWsFrameExtractor.processBytes((uint8_t*)mBuffer, bytesRead, dropConnection);
+
+//    while(msg.get())
+//    {
+//       // mWsBuffer should now contain a discrete SIP message, let the
+//       // stack go to work on it
+
+//       if(msg->size() == 4 && memcmp(msg->data(), "\r\n\r\n", 4) == 0)
+//       {
+//          // sending a keep alive reply now
+//          StackLog(<<"got a SIP ping embedded in WebSocket frame, replying");
+//          onDoubleCRLF();
+//          msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);
+//          continue;
+//       }
+
+//       resip_assert(mTransport);
+//       mMessage = new SipMessage(&mTransport->getTuple());
+
+//       mMessage->setSource(mWho);
+//       mMessage->setTlsDomain(mTransport->tlsDomain());
+
+// #ifdef USE_SSL
+//       // Set TlsPeerName if message is from TlsConnection
+//       TlsConnection *tlsConnection = dynamic_cast<TlsConnection *>(this);
+//       if(tlsConnection)
+//       {
+//          std::list<Data> peerNameList;
+//          tlsConnection->getPeerNames(peerNameList);
+//          mMessage->setTlsPeerNames(peerNameList);
+//       }
+// #endif
+
+//       WsConnectionBase *wsConnectionBase = dynamic_cast<WsConnectionBase *>(this);
+//       if (wsConnectionBase)
+//       {
+//          mMessage->setWsCookies(wsConnectionBase->getCookies());
+//          mMessage->setWsCookieContext(wsConnectionBase->getWsCookieContext());
+//       }
+
+//       Data::size_type msg_len = msg->size();
+//       // cast permitted, as it is borrowed:
+//       char *sipBuffer = (char *)msg->data();
+//       mMessage->addBuffer(sipBuffer);
+//       mMsgHeaderScanner.prepareForMessage(mMessage);
+//       char *unprocessedCharPtr;
+//       if (mMsgHeaderScanner.scanChunk(sipBuffer,
+//                                  (unsigned int)msg_len,
+//                                  &unprocessedCharPtr) !=
+//                     MsgHeaderScanner::scrEnd)
+//       {
+//          StackLog(<<"Scanner rejecting WebSocket SIP message as unparsable, length = " << msg_len);
+//          StackLog(<< Data(sipBuffer, msg_len));
+//          delete mMessage;
+//          mMessage=0;
+//       }
+
+//       unsigned int used = (unsigned int)(unprocessedCharPtr - sipBuffer);
+//       if (mMessage && (used < msg_len))
+//       {
+//          mMessage->setBody(sipBuffer+used, (uint32_t)msg_len-used);
+//       }
+
+//       if (mMessage && !transport()->basicCheck(*mMessage))
+//       {
+//          delete mMessage;
+//          mMessage = 0;
+//       }
+
+//       if (mMessage)
+//       {
+//          Transport::stampReceived(mMessage);
+//          resip_assert( mTransport );
+//          mTransport->pushRxMsgUp(mMessage);
+//          mMessage = 0;
+//       }
+//       else
+//       {
+//          // Something wrong...
+//          ErrLog(<< "We don't have a valid SIP message, maybe drop the connection?");
+//       }
+//       msg = mWsFrameExtractor.processBytes(0, 0, dropConnection);
+//    }
+
+//    if(dropConnection)
+//    {
+//       return false;
+//    }
+
+//    return true;
+// }
 
 #ifdef USE_SIGCOMP
 void
diff --git a/resip/stack/ConnectionBase.hxx b/resip/stack/ConnectionBase.hxx
old mode 100644
new mode 100755
index a90c89091..7aeccf7ae
--- a/resip/stack/ConnectionBase.hxx
+++ b/resip/stack/ConnectionBase.hxx
@@ -9,7 +9,7 @@
 #include "resip/stack/Transport.hxx"
 #include "resip/stack/MsgHeaderScanner.hxx"
 #include "resip/stack/SendData.hxx"
-#include "resip/stack/WsFrameExtractor.hxx"
+// #include "resip/stack/WsFrameExtractor.hxx"
 #include "resip/stack/Cookie.hxx"
 
 namespace osc
@@ -79,9 +79,9 @@ class ConnectionBase
 
       ConnState getCurrentState() const { return mConnState; }
       bool preparseNewBytes(int bytesRead);
-      bool wsProcessHandshake(int bytesRead, bool &dropConnection);
-      bool wsProcessData(int bytesRead);
-      void wsParseCookies(CookieList& cookieList, const SipMessage* message);
+      // bool wsProcessHandshake(int bytesRead, bool &dropConnection);
+      // bool wsProcessData(int bytesRead);
+      // void wsParseCookies(CookieList& cookieList, const SipMessage* message);
       void decompressNewBytes(int bytesRead);
       std::pair<char*, size_t> getWriteBuffer();
       std::pair<char*, size_t> getCurrentWriteBuffer();
@@ -125,7 +125,7 @@ class ConnectionBase
       char* mBuffer;
       size_t mBufferPos;
       size_t mBufferSize;
-      WsFrameExtractor mWsFrameExtractor;
+      // WsFrameExtractor mWsFrameExtractor;
 
       static char connectionStates[MAX][32];
       uint64_t mLastUsed;
diff --git a/resip/stack/Helper.cxx b/resip/stack/Helper.cxx
old mode 100644
new mode 100755
index f50488563..7cfb0e496
--- a/resip/stack/Helper.cxx
+++ b/resip/stack/Helper.cxx
@@ -26,10 +26,10 @@
 #include "rutil/ParseBuffer.hxx"
 #include "rutil/TransportType.hxx"
 #include "resip/stack/SipMessage.hxx"
-#include "resip/stack/Pkcs7Contents.hxx"
-#include "resip/stack/MultipartSignedContents.hxx"
-#include "resip/stack/MultipartMixedContents.hxx"
-#include "resip/stack/MultipartAlternativeContents.hxx"
+// #include "resip/stack/Pkcs7Contents.hxx"
+// #include "resip/stack/MultipartSignedContents.hxx"
+// #include "resip/stack/MultipartMixedContents.hxx"
+// #include "resip/stack/MultipartAlternativeContents.hxx"
 #include "rutil/WinLeakCheck.hxx"
 
 #ifdef USE_SSL
@@ -1989,109 +1989,109 @@ Helper::ContentsSecAttrs::ContentsSecAttrs(std::unique_ptr<Contents> contents,
 {}
 
 
-Contents*
-extractFromPkcs7Recurse(Contents* tree,
-                        const Data& signerAor,
-                        const Data& receiverAor,
-                        SecurityAttributes* attributes,
-                        Security& security)
-{
-   Pkcs7Contents* pk;
-   if ((pk = dynamic_cast<Pkcs7Contents*>(tree)))
-   {
-      InfoLog( << "GREG1: " << *pk );
-#if defined(USE_SSL)
-      Contents* contents = security.decrypt(receiverAor, pk);
-      if (contents)
-      {
-         attributes->setEncrypted();
-      }
-      return contents;
-#else
-      return 0;
-#endif
-   }
-   MultipartSignedContents* mps;
-   if ((mps = dynamic_cast<MultipartSignedContents*>(tree)))
-   {
-      InfoLog( << "GREG2: " << *mps );
-#if defined(USE_SSL)
-      Data signer;
-      SignatureStatus sigStatus;
-      Contents* b = extractFromPkcs7Recurse(security.checkSignature(mps, 
-                                                                    &signer,
-                                                                    &sigStatus),
-                                            signerAor,
-                                            receiverAor, attributes, security);
-      attributes->setSigner(signer);
-      attributes->setSignatureStatus(sigStatus);
-      return b->clone();
-#else
-      return mps->parts().front()->clone();
-#endif      
-   }
-   MultipartAlternativeContents* alt;
-   if ((alt = dynamic_cast<MultipartAlternativeContents*>(tree)))
-   {
-      InfoLog( << "GREG3: " << *alt );
-      for (MultipartAlternativeContents::Parts::reverse_iterator i = alt->parts().rbegin();
-           i != alt->parts().rend(); ++i)
-      {
-         Contents* b = extractFromPkcs7Recurse(*i, signerAor, receiverAor, attributes, security);
-         if (b)
-         {
-            return b;
-         }
-      }
-   }
-
-   MultipartMixedContents* mult;
-   if ((mult = dynamic_cast<MultipartMixedContents*>(tree)))
-   {
-      InfoLog( << "GREG4: " << *mult );
-      for (MultipartMixedContents::Parts::iterator i = mult->parts().begin();
-           i != mult->parts().end(); ++i)
-      {
-         Contents* b = extractFromPkcs7Recurse(*i, signerAor, receiverAor,
-                                               attributes, security);
-         if (b)
-         {
-            return b;
-         }
-      };
-
-      return 0;
-   }
-
-   return tree->clone();
-}
-
-Helper::ContentsSecAttrs
-Helper::extractFromPkcs7(const SipMessage& message, 
-                         Security& security)
-{
-   SecurityAttributes* attr = new SecurityAttributes;
-   // .dlb. currently flattening SecurityAttributes?
-   //attr->setIdentity(message.getIdentity());
-   attr->setIdentity(message.header(h_From).uri().getAor());
-   Contents *b = message.getContents();
-   if (b) 
-   {
-      Data fromAor(message.header(h_From).uri().getAor());
-      Data toAor(message.header(h_To).uri().getAor());
-      if (message.isRequest())
-      {
-         b = extractFromPkcs7Recurse(b, fromAor, toAor, attr, security);
-      }
-      else // its a response
-      {
-         b = extractFromPkcs7Recurse(b, toAor, fromAor, attr, security);
-      }
-   }
-   std::unique_ptr<Contents> c(b);
-   std::unique_ptr<SecurityAttributes> a(attr);
-   return ContentsSecAttrs(std::move(c), std::move(a));
-}
+// Contents*
+// extractFromPkcs7Recurse(Contents* tree,
+//                         const Data& signerAor,
+//                         const Data& receiverAor,
+//                         SecurityAttributes* attributes,
+//                         Security& security)
+// {
+//    Pkcs7Contents* pk;
+//    if ((pk = dynamic_cast<Pkcs7Contents*>(tree)))
+//    {
+//       InfoLog( << "GREG1: " << *pk );
+// #if defined(USE_SSL)
+//       Contents* contents = security.decrypt(receiverAor, pk);
+//       if (contents)
+//       {
+//          attributes->setEncrypted();
+//       }
+//       return contents;
+// #else
+//       return 0;
+// #endif
+//    }
+//    MultipartSignedContents* mps;
+//    if ((mps = dynamic_cast<MultipartSignedContents*>(tree)))
+//    {
+//       InfoLog( << "GREG2: " << *mps );
+// #if defined(USE_SSL)
+//       Data signer;
+//       SignatureStatus sigStatus;
+//       Contents* b = extractFromPkcs7Recurse(security.checkSignature(mps, 
+//                                                                     &signer,
+//                                                                     &sigStatus),
+//                                             signerAor,
+//                                             receiverAor, attributes, security);
+//       attributes->setSigner(signer);
+//       attributes->setSignatureStatus(sigStatus);
+//       return b->clone();
+// #else
+//       return mps->parts().front()->clone();
+// #endif      
+//    }
+//    MultipartAlternativeContents* alt;
+//    if ((alt = dynamic_cast<MultipartAlternativeContents*>(tree)))
+//    {
+//       InfoLog( << "GREG3: " << *alt );
+//       for (MultipartAlternativeContents::Parts::reverse_iterator i = alt->parts().rbegin();
+//            i != alt->parts().rend(); ++i)
+//       {
+//          Contents* b = extractFromPkcs7Recurse(*i, signerAor, receiverAor, attributes, security);
+//          if (b)
+//          {
+//             return b;
+//          }
+//       }
+//    }
+
+//    MultipartMixedContents* mult;
+//    if ((mult = dynamic_cast<MultipartMixedContents*>(tree)))
+//    {
+//       InfoLog( << "GREG4: " << *mult );
+//       for (MultipartMixedContents::Parts::iterator i = mult->parts().begin();
+//            i != mult->parts().end(); ++i)
+//       {
+//          Contents* b = extractFromPkcs7Recurse(*i, signerAor, receiverAor,
+//                                                attributes, security);
+//          if (b)
+//          {
+//             return b;
+//          }
+//       };
+
+//       return 0;
+//    }
+
+//    return tree->clone();
+// }
+
+// Helper::ContentsSecAttrs
+// Helper::extractFromPkcs7(const SipMessage& message, 
+//                          Security& security)
+// {
+//    SecurityAttributes* attr = new SecurityAttributes;
+//    // .dlb. currently flattening SecurityAttributes?
+//    //attr->setIdentity(message.getIdentity());
+//    attr->setIdentity(message.header(h_From).uri().getAor());
+//    Contents *b = message.getContents();
+//    if (b) 
+//    {
+//       Data fromAor(message.header(h_From).uri().getAor());
+//       Data toAor(message.header(h_To).uri().getAor());
+//       if (message.isRequest())
+//       {
+//          b = extractFromPkcs7Recurse(b, fromAor, toAor, attr, security);
+//       }
+//       else // its a response
+//       {
+//          b = extractFromPkcs7Recurse(b, toAor, fromAor, attr, security);
+//       }
+//    }
+//    std::unique_ptr<Contents> c(b);
+//    std::unique_ptr<SecurityAttributes> a(attr);
+//    return ContentsSecAttrs(std::move(c), std::move(a));
+// }
 
 Helper::FailureMessageEffect 
 Helper::determineFailureMessageEffect(const SipMessage& response,
@@ -2187,81 +2187,81 @@ SdpContents* getSdpRecurse(Contents* tree)
       return static_cast<SdpContents*>(tree);
    }
 
-   MultipartSignedContents* mps;
-   if ((mps = dynamic_cast<MultipartSignedContents*>(tree)))
-   {
-      try
-      {
-         MultipartSignedContents::Parts::const_iterator it = mps->parts().begin();
-         Contents* contents = getSdpRecurse(*it);
-         return static_cast<SdpContents*>(contents);
-      }
-      catch (ParseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());       
-      }
-      catch (BaseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());
-      }
-
-      return 0;
-   }
-
-   MultipartAlternativeContents* alt;
-   if ((alt = dynamic_cast<MultipartAlternativeContents*>(tree)))
-   {
-      try
-      {
-         for (MultipartAlternativeContents::Parts::reverse_iterator i = alt->parts().rbegin();
-              i != alt->parts().rend(); ++i)
-         {
-            Contents* contents = getSdpRecurse(*i);
-            if (contents)
-            {
-               return static_cast<SdpContents*>(contents);
-            }
-         }
-      }
-      catch (ParseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());
-      }
-      catch (BaseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());
-      }
-
-      return 0;
-   }
-
-   MultipartMixedContents* mult;
-   if ((mult = dynamic_cast<MultipartMixedContents*>(tree)))
-   {
-
-      try
-      {
-         for (MultipartMixedContents::Parts::iterator i = mult->parts().begin();
-              i != mult->parts().end(); ++i)
-         {
-            Contents* contents = getSdpRecurse(*i);
-            if (contents)
-            {
-               return static_cast<SdpContents*>(contents);
-            }
-         }
-      }
-      catch (ParseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());
-      }
-      catch (BaseException& e)
-      {
-         ErrLog(<< e.name() << endl << e.getMessage());
-      }
-
-      return 0;
-   }
+   // MultipartSignedContents* mps;
+   // if ((mps = dynamic_cast<MultipartSignedContents*>(tree)))
+   // {
+   //    try
+   //    {
+   //       MultipartSignedContents::Parts::const_iterator it = mps->parts().begin();
+   //       Contents* contents = getSdpRecurse(*it);
+   //       return static_cast<SdpContents*>(contents);
+   //    }
+   //    catch (ParseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());       
+   //    }
+   //    catch (BaseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());
+   //    }
+
+   //    return 0;
+   // }
+
+   // MultipartAlternativeContents* alt;
+   // if ((alt = dynamic_cast<MultipartAlternativeContents*>(tree)))
+   // {
+   //    try
+   //    {
+   //       for (MultipartAlternativeContents::Parts::reverse_iterator i = alt->parts().rbegin();
+   //            i != alt->parts().rend(); ++i)
+   //       {
+   //          Contents* contents = getSdpRecurse(*i);
+   //          if (contents)
+   //          {
+   //             return static_cast<SdpContents*>(contents);
+   //          }
+   //       }
+   //    }
+   //    catch (ParseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());
+   //    }
+   //    catch (BaseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());
+   //    }
+
+   //    return 0;
+   // }
+
+   // MultipartMixedContents* mult;
+   // if ((mult = dynamic_cast<MultipartMixedContents*>(tree)))
+   // {
+
+   //    try
+   //    {
+   //       for (MultipartMixedContents::Parts::iterator i = mult->parts().begin();
+   //            i != mult->parts().end(); ++i)
+   //       {
+   //          Contents* contents = getSdpRecurse(*i);
+   //          if (contents)
+   //          {
+   //             return static_cast<SdpContents*>(contents);
+   //          }
+   //       }
+   //    }
+   //    catch (ParseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());
+   //    }
+   //    catch (BaseException& e)
+   //    {
+   //       ErrLog(<< e.name() << endl << e.getMessage());
+   //    }
+
+   //    return 0;
+   // }
 
    return 0;
 }
diff --git a/resip/stack/Helper.hxx b/resip/stack/Helper.hxx
old mode 100644
new mode 100755
index 0593c46d7..ca88c8bff
--- a/resip/stack/Helper.hxx
+++ b/resip/stack/Helper.hxx
@@ -539,7 +539,7 @@ class Helper
             mutable std::unique_ptr<SecurityAttributes> mAttributes;
       };
 
-      static ContentsSecAttrs extractFromPkcs7(const SipMessage& message, Security& security);
+      // static ContentsSecAttrs extractFromPkcs7(const SipMessage& message, Security& security);
 
       
       enum FailureMessageEffect{ DialogTermination, TransactionTermination, UsageTermination, 
diff --git a/resip/stack/SdpContents.cxx b/resip/stack/SdpContents.cxx
old mode 100644
new mode 100755
index 37f75d8a0..282f7f9bc
--- a/resip/stack/SdpContents.cxx
+++ b/resip/stack/SdpContents.cxx
@@ -5,7 +5,7 @@
 #include <algorithm>
 
 #include "resip/stack/SdpContents.hxx"
-#include "resip/stack/TrickleIceContents.hxx"
+// #include "resip/stack/TrickleIceContents.hxx"
 #include "resip/stack/Helper.hxx"
 #include "rutil/ParseBuffer.hxx"
 #include "rutil/DataStream.hxx"
@@ -1492,23 +1492,23 @@ SdpContents::Session::getMediumByMid(const Data& mid) const
    return nullptr;
 }
 
-std::shared_ptr<TrickleIceContents>
-SdpContents::Session::makeIceFragment(const Data& fragment,
-               unsigned int lineIndex, const Data& mid)
-{
-   std::shared_ptr<TrickleIceContents> ret;
-   const Medium* m = getMediumByMid(mid);
-   if(m && m->exists("ice-ufrag") && m->exists("ice-pwd"))
-   {
-      ret = std::make_shared<TrickleIceContents>();
-      ret->addAttribute(Data("ice-ufrag"), m->getValues("ice-ufrag").front());
-      ret->addAttribute(Data("ice-pwd"), m->getValues("ice-pwd").front());
-      Medium _m(m->name(), m->port(), m->multicast(), m->protocol());
-      _m.addAttribute("candidate", fragment.substr((Data::size_type)strlen("candidate:")));
-      ret->addMedium(_m);
-   }
-   return ret;
-}
+// std::shared_ptr<TrickleIceContents>
+// SdpContents::Session::makeIceFragment(const Data& fragment,
+//                unsigned int lineIndex, const Data& mid)
+// {
+//    std::shared_ptr<TrickleIceContents> ret;
+//    const Medium* m = getMediumByMid(mid);
+//    if(m && m->exists("ice-ufrag") && m->exists("ice-pwd"))
+//    {
+//       ret = std::make_shared<TrickleIceContents>();
+//       ret->addAttribute(Data("ice-ufrag"), m->getValues("ice-ufrag").front());
+//       ret->addAttribute(Data("ice-pwd"), m->getValues("ice-pwd").front());
+//       Medium _m(m->name(), m->port(), m->multicast(), m->protocol());
+//       _m.addAttribute("candidate", fragment.substr((Data::size_type)strlen("candidate:")));
+//       ret->addMedium(_m);
+//    }
+//    return ret;
+// }
 
 SdpContents::Session::Medium::Medium(const Data& name,
                                      unsigned long port,
@@ -1526,7 +1526,8 @@ SdpContents::Session::Medium::Medium()
    : mSession(0),
      mPort(0),
      mMulticast(1),
-     mRtpMapDone(false)
+     mRtpMapDone(false),
+     mSSRC(0)
 {}
 
 SdpContents::Session::Medium::Medium(const Medium& rhs)
@@ -1544,7 +1545,8 @@ SdpContents::Session::Medium::Medium(const Medium& rhs)
      mEncryption(rhs.mEncryption),
      mAttributeHelper(rhs.mAttributeHelper),
      mRtpMapDone(rhs.mRtpMapDone),
-     mRtpMap(rhs.mRtpMap)
+     mRtpMap(rhs.mRtpMap),
+     mSSRC(rhs.mSSRC)
 {
 }
 
@@ -1706,6 +1708,14 @@ SdpContents::Session::Medium::parse(ParseBuffer& pb)
    }
 
    mAttributeHelper.parse(pb);
+
+   if (!pb.eof() && *pb.position() == 'y')
+   {
+      pb.skipChar('y');
+      pb.skipChar(Symbols::EQUALS[0]);
+      mSSRC = pb.uInt32();
+      skipEol(pb);
+   }
 }
 
 EncodeStream&
@@ -1788,6 +1798,10 @@ SdpContents::Session::Medium::encode(EncodeStream& s) const
 
    mAttributeHelper.encode(s);
 
+   char y[16] = {0};
+   snprintf(y, sizeof(y), "%010u", mSSRC);
+   s << "y=" << y << Symbols::CRLF;
+
    return s;
 }
 
diff --git a/resip/stack/SdpContents.hxx b/resip/stack/SdpContents.hxx
old mode 100644
new mode 100755
index acf793f5a..dbe53f104
--- a/resip/stack/SdpContents.hxx
+++ b/resip/stack/SdpContents.hxx
@@ -843,6 +843,9 @@ class SdpContents : public Contents
                   const Direction& getDirection() const;
                   const Direction& getDirection(const Direction& sessionDefault) const;
 
+                  uint32_t ssrc() const {return mSSRC;}
+                  uint32_t& ssrc() { return mSSRC;}
+
                private:
                   void setSession(Session* session);
                   Session* mSession;
@@ -864,6 +867,8 @@ class SdpContents : public Contents
                   typedef HashMap<int, Codec> RtpMap;
                   RtpMap mRtpMap;
 
+                  uint32_t mSSRC;
+
                   friend class Session;
             };
 
@@ -1117,8 +1122,8 @@ class SdpContents : public Contents
              *  @param fragment the candidate line to include
               * @return a new TrickleIceContents
               */
-            std::shared_ptr<TrickleIceContents> makeIceFragment(const Data& fragment,
-               unsigned int lineIndex, const Data& mid);
+            // std::shared_ptr<TrickleIceContents> makeIceFragment(const Data& fragment,
+            //    unsigned int lineIndex, const Data& mid);
 
          private:
             int mVersion;
diff --git a/resip/stack/SipStack.cxx b/resip/stack/SipStack.cxx
old mode 100644
new mode 100755
index 6bc6abc13..732ea2fb2
--- a/resip/stack/SipStack.cxx
+++ b/resip/stack/SipStack.cxx
@@ -465,15 +465,15 @@ SipStack::addTransport( TransportType protocol,
             break;
 
          case WS:
-            transport = new WsTransport(stateMacFifo, 
-                  port,
-                  version,
-                  ipInterface,
-                  mSocketFunc,
-                  *mCompression,
-                  transportFlags,
-                  wsConnectionValidator,
-                  wsCookieContextFactory);
+            // transport = new WsTransport(stateMacFifo, 
+            //       port,
+            //       version,
+            //       ipInterface,
+            //       mSocketFunc,
+            //       *mCompression,
+            //       transportFlags,
+            //       wsConnectionValidator,
+            //       wsCookieContextFactory);
             break;
 
          case WSS:
diff --git a/resip/stack/TransactionState.cxx b/resip/stack/TransactionState.cxx
old mode 100644
new mode 100755
index 8120dff29..9098116eb
--- a/resip/stack/TransactionState.cxx
+++ b/resip/stack/TransactionState.cxx
@@ -434,14 +434,14 @@ TransactionState::process(TransactionController& controller,
                            TransactionMessage* message)
 { 
    // Note:  KeepAliveMessage is a special SipMessage - check for it first
-   KeepAliveMessage* keepAlive = dynamic_cast<KeepAliveMessage*>(message);
-   if (keepAlive)
-   {
-      StackLog ( << "Sending keep alive to: " << keepAlive->getDestination());      
-      controller.mTransportSelector.transmit(keepAlive, keepAlive->getDestination());
-      delete keepAlive;
-      return;
-   }
+   // KeepAliveMessage* keepAlive = dynamic_cast<KeepAliveMessage*>(message);
+   // if (keepAlive)
+   // {
+   //    StackLog ( << "Sending keep alive to: " << keepAlive->getDestination());      
+   //    controller.mTransportSelector.transmit(keepAlive, keepAlive->getDestination());
+   //    delete keepAlive;
+   //    return;
+   // }
 
    SipMessage* sip = dynamic_cast<SipMessage*>(message);
    if(!sip)
diff --git a/resip/stack/TransportSelector.cxx b/resip/stack/TransportSelector.cxx
old mode 100644
new mode 100755
index 56f83e49e..c368d0a18
--- a/resip/stack/TransportSelector.cxx
+++ b/resip/stack/TransportSelector.cxx
@@ -238,7 +238,7 @@ TransportSelector::addTransport(std::unique_ptr<Transport> autoTransport, bool i
 #endif
    else if(transport->transport()==WS)
    {
-      resip_assert(dynamic_cast<WsTransport*>(transport));
+      // resip_assert(dynamic_cast<WsTransport*>(transport));
    }
 #ifdef USE_SSL
    else if(transport->transport()==WSS)
diff --git a/rutil/CMakeLists.txt b/rutil/CMakeLists.txt
old mode 100644
new mode 100755
index 7ed566263..da74fd473
--- a/rutil/CMakeLists.txt
+++ b/rutil/CMakeLists.txt
@@ -262,7 +262,7 @@ set_target_properties(rutil PROPERTIES FOLDER rutil)
 version_libname(rutil)
 
 install(TARGETS rutil DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/rutil ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/rutil ${INCLUDES})
 
 if(NOT WITH_C_ARES)
    add_subdirectory(dns/ares)
diff --git a/rutil/dns/ares/CMakeLists.txt b/rutil/dns/ares/CMakeLists.txt
old mode 100644
new mode 100755
index 021b8cf28..8cb0002c1
--- a/rutil/dns/ares/CMakeLists.txt
+++ b/rutil/dns/ares/CMakeLists.txt
@@ -57,7 +57,7 @@ version_libname(resipares)
 set_target_properties(resipares PROPERTIES FOLDER rutil/ares)
 
 install(TARGETS resipares DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install(FILES ${INCLUDES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/rutil/dns/ares)
+#install(FILES ${INCLUDES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/rutil/dns/ares)
 
 add_executable(ahost EXCLUDE_FROM_ALL ahost.c)
 add_executable(adig EXCLUDE_FROM_ALL adig.c)
