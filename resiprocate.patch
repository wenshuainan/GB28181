diff --git a/CMakeLists.txt b/CMakeLists.txt
old mode 100644
new mode 100755
index 4e55b5c3e..2bae4ffda
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 3.21 FATAL_ERROR)
+cmake_minimum_required(VERSION 3.10 FATAL_ERROR)
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/build/cmake_modules")
 
 # For Visual Studio Solution Generation
@@ -48,8 +48,8 @@ add_definitions(-DHAVE_VERSION_H)
 configure_file(${CMAKE_CURRENT_SOURCE_DIR}/version.h.cmake
                ${CMAKE_CURRENT_BINARY_DIR}/version.h)
 include_directories(${CMAKE_CURRENT_BINARY_DIR})
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/version.h
-        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/resip/)
+#install(FILES ${CMAKE_CURRENT_BINARY_DIR}/version.h
+#        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/resip/)
 
 option(ENABLE_LOG_REPOSITORY_DETAILS "Log repository revision and branch" TRUE)
 if(ENABLE_LOG_REPOSITORY_DETAILS)
@@ -100,14 +100,14 @@ endif()
 # Top-level user-settable variables (with defaults)
 # Those can be queried from the command line using "cmake -LH" and can be
 # specified on the command line, using cmake-gui or ccmake.
-option(WITH_SSL "Link against SSL libraries" TRUE)
-option(USE_POPT "Link against POPT libraries" TRUE)
+option(WITH_SSL "Link against SSL libraries" FALSE)
+option(USE_POPT "Link against POPT libraries" FALSE)
 option(USE_SIGCOMP "Use OpenSigComp" FALSE)
 option(USE_FMT "Link against fmt library" FALSE)
-option(VERSIONED_SONAME "Include Major.Minor version in SONAME" TRUE)
+option(VERSIONED_SONAME "Include Major.Minor version in SONAME" FALSE)
 option(ENABLE_ANDROID "Enable Android build" FALSE)
-option(USE_IPV6 "Enable IPv6" TRUE)
-option(USE_DTLS "Enable DTLS" TRUE)
+option(USE_IPV6 "Enable IPv6" FALSE)
+option(USE_DTLS "Enable DTLS" FALSE)
 option(PEDANTIC_STACK "Enable pedantic behavior (fully parse all messages)" FALSE)
 option(USE_MYSQL "Link against MySQL client libraries" FALSE)
 # some systems may have a newer version of libpq that is not
@@ -117,18 +117,18 @@ option(USE_SOCI_POSTGRESQL "Build recon with SOCI PostgreSQL support" FALSE)
 # time in some environments, e.g. CentOS 8.1
 option(USE_SOCI_MYSQL "Build recon with SOCI MySQL support" FALSE)
 option(USE_POSTGRESQL "Link against PostgreSQL client libraries" FALSE)
-option(USE_MAXMIND_GEOIP "Link against MaxMind GeoIP libraries" TRUE)
+option(USE_MAXMIND_GEOIP "Link against MaxMind GeoIP libraries" FALSE)
 option(RESIP_HAVE_RADCLI "Link against radcli RADIUS client library" FALSE)
 option(USE_NETSNMP "Link against NetSNMP client libraries" FALSE)
-option(BUILD_REPRO "Build repro SIP proxy" TRUE)
-option(BUILD_RETURN "Build reTurn server" TRUE)
-option(BUILD_REFLOW "Build reflow library" TRUE)
-option(BUILD_REND "Build rend" TRUE)
-option(BUILD_TFM "Build TFM, requires Netxx and cppunit" TRUE)
+option(BUILD_REPRO "Build repro SIP proxy" FALSE)
+option(BUILD_RETURN "Build reTurn server" FALSE)
+option(BUILD_REFLOW "Build reflow library" FALSE)
+option(BUILD_REND "Build rend" FALSE)
+option(BUILD_TFM "Build TFM, requires Netxx and cppunit" FALSE)
 option(BUILD_CLICKTOCALL "Build Click to call application" FALSE)
 option(BUILD_ICHAT_GW "Build iChat gateway, requires gloox" FALSE)
 option(BUILD_TELEPATHY_CM "Build Telepathy connection manager" FALSE)
-option(BUILD_RECON "Build reCon Conversation Manager library" TRUE)
+option(BUILD_RECON "Build reCon Conversation Manager library" FALSE)
 option(USE_SRTP1 "Use srtp 1.x instead of current version" FALSE)
 option(BUILD_RECONSERVER "Build reConServer" FALSE)
 option(USE_SIPXTAPI "Link against sipXtapi" FALSE)
@@ -139,7 +139,7 @@ option(USE_LIBWEBRTC "Link against LibWebRTC" FALSE)
 option(RECON_LOCAL_HW_TESTS "Attempt to use local audio hardware in unit tests" FALSE)
 option(BUILD_P2P "Build P2P, links against S2C and SSL, unfinished" FALSE)
 option(BUILD_PYTHON "Build components requiring Python" FALSE)
-option(BUILD_TESTING "Build manual & unit tests" TRUE)
+option(BUILD_TESTING "Build manual & unit tests" FALSE)
 
 # Enable/disable linux based settings appropriately
 if(WIN32)
@@ -149,11 +149,11 @@ if(WIN32)
    set(REGENERATE_MEDIA_SAMPLES_DEFAULT OFF)
    set(BUILD_DSO_PLUGINS_DEFAULT OFF)
 else()
-   set(WITH_C_ARES_DEFAULT ON)  # Needed for TFM to build correctly on linux
-   set(BUILD_QPID_PROTON_DEFAULT ON)
-   set(RESIP_ASSERT_SYSLOG_DEFAULT ON)
-   set(REGENERATE_MEDIA_SAMPLES_DEFAULT ON)
-   set(BUILD_DSO_PLUGINS_DEFAULT ON)
+   set(WITH_C_ARES_DEFAULT OFF)  # Needed for TFM to build correctly on linux
+   set(BUILD_QPID_PROTON_DEFAULT OFF)
+   set(RESIP_ASSERT_SYSLOG_DEFAULT OFF)
+   set(REGENERATE_MEDIA_SAMPLES_DEFAULT OFF)
+   set(BUILD_DSO_PLUGINS_DEFAULT OFF)
 endif()
 option(WITH_C_ARES "Link against libc-ares (rather than rutil/dns/ares)" ${WITH_C_ARES_DEFAULT})
 option(BUILD_QPID_PROTON "Build components requiring qpid-proton (AMQP)" ${BUILD_QPID_PROTON_DEFAULT})
@@ -201,7 +201,7 @@ if(WIN32)
    set(USE_CONTRIB_DEFAULT ON)
    set(USE_NUGET_DEFAULT ON)
 else()
-   set(BUILD_SHARED_LIBS_DEFAULT ON)
+   set(BUILD_SHARED_LIBS_DEFAULT OFF)
    set(USE_CONTRIB_DEFAULT OFF)
    set(USE_NUGET_DEFAULT OFF)
 endif()
diff --git a/resip/dum/AppDialog.cxx b/resip/dum/AppDialog.cxx
old mode 100644
new mode 100755
index 279949297..7ad479bda
--- a/resip/dum/AppDialog.cxx
+++ b/resip/dum/AppDialog.cxx
@@ -20,17 +20,17 @@ AppDialog::getHandle()
    return AppDialogHandle(mHam, mId);
 }
 
-vector<ClientSubscriptionHandle> 
-AppDialog::getClientSubscriptions()
-{
-   return mDialog->getClientSubscriptions();
-}
+// vector<ClientSubscriptionHandle> 
+// AppDialog::getClientSubscriptions()
+// {
+//    return mDialog->getClientSubscriptions();
+// }
 
-vector<ClientSubscriptionHandle> 
-AppDialog::findClientSubscriptions(const Data& event)
-{
-   return mDialog->findClientSubscriptions(event);
-}
+// vector<ClientSubscriptionHandle> 
+// AppDialog::findClientSubscriptions(const Data& event)
+// {
+//    return mDialog->findClientSubscriptions(event);
+// }
 
 vector<ServerSubscriptionHandle> 
 AppDialog::getServerSubscriptions()
diff --git a/resip/dum/AppDialog.hxx b/resip/dum/AppDialog.hxx
old mode 100644
new mode 100755
index 934bef438..e81f8fadf
--- a/resip/dum/AppDialog.hxx
+++ b/resip/dum/AppDialog.hxx
@@ -27,8 +27,8 @@ class AppDialog : public Handled
 
       //?dcm? -- further evidence that this should possbily be a dialog
       //subclass(cancel gets tricky). List vs vector?(here and in Dialog)
-      std::vector<ClientSubscriptionHandle> getClientSubscriptions();
-      std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
+      // std::vector<ClientSubscriptionHandle> getClientSubscriptions();
+      // std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
 
       std::vector<ServerSubscriptionHandle> getServerSubscriptions();
       std::vector<ServerSubscriptionHandle> findServerSubscriptions(const Data& event);
diff --git a/resip/dum/CMakeLists.txt b/resip/dum/CMakeLists.txt
old mode 100644
new mode 100755
index c4d5e3ff9..11db5a54f
--- a/resip/dum/CMakeLists.txt
+++ b/resip/dum/CMakeLists.txt
@@ -9,15 +9,15 @@ set(INCLUDES
    ChallengeInfo.hxx
    ClientAuthExtension.hxx
    ClientAuthManager.hxx
-   ClientInviteSession.hxx
-   ClientOutOfDialogReq.hxx
+   #ClientInviteSession.hxx
+   #ClientOutOfDialogReq.hxx
    ClientPagerMessage.hxx
-   ClientPublication.hxx
+   #ClientPublication.hxx
    ClientRegistration.hxx
    ClientSubscriptionFunctor.hxx
-   ClientSubscription.hxx
+   #ClientSubscription.hxx
    ContactInstanceRecord.hxx
-   DefaultServerReferHandler.hxx
+   #DefaultServerReferHandler.hxx
    DestroyUsage.hxx
    DialogEventHandler.hxx
    DialogEventInfo.hxx
@@ -57,7 +57,7 @@ set(INCLUDES
    InMemorySyncPubDb.hxx
    InMemorySyncRegDb.hxx
    InviteDialogs.hxx
-   InviteSessionCreator.hxx
+   #InviteSessionCreator.hxx
    InviteSessionHandler.hxx
    InviteSession.hxx
    KeepAliveManager.hxx
@@ -68,13 +68,13 @@ set(INCLUDES
    NetworkAssociation.hxx
    NonDialogUsage.hxx
    OutgoingEvent.hxx
-   OutOfDialogHandler.hxx
-   OutOfDialogReqCreator.hxx
+   #OutOfDialogHandler.hxx
+   #OutOfDialogReqCreator.hxx
    PagerMessageCreator.hxx
    PagerMessageHandler.hxx
    Postable.hxx
    Profile.hxx
-   PublicationCreator.hxx
+   #PublicationCreator.hxx
    PublicationHandler.hxx
    PublicationPersistenceManager.hxx
    RADIUSServerAuthManager.hxx
@@ -86,16 +86,16 @@ set(INCLUDES
    RegistrationPersistenceManager.hxx
    RemoteCertStore.hxx
    RequestValidationHandler.hxx
-   ServerAuthManager.hxx
+   #ServerAuthManager.hxx
    ServerInviteSession.hxx
-   ServerOutOfDialogReq.hxx
+   #ServerOutOfDialogReq.hxx
    ServerPagerMessage.hxx
-   ServerPublication.hxx
-   ServerRegistration.hxx
+   #ServerPublication.hxx
+   #ServerRegistration.hxx
    ServerSubscriptionFunctor.hxx
    ServerSubscription.hxx
    ssl/EncryptionManager.hxx
-   SubscriptionCreator.hxx
+   #SubscriptionCreator.hxx
    SubscriptionHandler.hxx
    SubscriptionPersistenceManager.hxx
    SubscriptionState.hxx
@@ -119,14 +119,14 @@ add_library(dum
    ChallengeInfo.cxx
    ClientAuthExtension.cxx
    ClientAuthManager.cxx
-   ClientInviteSession.cxx
-   ClientOutOfDialogReq.cxx
+   #ClientInviteSession.cxx
+   #ClientOutOfDialogReq.cxx
    ClientPagerMessage.cxx
-   ClientPublication.cxx
+   #ClientPublication.cxx
    ClientRegistration.cxx
-   ClientSubscription.cxx
+   #ClientSubscription.cxx
    ContactInstanceRecord.cxx
-   DefaultServerReferHandler.cxx
+   #DefaultServerReferHandler.cxx
    DestroyUsage.cxx
    Dialog.cxx
    DialogEventInfo.cxx
@@ -156,7 +156,7 @@ add_library(dum
    InMemorySyncPubDb.cxx
    InMemorySyncRegDb.cxx
    InviteSession.cxx
-   InviteSessionCreator.cxx
+   #InviteSessionCreator.cxx
    InviteSessionHandler.cxx
    KeepAliveManager.cxx
    KeepAliveTimeout.cxx
@@ -165,23 +165,23 @@ add_library(dum
    MergedRequestRemovalCommand.cxx
    NetworkAssociation.cxx
    NonDialogUsage.cxx
-   OutOfDialogReqCreator.cxx
+   #OutOfDialogReqCreator.cxx
    OutgoingEvent.cxx
    PagerMessageCreator.cxx
    Profile.cxx
-   PublicationCreator.cxx
+   #PublicationCreator.cxx
    RADIUSServerAuthManager.cxx
    RedirectManager.cxx
    RegistrationCreator.cxx
    RegistrationHandler.cxx
-   ServerAuthManager.cxx
+   #ServerAuthManager.cxx
    ServerInviteSession.cxx
-   ServerOutOfDialogReq.cxx
+   #ServerOutOfDialogReq.cxx
    ServerPagerMessage.cxx
-   ServerPublication.cxx
-   ServerRegistration.cxx
+   #ServerPublication.cxx
+   #ServerRegistration.cxx
    ServerSubscription.cxx
-   SubscriptionCreator.cxx
+   #SubscriptionCreator.cxx
    SubscriptionHandler.cxx
    SubscriptionState.cxx
    TargetCommand.cxx
@@ -204,7 +204,7 @@ version_libname(dum)
 set_target_properties(dum PROPERTIES FOLDER dum)
 
 install(TARGETS dum DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/dum ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/dum ${INCLUDES})
 
 if(BUILD_TESTING)
     add_subdirectory(test)
diff --git a/resip/dum/Dialog.cxx b/resip/dum/Dialog.cxx
old mode 100644
new mode 100755
index 60dd869ca..ecd58c1d8
--- a/resip/dum/Dialog.cxx
+++ b/resip/dum/Dialog.cxx
@@ -30,7 +30,7 @@ Dialog::Dialog(DialogUsageManager& dum, const SipMessage& msg, DialogSet& ds)
    : mDum(dum),
      mDialogSet(ds),
      mId("INVALID", "INVALID", "INVALID"),
-     mClientSubscriptions(),
+   //   mClientSubscriptions(),
      mServerSubscriptions(),
      mInviteSession(0),
      mType(Fake),
@@ -281,10 +281,10 @@ Dialog::~Dialog()
 
    mDestroying = true;
 
-   while (!mClientSubscriptions.empty())
-   {
-      delete *mClientSubscriptions.begin();
-   }
+   // while (!mClientSubscriptions.empty())
+   // {
+   //    delete *mClientSubscriptions.begin();
+   // }
 
    while (!mServerSubscriptions.empty())
    {
@@ -345,11 +345,11 @@ Dialog::getRouteSet() const noexcept
 void
 Dialog::cancel()
 {
-   ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
-   if (uac)
-   {
-      uac->cancel();
-   }
+   // ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
+   // if (uac)
+   // {
+   //    uac->cancel();
+   // }
 }
 
 void
@@ -376,13 +376,13 @@ Dialog::end(const Data& endReason, const ParserContainer<Token>& endReasons)
    // End Subscriptions
    // !jrm! WARN ClientSubscription and ServerSubscription have access to this dialog and will remove themselves
    // from the m<client|server>Subscriptions collections in the call to end().
-   for (list<ClientSubscription*>::iterator it(mClientSubscriptions.begin());
-        it != mClientSubscriptions.end();)
-   {
-	   ClientSubscription* c = *it;
-       it++;       
-	   c->end();
-   }
+   // for (list<ClientSubscription*>::iterator it(mClientSubscriptions.begin());
+   //      it != mClientSubscriptions.end();)
+   // {
+	//    ClientSubscription* c = *it;
+   //     it++;       
+	//    c->end();
+   // }
 
    for (list<ServerSubscription*>::iterator it2(mServerSubscriptions.begin());
         it2 != mServerSubscriptions.end();)
@@ -645,44 +645,44 @@ Dialog::dispatch(const SipMessage& msg)
          }
          break;
          case NOTIFY:
-            {
-               ClientSubscription* client = findMatchingClientSub(request);
-               if (client)
-               {
-                  client->dispatch(request);
-               }
-               else
-               {
-                  BaseCreator* creator = mDialogSet.getCreator();
-                  if (creator && (creator->getLastRequest()->header(h_RequestLine).method() == SUBSCRIBE ||
-                     creator->getLastRequest()->header(h_RequestLine).method() == REFER))  
-                  {
-                     DebugLog (<< "Making subscription (from creator) request: " << *creator->getLastRequest());
-                     ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
-                     mClientSubscriptions.push_back(sub);
-                     sub->dispatch(request);
-                  }
-                  else
-                  {
-                     if (mInviteSession != 0 && (!msg.exists(h_Event) || msg.header(h_Event).value() == "refer") && 
-                         mDum.getClientSubscriptionHandler("refer")!=0) 
-                     {
-                        DebugLog (<< "Making subscription from NOTIFY: " << msg);
-                        ClientSubscription* sub = makeClientSubscription(msg);
-                        mClientSubscriptions.push_back(sub);
-                        ClientSubscriptionHandle client = sub->getHandle();
-                        mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), client, msg);				      
-                        sub->dispatch(request);
-                     }
-                     else
-                     {
-                        auto response = std::make_shared<SipMessage>();
-                        makeResponse(*response, msg, 406);
-                        send(response);
-                     }
-                  }
-               }
-            }
+            // {
+            //    ClientSubscription* client = findMatchingClientSub(request);
+            //    if (client)
+            //    {
+            //       client->dispatch(request);
+            //    }
+            //    else
+            //    {
+            //       BaseCreator* creator = mDialogSet.getCreator();
+            //       if (creator && (creator->getLastRequest()->header(h_RequestLine).method() == SUBSCRIBE ||
+            //          creator->getLastRequest()->header(h_RequestLine).method() == REFER))  
+            //       {
+            //          DebugLog (<< "Making subscription (from creator) request: " << *creator->getLastRequest());
+            //          ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
+            //          mClientSubscriptions.push_back(sub);
+            //          sub->dispatch(request);
+            //       }
+            //       else
+            //       {
+            //          if (mInviteSession != 0 && (!msg.exists(h_Event) || msg.header(h_Event).value() == "refer") && 
+            //              mDum.getClientSubscriptionHandler("refer")!=0) 
+            //          {
+            //             DebugLog (<< "Making subscription from NOTIFY: " << msg);
+            //             ClientSubscription* sub = makeClientSubscription(msg);
+            //             mClientSubscriptions.push_back(sub);
+            //             ClientSubscriptionHandle client = sub->getHandle();
+            //             mDum.mInviteSessionHandler->onReferAccepted(mInviteSession->getSessionHandle(), client, msg);				      
+            //             sub->dispatch(request);
+            //          }
+            //          else
+            //          {
+            //             auto response = std::make_shared<SipMessage>();
+            //             makeResponse(*response, msg, 406);
+            //             send(response);
+            //          }
+            //       }
+            //    }
+            // }
             break;
         default:
            resip_assert(0);
@@ -751,24 +751,24 @@ Dialog::dispatch(const SipMessage& msg)
       switch (response.header(h_CSeq).method())
       {
          case INVITE:
-            if (mInviteSession == 0)
-            {
-               DebugLog ( << "Dialog::dispatch  --  Created new client invite session" << msg.brief());
-
-               mInviteSession = makeClientInviteSession(response);
-               if (mInviteSession)
-               {
-                  mInviteSession->dispatch(response);
-               }
-               else
-               {
-                  ErrLog( << "Dialog::dispatch  --  Unable to create invite session from response" << msg.brief());
-               }
-            }
-            else
-            {
-               mInviteSession->dispatch(response);
-            }
+            // if (mInviteSession == 0)
+            // {
+            //    DebugLog ( << "Dialog::dispatch  --  Created new client invite session" << msg.brief());
+
+            //    mInviteSession = makeClientInviteSession(response);
+            //    if (mInviteSession)
+            //    {
+            //       mInviteSession->dispatch(response);
+            //    }
+            //    else
+            //    {
+            //       ErrLog( << "Dialog::dispatch  --  Unable to create invite session from response" << msg.brief());
+            //    }
+            // }
+            // else
+            // {
+            //    mInviteSession->dispatch(response);
+            // }
             break;
          case BYE:
          case ACK:
@@ -810,32 +810,32 @@ Dialog::dispatch(const SipMessage& msg)
 
          case SUBSCRIBE:
          {
-            ClientSubscription* client = findMatchingClientSub(response);
-            if (client)
-            {
-               client->dispatch(response);
-            }
-            else
-            {
-               //!dcm! -- can't subscribe in an existing Dialog, this is all
-               //a bit of a hack; currently, spurious failure messages may cause callbacks
-               BaseCreator* creator = mDialogSet.getCreator();
-               if (!creator || !creator->getLastRequest()->exists(h_Event))
-               {
-                  return;
-               }
-               else
-               {
-                  ClientSubscriptionHandler* handler =
-                     mDum.getClientSubscriptionHandler(creator->getLastRequest()->header(h_Event).value());
-                  if (handler)
-                  {
-                     ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
-                     mClientSubscriptions.push_back(sub);
-                     sub->dispatch(response);
-                  }
-               }
-            }
+            // ClientSubscription* client = findMatchingClientSub(response);
+            // if (client)
+            // {
+            //    client->dispatch(response);
+            // }
+            // else
+            // {
+            //    //!dcm! -- can't subscribe in an existing Dialog, this is all
+            //    //a bit of a hack; currently, spurious failure messages may cause callbacks
+            //    BaseCreator* creator = mDialogSet.getCreator();
+            //    if (!creator || !creator->getLastRequest()->exists(h_Event))
+            //    {
+            //       return;
+            //    }
+            //    else
+            //    {
+            //       ClientSubscriptionHandler* handler =
+            //          mDum.getClientSubscriptionHandler(creator->getLastRequest()->header(h_Event).value());
+            //       if (handler)
+            //       {
+            //          ClientSubscription* sub = makeClientSubscription(*creator->getLastRequest());
+            //          mClientSubscriptions.push_back(sub);
+            //          sub->dispatch(response);
+            //       }
+            //    }
+            // }
 
          }
          break;
@@ -890,19 +890,19 @@ Dialog::findMatchingServerSub(const SipMessage& msg)
    return 0;
 }
 
-ClientSubscription*
-Dialog::findMatchingClientSub(const SipMessage& msg)
-{
-   for (std::list<ClientSubscription*>::iterator i=mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      if ((*i)->matches(msg))
-      {
-         return *i;
-      }
-   }
-   return 0;
-}
+// ClientSubscription*
+// Dialog::findMatchingClientSub(const SipMessage& msg)
+// {
+//    for (std::list<ClientSubscription*>::iterator i=mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       if ((*i)->matches(msg))
+//       {
+//          return *i;
+//       }
+//    }
+//    return 0;
+// }
 
 InviteSessionHandle
 Dialog::getInviteSession()
@@ -917,21 +917,21 @@ Dialog::getInviteSession()
    }
 }
 
-std::vector<ClientSubscriptionHandle>
-Dialog::findClientSubscriptions(const Data& event)
-{
-   std::vector<ClientSubscriptionHandle> handles;
-
-   for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      if ( (*i)->getEventType() == event)
-      {
-         handles.push_back((*i)->getHandle());
-      }
-   }
-   return handles;
-}
+// std::vector<ClientSubscriptionHandle>
+// Dialog::findClientSubscriptions(const Data& event)
+// {
+//    std::vector<ClientSubscriptionHandle> handles;
+
+//    for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       if ( (*i)->getEventType() == event)
+//       {
+//          handles.push_back((*i)->getHandle());
+//       }
+//    }
+//    return handles;
+// }
 
 std::vector<ServerSubscriptionHandle>
 Dialog::findServerSubscriptions(const Data& event)
@@ -949,19 +949,19 @@ Dialog::findServerSubscriptions(const Data& event)
    return handles;
 }
 
-std::vector<ClientSubscriptionHandle>
-Dialog::getClientSubscriptions()
-{
-   std::vector<ClientSubscriptionHandle> handles;
+// std::vector<ClientSubscriptionHandle>
+// Dialog::getClientSubscriptions()
+// {
+//    std::vector<ClientSubscriptionHandle> handles;
 
-   for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
-        i != mClientSubscriptions.end(); ++i)
-   {
-      handles.push_back((*i)->getHandle());
-   }
+//    for (std::list<ClientSubscription*>::const_iterator i = mClientSubscriptions.begin();
+//         i != mClientSubscriptions.end(); ++i)
+//    {
+//       handles.push_back((*i)->getHandle());
+//    }
 
-   return handles;
-}
+//    return handles;
+// }
 
 std::vector<ServerSubscriptionHandle>
 Dialog::getServerSubscriptions()
@@ -981,18 +981,18 @@ void
 Dialog::redirected(const SipMessage& msg)
 {
    //Established dialogs are not destroyed by a redirect
-   if (!mClientSubscriptions.empty() || !mServerSubscriptions.empty())
+   if (/* !mClientSubscriptions.empty() ||  */!mServerSubscriptions.empty())
    {
       return;
    }
    if (mInviteSession)
    {
-      ClientInviteSession* cInv = dynamic_cast<ClientInviteSession*>(mInviteSession);
-      if (cInv)
-      {
-         cInv->handleRedirect(msg);
-         mReUseDialogSet = true;  // Set flag so that DialogSet will not be destroyed and new Request can use it
-      }
+      // ClientInviteSession* cInv = dynamic_cast<ClientInviteSession*>(mInviteSession);
+      // if (cInv)
+      // {
+      //    cInv->handleRedirect(msg);
+      //    mReUseDialogSet = true;  // Set flag so that DialogSet will not be destroyed and new Request can use it
+      // }
    }
 }
 
@@ -1123,25 +1123,25 @@ Dialog::setRequestNextCSeq(SipMessage& request)
    request.header(h_CSeq).sequence() = ++mLocalCSeq;
 }
 
-ClientInviteSession*
-Dialog::makeClientInviteSession(const SipMessage& response)
-{
-   InviteSessionCreator* creator = dynamic_cast<InviteSessionCreator*>(mDialogSet.getCreator());
-   if (!creator)
-   {
-      resip_assert(0); // !jf! this maybe can assert by evil UAS
-      return 0;
-   }
-   //return mDum.createAppClientInviteSession(*this, *creator);
-   return new ClientInviteSession(mDum, *this, creator->getLastRequest(),
-                                  creator->getInitialOffer(), creator->getEncryptionLevel(), creator->getServerSubscription());
-}
-
-ClientSubscription*
-Dialog::makeClientSubscription(const SipMessage& request)
-{
-   return new ClientSubscription(mDum, *this, request);
-}
+// ClientInviteSession*
+// Dialog::makeClientInviteSession(const SipMessage& response)
+// {
+//    InviteSessionCreator* creator = dynamic_cast<InviteSessionCreator*>(mDialogSet.getCreator());
+//    if (!creator)
+//    {
+//       resip_assert(0); // !jf! this maybe can assert by evil UAS
+//       return 0;
+//    }
+//    //return mDum.createAppClientInviteSession(*this, *creator);
+//    return new ClientInviteSession(mDum, *this, creator->getLastRequest(),
+//                                   creator->getInitialOffer(), creator->getEncryptionLevel(), creator->getServerSubscription());
+// }
+
+// ClientSubscription*
+// Dialog::makeClientSubscription(const SipMessage& request)
+// {
+//    return new ClientSubscription(mDum, *this, request);
+// }
 
 ServerInviteSession*
 Dialog::makeServerInviteSession(const SipMessage& request)
@@ -1175,11 +1175,11 @@ Dialog::send(std::shared_ptr<SipMessage> msg)
 void
 Dialog::onForkAccepted()
 {
-   ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
-   if (uac)
-   {
-      uac->onForkAccepted();
-   }
+   // ClientInviteSession* uac = dynamic_cast<ClientInviteSession*>(mInviteSession);
+   // if (uac)
+   // {
+   //    uac->onForkAccepted();
+   // }
 }
 
 void 
@@ -1187,7 +1187,7 @@ Dialog::possiblyDie()
 {
    if (!mDestroying)
    {
-      if (mClientSubscriptions.empty() &&
+      if (/* mClientSubscriptions.empty() && */
           mServerSubscriptions.empty() &&
           !mInviteSession)
       {
@@ -1212,12 +1212,12 @@ Dialog::flowTerminated()
    }
 
    // notify client subscription dialogs
-   std::list<ClientSubscription*> tempClientList = mClientSubscriptions;  // Create copy since subscription can be deleted
-   for (std::list<ClientSubscription*>::iterator ic=tempClientList.begin();
-        ic != tempClientList.end(); ++ic)
-   {
-      (*ic)->flowTerminated();
-   }
+   // std::list<ClientSubscription*> tempClientList = mClientSubscriptions;  // Create copy since subscription can be deleted
+   // for (std::list<ClientSubscription*>::iterator ic=tempClientList.begin();
+   //      ic != tempClientList.end(); ++ic)
+   // {
+   //    (*ic)->flowTerminated();
+   // }
 
    // notify invite session dialog
    if (mInviteSession)
@@ -1230,9 +1230,9 @@ EncodeStream&
 resip::operator<<(EncodeStream& strm, const Dialog& dialog)
 {
    strm
-      << "mClientSubscriptions("
-      << dialog.mClientSubscriptions.size()
-      << "), "
+      // << "mClientSubscriptions("
+      // << dialog.mClientSubscriptions.size()
+      // << "), "
       << "mServerSubscriptions("
       << dialog.mServerSubscriptions.size()
       << ")";
diff --git a/resip/dum/Dialog.hxx b/resip/dum/Dialog.hxx
old mode 100644
new mode 100755
index 3c63eb323..fc987d6bb
--- a/resip/dum/Dialog.hxx
+++ b/resip/dum/Dialog.hxx
@@ -59,8 +59,8 @@ class Dialog
       //void setLocalContact(const NameAddr& localContact);
       //void setRemoteTarget(const NameAddr& remoteTarget);
       
-      std::vector<ClientSubscriptionHandle> getClientSubscriptions();
-      std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
+      // std::vector<ClientSubscriptionHandle> getClientSubscriptions();
+      // std::vector<ClientSubscriptionHandle> findClientSubscriptions(const Data& event);
 
       std::vector<ServerSubscriptionHandle> getServerSubscriptions();
       std::vector<ServerSubscriptionHandle> findServerSubscriptions(const Data& event);
@@ -102,12 +102,12 @@ class Dialog
       friend class AppDialog;
       void possiblyDie();
 
-      ClientSubscription* findMatchingClientSub(const SipMessage& msg);
+      // ClientSubscription* findMatchingClientSub(const SipMessage& msg);
       ServerSubscription* findMatchingServerSub(const SipMessage& msg);
 
       void addUsage(BaseUsage* usage);
-      ClientInviteSession* makeClientInviteSession(const SipMessage& msg);
-      ClientSubscription*  makeClientSubscription(const SipMessage& msg);
+      // ClientInviteSession* makeClientInviteSession(const SipMessage& msg);
+      // ClientSubscription*  makeClientSubscription(const SipMessage& msg);
       
       ServerInviteSession* makeServerInviteSession(const SipMessage& msg);
       ServerSubscription*  makeServerSubscription(const SipMessage& msg);
@@ -123,7 +123,7 @@ class Dialog
       DialogSet& mDialogSet;
       DialogId mId;  
 
-      std::list<ClientSubscription*> mClientSubscriptions;
+      // std::list<ClientSubscription*> mClientSubscriptions;
       std::list<ServerSubscription*> mServerSubscriptions;
       InviteSession* mInviteSession;
 
diff --git a/resip/dum/DialogSet.cxx b/resip/dum/DialogSet.cxx
old mode 100644
new mode 100755
index e6e920d96..7106523da
--- a/resip/dum/DialogSet.cxx
+++ b/resip/dum/DialogSet.cxx
@@ -42,10 +42,10 @@ DialogSet::DialogSet(BaseCreator* creator, DialogUsageManager& dum) :
    mAppDialogSet(0),
    mState(Initial),
    mClientRegistration(0),
-   mServerRegistration(0),
-   mClientPublication(0),
-   mClientOutOfDialogRequests(),
-   mServerOutOfDialogRequest(0),
+   // mServerRegistration(0),
+   // mClientPublication(0),
+   // mClientOutOfDialogRequests(),
+   // mServerOutOfDialogRequest(0),
    mClientPagerMessage(0),
    mServerPagerMessage(0)
 {
@@ -64,10 +64,10 @@ DialogSet::DialogSet(const SipMessage& request, DialogUsageManager& dum) :
    mAppDialogSet(0),
    mState(Established),
    mClientRegistration(0),
-   mServerRegistration(0),
-   mClientPublication(0),
-   mClientOutOfDialogRequests(),
-   mServerOutOfDialogRequest(0),
+   // mServerRegistration(0),
+   // mClientPublication(0),
+   // mClientOutOfDialogRequests(),
+   // mServerOutOfDialogRequest(0),
    mClientPagerMessage(0),
    mServerPagerMessage(0)
 {
@@ -116,16 +116,16 @@ DialogSet::~DialogSet()
    }
 
    delete mClientRegistration;
-   delete mServerRegistration;
-   delete mClientPublication;
-   delete mServerOutOfDialogRequest;
+   // delete mServerRegistration;
+   // delete mClientPublication;
+   // delete mServerOutOfDialogRequest;
    delete mClientPagerMessage;
    delete mServerPagerMessage;
 
-   while (!mClientOutOfDialogRequests.empty())
-   {
-      delete *mClientOutOfDialogRequests.begin();
-   }
+   // while (!mClientOutOfDialogRequests.empty())
+   // {
+   //    delete *mClientOutOfDialogRequests.begin();
+   // }
 
    DebugLog ( << " ********** DialogSet::~DialogSet: " << mId << "*************" );
    // !dcm! -- very delicate code, change the order things go horribly wrong
@@ -148,13 +148,13 @@ void DialogSet::possiblyDie()
       //       for which we have not created any Dialogs yet - in this case
       //       we don't want the dialogset to die, since the UAC usage is not complete.     
       (getCreator() == 0 || (mState != Initial && mState != ReceivedProvisional)) &&
-      mClientOutOfDialogRequests.empty() &&
-      !(mClientPublication ||
-        mServerOutOfDialogRequest ||
+      // mClientOutOfDialogRequests.empty() &&
+      !(/* mClientPublication || */
+      //   mServerOutOfDialogRequest ||
         mClientPagerMessage ||
         mServerPagerMessage ||
-        mClientRegistration ||
-        mServerRegistration))
+        mClientRegistration/*  ||
+        mServerRegistration */))
    {
       mState = Destroying;
       mDum.destroy(this);
@@ -554,62 +554,62 @@ DialogSet::dispatch(const SipMessage& msg)
             break;
             
          case REFER:
-            if (dialog)
-            {
-               DebugLog(<< "in dialog refer request");
-               break; // in dialog
-            }
-            else if (request.header(h_To).exists(p_tag))
-            {
-                // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
-                auto response = std::make_shared<SipMessage>();
-                mDum.makeResponse(*response, msg, 481);
-                mDum.send(response);
-                return;
-            }
-            // We have an out-of-dialog request, check if it needs an implied subscription dialog
-            else if((request.exists(h_ReferSub) && 
-                     request.header(h_ReferSub).isWellFormed() &&
-                     request.header(h_ReferSub).value()=="false") ||
-                     (request.exists(h_Requires) &&
-                     request.header(h_Requires).find(Token("norefersub"))))// out of dialog & noReferSub=true
-            {
-               // No dialog needed here
-               DebugLog(<< "out of dialog refer request with norefersub");
-               resip_assert(mServerOutOfDialogRequest == 0);
-               mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-               mServerOutOfDialogRequest->dispatch(request);
-               return;
-            }
-            else
-            {
-               DebugLog(<< "out of dialog refer request with refer sub");
-               break; // dialog creating
-            }
+            // if (dialog)
+            // {
+            //    DebugLog(<< "in dialog refer request");
+            //    break; // in dialog
+            // }
+            // else if (request.header(h_To).exists(p_tag))
+            // {
+            //     // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
+            //     auto response = std::make_shared<SipMessage>();
+            //     mDum.makeResponse(*response, msg, 481);
+            //     mDum.send(response);
+            //     return;
+            // }
+            // // We have an out-of-dialog request, check if it needs an implied subscription dialog
+            // else if((request.exists(h_ReferSub) && 
+            //          request.header(h_ReferSub).isWellFormed() &&
+            //          request.header(h_ReferSub).value()=="false") ||
+            //          (request.exists(h_Requires) &&
+            //          request.header(h_Requires).find(Token("norefersub"))))// out of dialog & noReferSub=true
+            // {
+            //    // No dialog needed here
+            //    DebugLog(<< "out of dialog refer request with norefersub");
+            //    resip_assert(mServerOutOfDialogRequest == 0);
+            //    mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+            //    mServerOutOfDialogRequest->dispatch(request);
+            //    return;
+            // }
+            // else
+            // {
+            //    DebugLog(<< "out of dialog refer request with refer sub");
+            //    break; // dialog creating
+            // }
             break;
 
          case NOTIFY:
-            if (dialog)
-            {
-               break; //dialog creating/handled by dialog
-            }
-            else if (request.header(h_To).exists(p_tag))
-            {
-                // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
-                auto response = std::make_shared<SipMessage>();
-                mDum.makeResponse(*response, msg, 481);
-                mDum.send(response);
-                return;
-            }
-            else // no to tag - unsolicited notify
-            {
-               // unsolicited - not allowed but commonly implemented
-               // by large companies with a bridge as their logo
-               resip_assert(mServerOutOfDialogRequest == 0);
-               mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-               mServerOutOfDialogRequest->dispatch(request);
-               return;
-            }
+            // if (dialog)
+            // {
+            //    break; //dialog creating/handled by dialog
+            // }
+            // else if (request.header(h_To).exists(p_tag))
+            // {
+            //     // We have a To tag, but don't have an existing dialog, we shouldn't be creating a new one, reject
+            //     auto response = std::make_shared<SipMessage>();
+            //     mDum.makeResponse(*response, msg, 481);
+            //     mDum.send(response);
+            //     return;
+            // }
+            // else // no to tag - unsolicited notify
+            // {
+            //    // unsolicited - not allowed but commonly implemented
+            //    // by large companies with a bridge as their logo
+            //    resip_assert(mServerOutOfDialogRequest == 0);
+            //    mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+            //    mServerOutOfDialogRequest->dispatch(request);
+            //    return;
+            // }
             break;
 
          case PUBLISH:
@@ -618,11 +618,11 @@ DialogSet::dispatch(const SipMessage& msg)
             
          case REGISTER:
             // !jf! move this to DialogUsageManager
-            if (mServerRegistration == 0)
-            {
-               mServerRegistration = makeServerRegistration(request);
-            }
-            mServerRegistration->dispatch(request);
+            // if (mServerRegistration == 0)
+            // {
+            //    mServerRegistration = makeServerRegistration(request);
+            // }
+            // mServerRegistration->dispatch(request);
             return;
 
          case MESSAGE:
@@ -639,9 +639,9 @@ DialogSet::dispatch(const SipMessage& msg)
             // !jf! move this to DialogUsageManager
             DebugLog ( << "In DialogSet::dispatch, default(ServerOutOfDialogRequest), msg: " << msg );
             // only can be one ServerOutOfDialogReq at a time
-            resip_assert(mServerOutOfDialogRequest == 0);
-            mServerOutOfDialogRequest = makeServerOutOfDialog(request);
-            mServerOutOfDialogRequest->dispatch(request);
+            // resip_assert(mServerOutOfDialogRequest == 0);
+            // mServerOutOfDialogRequest = makeServerOutOfDialog(request);
+            // mServerOutOfDialogRequest->dispatch(request);
             return;
       }
    }
@@ -739,14 +739,14 @@ DialogSet::dispatch(const SipMessage& msg)
             break; 
 
          case PUBLISH:
-            if (mClientPublication == 0 && getCreator())
-            {
-               mClientPublication = makeClientPublication(response);
-            }
-            if (mClientPublication)
-            {
-               mClientPublication->dispatch(response);
-            }
+            // if (mClientPublication == 0 && getCreator())
+            // {
+            //    mClientPublication = makeClientPublication(response);
+            // }
+            // if (mClientPublication)
+            // {
+            //    mClientPublication->dispatch(response);
+            // }
             return;
 
          case REGISTER:
@@ -795,19 +795,19 @@ DialogSet::dispatch(const SipMessage& msg)
             
          default:
          {
-            ClientOutOfDialogReq* req = findMatchingClientOutOfDialogReq(response);
-            if (req == 0)
-            {
-               // We should only create a new ClientOutOfDialogReq if this is a response to our initial request
-               if (!getCreator() || !(msg.header(h_CSeq) == getCreator()->getLastRequest()->header(h_CSeq)))
-               {
-                  InfoLog(<< "Cannot create a ClientOutOfDialogReq, initial dialog request is missing or cseq does not match, ignoring.");
-                  return;
-               }
-               req = makeClientOutOfDialogReq(response);
-               mClientOutOfDialogRequests.push_back(req);
-            }
-            req->dispatch(response);
+            // ClientOutOfDialogReq* req = findMatchingClientOutOfDialogReq(response);
+            // if (req == 0)
+            // {
+            //    // We should only create a new ClientOutOfDialogReq if this is a response to our initial request
+            //    if (!getCreator() || !(msg.header(h_CSeq) == getCreator()->getLastRequest()->header(h_CSeq)))
+            //    {
+            //       InfoLog(<< "Cannot create a ClientOutOfDialogReq, initial dialog request is missing or cseq does not match, ignoring.");
+            //       return;
+            //    }
+            //    req = makeClientOutOfDialogReq(response);
+            //    mClientOutOfDialogRequests.push_back(req);
+            // }
+            // req->dispatch(response);
             return;
          }
       }
@@ -935,19 +935,19 @@ DialogSet::dispatch(const SipMessage& msg)
 }
 
 
-ClientOutOfDialogReq*
-DialogSet::findMatchingClientOutOfDialogReq(const SipMessage& msg)
-{
-   for (std::list<ClientOutOfDialogReq*>::iterator i=mClientOutOfDialogRequests.begin();
-        i != mClientOutOfDialogRequests.end(); ++i)
-   {
-      if ((*i)->matches(msg))
-      {
-         return *i;
-      }
-   }
-   return 0;
-}
+// ClientOutOfDialogReq*
+// DialogSet::findMatchingClientOutOfDialogReq(const SipMessage& msg)
+// {
+//    for (std::list<ClientOutOfDialogReq*>::iterator i=mClientOutOfDialogRequests.begin();
+//         i != mClientOutOfDialogRequests.end(); ++i)
+//    {
+//       if ((*i)->matches(msg))
+//       {
+//          return *i;
+//       }
+//    }
+//    return 0;
+// }
 
 Dialog*
 DialogSet::findDialog(const DialogId id)
@@ -1113,11 +1113,11 @@ DialogSet::getClientRegistration()
 ServerRegistrationHandle
 DialogSet::getServerRegistration()
 {
-   if (mServerRegistration)
-   {
-      return mServerRegistration->getHandle();
-   }
-   else
+   // if (mServerRegistration)
+   // {
+   //    return mServerRegistration->getHandle();
+   // }
+   // else
    {
       return ServerRegistrationHandle::NotValid();
    }
@@ -1126,11 +1126,11 @@ DialogSet::getServerRegistration()
 ClientPublicationHandle
 DialogSet::getClientPublication()
 {
-   if (mClientPublication)
-   {
-      return mClientPublication->getHandle();
-   }
-   else
+   // if (mClientPublication)
+   // {
+   //    return mClientPublication->getHandle();
+   // }
+   // else
    {
       return ClientPublicationHandle::NotValid();
    }
@@ -1144,33 +1144,33 @@ DialogSet::makeClientRegistration(const SipMessage& response)
    return new ClientRegistration(mDum, *this, creator->getLastRequest());
 }
 
-ClientPublication*
-DialogSet::makeClientPublication(const SipMessage& response)
-{
-   BaseCreator* creator = getCreator();
-   resip_assert(creator);
-   return new ClientPublication(mDum, *this, creator->getLastRequest());
-}
-
-ClientOutOfDialogReq*
-DialogSet::makeClientOutOfDialogReq(const SipMessage& response)
-{
-   BaseCreator* creator = getCreator();
-   resip_assert(creator);
-   return new ClientOutOfDialogReq(mDum, *this, *creator->getLastRequest());
-}
-
-ServerRegistration*
-DialogSet::makeServerRegistration(const SipMessage& request)
-{
-   return new ServerRegistration(mDum, *this, request);
-}
-
-ServerOutOfDialogReq*
-DialogSet::makeServerOutOfDialog(const SipMessage& request)
-{
-   return new ServerOutOfDialogReq(mDum, *this, request);
-}
+// ClientPublication*
+// DialogSet::makeClientPublication(const SipMessage& response)
+// {
+//    BaseCreator* creator = getCreator();
+//    resip_assert(creator);
+//    return new ClientPublication(mDum, *this, creator->getLastRequest());
+// }
+
+// ClientOutOfDialogReq*
+// DialogSet::makeClientOutOfDialogReq(const SipMessage& response)
+// {
+//    BaseCreator* creator = getCreator();
+//    resip_assert(creator);
+//    return new ClientOutOfDialogReq(mDum, *this, *creator->getLastRequest());
+// }
+
+// ServerRegistration*
+// DialogSet::makeServerRegistration(const SipMessage& request)
+// {
+//    return new ServerRegistration(mDum, *this, request);
+// }
+
+// ServerOutOfDialogReq*
+// DialogSet::makeServerOutOfDialog(const SipMessage& request)
+// {
+//    return new ServerOutOfDialogReq(mDum, *this, request);
+// }
 
 ServerPagerMessage*
 DialogSet::makeServerPagerMessage(const SipMessage& request)
@@ -1178,18 +1178,18 @@ DialogSet::makeServerPagerMessage(const SipMessage& request)
    return new ServerPagerMessage(mDum, *this, request);
 }
 
-ServerOutOfDialogReqHandle
-DialogSet::getServerOutOfDialog()
-{
-   if (mServerOutOfDialogRequest)
-   {
-      return mServerOutOfDialogRequest->getHandle();
-   }
-   else
-   {
-      return ServerOutOfDialogReqHandle::NotValid();
-   }
-}
+// ServerOutOfDialogReqHandle
+// DialogSet::getServerOutOfDialog()
+// {
+//    if (mServerOutOfDialogRequest)
+//    {
+//       return mServerOutOfDialogRequest->getHandle();
+//    }
+//    else
+//    {
+//       return ServerOutOfDialogReqHandle::NotValid();
+//    }
+// }
 
 void DialogSet::dispatchToAllDialogs(const SipMessage& msg)
 {
diff --git a/resip/dum/DialogSet.hxx b/resip/dum/DialogSet.hxx
old mode 100644
new mode 100755
index 71fbcd4cb..3f4c67d78
--- a/resip/dum/DialogSet.hxx
+++ b/resip/dum/DialogSet.hxx
@@ -45,8 +45,8 @@ class DialogSet
       ClientRegistrationHandle getClientRegistration();
       ServerRegistrationHandle getServerRegistration();
       ClientPublicationHandle getClientPublication();
-      ClientOutOfDialogReqHandle getClientOutOfDialog();
-      ServerOutOfDialogReqHandle getServerOutOfDialog();
+      // ClientOutOfDialogReqHandle getClientOutOfDialog();
+      // ServerOutOfDialogReqHandle getServerOutOfDialog();
 
       bool isDestroying() const noexcept { return mState == Destroying; };
 
@@ -92,14 +92,14 @@ class DialogSet
       Dialog* findDialog(const SipMessage& msg);
       Dialog* findDialog(const DialogId id);
 
-      ClientOutOfDialogReq* findMatchingClientOutOfDialogReq(const SipMessage& msg);
+      // ClientOutOfDialogReq* findMatchingClientOutOfDialogReq(const SipMessage& msg);
 
       ClientRegistration* makeClientRegistration(const SipMessage& msg);
-      ClientPublication* makeClientPublication( const SipMessage& msg);
-      ClientOutOfDialogReq* makeClientOutOfDialogReq(const SipMessage& msg);
+      // ClientPublication* makeClientPublication( const SipMessage& msg);
+      // ClientOutOfDialogReq* makeClientOutOfDialogReq(const SipMessage& msg);
 
-      ServerRegistration* makeServerRegistration(const SipMessage& msg);
-      ServerOutOfDialogReq* makeServerOutOfDialog(const SipMessage& msg);
+      // ServerRegistration* makeServerRegistration(const SipMessage& msg);
+      // ServerOutOfDialogReq* makeServerOutOfDialog(const SipMessage& msg);
       
       ServerPagerMessage* makeServerPagerMessage(const SipMessage& request);      
 
@@ -117,10 +117,10 @@ class DialogSet
       AppDialogSet* mAppDialogSet;
       State mState;
       ClientRegistration* mClientRegistration;
-      ServerRegistration* mServerRegistration;
-      ClientPublication* mClientPublication;
-      std::list<ClientOutOfDialogReq*> mClientOutOfDialogRequests;
-      ServerOutOfDialogReq* mServerOutOfDialogRequest;
+      // ServerRegistration* mServerRegistration;
+      // ClientPublication* mClientPublication;
+      // std::list<ClientOutOfDialogReq*> mClientOutOfDialogRequests;
+      // ServerOutOfDialogReq* mServerOutOfDialogRequest;
 
       ClientPagerMessage* mClientPagerMessage;
       ServerPagerMessage* mServerPagerMessage;
diff --git a/resip/dum/DialogSetId.cxx b/resip/dum/DialogSetId.cxx
old mode 100644
new mode 100755
index 266a2bf95..33e067971
--- a/resip/dum/DialogSetId.cxx
+++ b/resip/dum/DialogSetId.cxx
@@ -31,7 +31,7 @@ DialogSetId::DialogSetId(const SipMessage& msg) :
          }
          else
          {
-            //DebugLog ( <<  "********** Generated Local Tag *********** " );            
+            DebugLog ( <<  "********** Generated Local Tag *********** " );
             mTag = Helper::computeTag(Helper::tagSize);
          }
       }
diff --git a/resip/dum/DialogUsageManager.cxx b/resip/dum/DialogUsageManager.cxx
old mode 100644
new mode 100755
index e905fc28e..aeb27f0d3
--- a/resip/dum/DialogUsageManager.cxx
+++ b/resip/dum/DialogUsageManager.cxx
@@ -102,7 +102,7 @@ DialogUsageManager::DialogUsageManager(SipStack& stack, bool createDefaultFeatur
    mRedirectManager(new RedirectManager()),
    mInviteSessionHandler(0),
    mClientRegistrationHandler(0),
-   mServerRegistrationHandler(0),
+   // mServerRegistrationHandler(0),
    mRedirectHandler(0),
    mDialogSetHandler(0),
    mRequestValidationHandler(0),
@@ -121,7 +121,7 @@ DialogUsageManager::DialogUsageManager(SipStack& stack, bool createDefaultFeatur
 {
    //TODO -- create default features
    mStack.registerTransactionUser(*this);
-   addServerSubscriptionHandler("refer", new DefaultServerReferHandler());
+   // addServerSubscriptionHandler("refer", new DefaultServerReferHandler());
 
    mFifo.setDescription("DialogUsageManager::mFifo");
 
@@ -186,10 +186,10 @@ DialogUsageManager::~DialogUsageManager()
    delete mOutgoingTarget;
 
    // Delete Server Publications
-   while (!mServerPublications.empty())
-   {
-       delete mServerPublications.begin()->second;  // Deleting a ServerPublication removes itself from the map
-   }
+   // while (!mServerPublications.empty())
+   // {
+   //     delete mServerPublications.begin()->second;  // Deleting a ServerPublication removes itself from the map
+   // }
 
    // Remove any lingering incoming feature chain memory
    for(FeatureChainMap::iterator it = mIncomingFeatureChainMap.begin(); it != mIncomingFeatureChainMap.end(); it++)
@@ -365,12 +365,12 @@ DialogUsageManager::setClientRegistrationHandler(ClientRegistrationHandler* hand
    mClientRegistrationHandler = handler;
 }
 
-void
-DialogUsageManager::setServerRegistrationHandler(ServerRegistrationHandler* handler)
-{
-   resip_assert(!mServerRegistrationHandler);
-   mServerRegistrationHandler = handler;
-}
+// void
+// DialogUsageManager::setServerRegistrationHandler(ServerRegistrationHandler* handler)
+// {
+//    resip_assert(!mServerRegistrationHandler);
+//    mServerRegistrationHandler = handler;
+// }
 
 void
 DialogUsageManager::setDialogSetHandler(DialogSetHandler* handler) noexcept
@@ -423,13 +423,13 @@ DialogUsageManager::addTimerMs(DumTimeout::Type type, unsigned long duration,
    mStack.postMS(t, duration, this);
 }
 
-void
-DialogUsageManager::addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mClientSubscriptionHandlers.find(eventType) == mClientSubscriptionHandlers.end());
-   mClientSubscriptionHandlers[eventType] = handler;
-}
+// void
+// DialogUsageManager::addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mClientSubscriptionHandlers.find(eventType) == mClientSubscriptionHandlers.end());
+//    mClientSubscriptionHandlers[eventType] = handler;
+// }
 
 void
 DialogUsageManager::addServerSubscriptionHandler(const Data& eventType, ServerSubscriptionHandler* handler)
@@ -450,29 +450,29 @@ DialogUsageManager::addServerSubscriptionHandler(const Data& eventType, ServerSu
    mServerSubscriptionHandlers[eventType] = handler;
 }
 
-void
-DialogUsageManager::addClientPublicationHandler(const Data& eventType, ClientPublicationHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mClientPublicationHandlers.find(eventType) == mClientPublicationHandlers.end());
-   mClientPublicationHandlers[eventType] = handler;
-}
+// void
+// DialogUsageManager::addClientPublicationHandler(const Data& eventType, ClientPublicationHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mClientPublicationHandlers.find(eventType) == mClientPublicationHandlers.end());
+//    mClientPublicationHandlers[eventType] = handler;
+// }
 
-void
-DialogUsageManager::addServerPublicationHandler(const Data& eventType, ServerPublicationHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mServerPublicationHandlers.find(eventType) == mServerPublicationHandlers.end());
-   mServerPublicationHandlers[eventType] = handler;
-}
+// void
+// DialogUsageManager::addServerPublicationHandler(const Data& eventType, ServerPublicationHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mServerPublicationHandlers.find(eventType) == mServerPublicationHandlers.end());
+//    mServerPublicationHandlers[eventType] = handler;
+// }
 
-void
-DialogUsageManager::addOutOfDialogHandler(MethodTypes type, OutOfDialogHandler* handler)
-{
-   resip_assert(handler);
-   resip_assert(mOutOfDialogHandlers.find(type) == mOutOfDialogHandlers.end());
-   mOutOfDialogHandlers[type] = handler;
-}
+// void
+// DialogUsageManager::addOutOfDialogHandler(MethodTypes type, OutOfDialogHandler* handler)
+// {
+//    resip_assert(handler);
+//    resip_assert(mOutOfDialogHandlers.find(type) == mOutOfDialogHandlers.end());
+//    mOutOfDialogHandlers[type] = handler;
+// }
 
 void
 DialogUsageManager::setClientPagerMessageHandler(ClientPagerMessageHandler* handler) noexcept
@@ -563,262 +563,262 @@ DialogUsageManager::sendResponse(const SipMessage& response)
    mStack.send(response, this);
 }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* appDs)
-{
-   return makeInviteSession(target, userProfile, initialOffer, None, nullptr, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* appDs)
-{
-   return makeInviteSession(target, getMasterUserProfile(), initialOffer, None, nullptr, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative, 
-                                      AppDialogSet* appDs)
-{
-   auto inv = makeNewSession(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative), appDs);
-   DumHelper::setOutgoingEncryptionLevel(*inv, level);
-   return inv;
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative,
-                                      AppDialogSet* appDs)
-{
-   return makeInviteSession(target, getMasterUserProfile(), initialOffer, level, alternative, appDs);
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target,
-    const DialogSetId& dialogSetId,
-    const std::shared_ptr<UserProfile>& userProfile,
-    const Contents* initialOffer,
-    EncryptionLevel level,
-    const Contents* alternative,
-    AppDialogSet* appDs)
-{
-    resip_assert(mDialogSetMap.find(dialogSetId) == mDialogSetMap.end());
-    BaseCreator* baseCreator(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative));
-    baseCreator->getLastRequest()->header(h_CallID).value() = dialogSetId.getCallId();
-    baseCreator->getLastRequest()->header(h_From).param(p_tag) = dialogSetId.getLocalTag();
-    auto inv = makeNewSession(baseCreator, appDs);
-    DumHelper::setOutgoingEncryptionLevel(*inv, level);
-    return inv;
-}
-
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, userProfile, initialOffer, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, userProfile, initialOffer, None, nullptr, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const std::shared_ptr<UserProfile>& userProfile,
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative, 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, userProfile, initialOffer, level, alternative, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, getMasterUserProfile(), initialOffer, None, nullptr, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSession(const NameAddr& target, 
-                                      InviteSessionHandle sessionToReplace, 
-                                      const Contents* initialOffer, 
-                                      EncryptionLevel level, 
-                                      const Contents* alternative , 
-                                      AppDialogSet* ads)
-{
-   auto inv = makeInviteSession(target, initialOffer, level, alternative, ads);
-   // add replaces header
-   resip_assert(sessionToReplace.isValid());
-   if(sessionToReplace.isValid())
-   {
-      CallId replaces;
-      const DialogId& id = sessionToReplace->getDialogId();
-      replaces.value() = id.getCallId();
-      replaces.param(p_toTag) = id.getRemoteTag();
-      replaces.param(p_fromTag) = id.getLocalTag();
-      inv->header(h_Replaces) = replaces;
-   }
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative, 
+//                                       AppDialogSet* appDs)
+// {
+//    auto inv = makeNewSession(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative), appDs);
+//    DumHelper::setOutgoingEncryptionLevel(*inv, level);
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               AppDialogSet* appDs)
-{
-   return makeInviteSessionFromRefer(refer, serverSub, initialOffer, None, 0, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative,
+//                                       AppDialogSet* appDs)
+// {
+//    return makeInviteSession(target, getMasterUserProfile(), initialOffer, level, alternative, appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               const std::shared_ptr<UserProfile>& userProfile,
-                                               const Contents* initialOffer,
-                                               AppDialogSet* appDs)
-{
-   ServerSubscriptionHandle empty;
-   return makeInviteSessionFromRefer(refer, userProfile, empty, initialOffer, None, 0, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target,
+//     const DialogSetId& dialogSetId,
+//     const std::shared_ptr<UserProfile>& userProfile,
+//     const Contents* initialOffer,
+//     EncryptionLevel level,
+//     const Contents* alternative,
+//     AppDialogSet* appDs)
+// {
+//     resip_assert(mDialogSetMap.find(dialogSetId) == mDialogSetMap.end());
+//     BaseCreator* baseCreator(new InviteSessionCreator(*this, target, userProfile, initialOffer, level, alternative));
+//     baseCreator->getLastRequest()->header(h_CallID).value() = dialogSetId.getCallId();
+//     baseCreator->getLastRequest()->header(h_From).param(p_tag) = dialogSetId.getLocalTag();
+//     auto inv = makeNewSession(baseCreator, appDs);
+//     DumHelper::setOutgoingEncryptionLevel(*inv, level);
+//     return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               EncryptionLevel level,
-                                               const Contents* alternative,
-                                               AppDialogSet* appDs)
-{
-   return makeInviteSessionFromRefer(refer, serverSub.isValid() ? serverSub->mDialog.mDialogSet.getUserProfile() : getMasterUserProfile(), serverSub, initialOffer, level, alternative, appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, userProfile, initialOffer, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
-                                               const std::shared_ptr<UserProfile>& userProfile,
-                                               ServerSubscriptionHandle serverSub,
-                                               const Contents* initialOffer,
-                                               EncryptionLevel level,
-                                               const Contents* alternative,
-                                               AppDialogSet* appDs)
-{
-   if (serverSub.isValid())
-   {
-      DebugLog(<< "implicit subscription");
-      //generate and send 100
-      SipFrag contents;
-      contents.message().header(h_StatusLine).statusCode() = 100;
-      contents.message().header(h_StatusLine).reason() = "Trying";
-      //will be cloned...ServerSub may not have the most efficient API possible
-      serverSub->setSubscriptionState(Active);
-      auto notify = serverSub->update(&contents);
-//   mInviteSessionHandler->onReadyToSend(InviteSessionHandle::NotValid(), notify);
-      serverSub->send(notify);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const std::shared_ptr<UserProfile>& userProfile,
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative, 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, userProfile, initialOffer, level, alternative, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-   //19.1.5
-   NameAddr target = refer.header(h_ReferTo);
-   target.uri().removeEmbedded();
-   target.uri().remove(p_method);
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSession(const NameAddr& target, 
+//                                       InviteSessionHandle sessionToReplace, 
+//                                       const Contents* initialOffer, 
+//                                       EncryptionLevel level, 
+//                                       const Contents* alternative , 
+//                                       AppDialogSet* ads)
+// {
+//    auto inv = makeInviteSession(target, initialOffer, level, alternative, ads);
+//    // add replaces header
+//    resip_assert(sessionToReplace.isValid());
+//    if(sessionToReplace.isValid())
+//    {
+//       CallId replaces;
+//       const DialogId& id = sessionToReplace->getDialogId();
+//       replaces.value() = id.getCallId();
+//       replaces.param(p_toTag) = id.getRemoteTag();
+//       replaces.param(p_fromTag) = id.getLocalTag();
+//       inv->header(h_Replaces) = replaces;
+//    }
+//    return inv;
+// }
 
-   // !jf! this code assumes you have a UserProfile
-   auto inv = makeNewSession(new InviteSessionCreator(*this,
-                                                      target,
-                                                      userProfile,
-                                                      initialOffer, level, alternative, serverSub), appDs);
-   DumHelper::setOutgoingEncryptionLevel(*inv, level);
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                AppDialogSet* appDs)
+// {
+//    return makeInviteSessionFromRefer(refer, serverSub, initialOffer, None, 0, appDs);
+// }
 
-   //could pass dummy target, then apply merge rules from 19.1.5...or
-   //makeNewSession would use rules from 19.1.5
-   if (refer.exists(h_ReferredBy))
-   {
-      inv->header(h_ReferredBy) = refer.header(h_ReferredBy);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                const std::shared_ptr<UserProfile>& userProfile,
+//                                                const Contents* initialOffer,
+//                                                AppDialogSet* appDs)
+// {
+//    ServerSubscriptionHandle empty;
+//    return makeInviteSessionFromRefer(refer, userProfile, empty, initialOffer, None, 0, appDs);
+// }
 
-   const Uri& referTo = refer.header(h_ReferTo).uri();
-   //19.1.5
-   if (referTo.hasEmbedded() && referTo.embedded().exists(h_Replaces))
-   {
-      inv->header(h_Replaces) = referTo.embedded().header(h_Replaces);
-   }
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                EncryptionLevel level,
+//                                                const Contents* alternative,
+//                                                AppDialogSet* appDs)
+// {
+//    return makeInviteSessionFromRefer(refer, serverSub.isValid() ? serverSub->mDialog.mDialogSet.getUserProfile() : getMasterUserProfile(), serverSub, initialOffer, level, alternative, appDs);
+// }
 
-   return inv;
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeInviteSessionFromRefer(const SipMessage& refer,
+//                                                const std::shared_ptr<UserProfile>& userProfile,
+//                                                ServerSubscriptionHandle serverSub,
+//                                                const Contents* initialOffer,
+//                                                EncryptionLevel level,
+//                                                const Contents* alternative,
+//                                                AppDialogSet* appDs)
+// {
+//    if (serverSub.isValid())
+//    {
+//       DebugLog(<< "implicit subscription");
+//       //generate and send 100
+//       SipFrag contents;
+//       contents.message().header(h_StatusLine).statusCode() = 100;
+//       contents.message().header(h_StatusLine).reason() = "Trying";
+//       //will be cloned...ServerSub may not have the most efficient API possible
+//       serverSub->setSubscriptionState(Active);
+//       auto notify = serverSub->update(&contents);
+// //   mInviteSessionHandler->onReadyToSend(InviteSessionHandle::NotValid(), notify);
+//       serverSub->send(notify);
+//    }
+
+//    //19.1.5
+//    NameAddr target = refer.header(h_ReferTo);
+//    target.uri().removeEmbedded();
+//    target.uri().remove(p_method);
+
+//    // !jf! this code assumes you have a UserProfile
+//    auto inv = makeNewSession(new InviteSessionCreator(*this,
+//                                                       target,
+//                                                       userProfile,
+//                                                       initialOffer, level, alternative, serverSub), appDs);
+//    DumHelper::setOutgoingEncryptionLevel(*inv, level);
+
+//    //could pass dummy target, then apply merge rules from 19.1.5...or
+//    //makeNewSession would use rules from 19.1.5
+//    if (refer.exists(h_ReferredBy))
+//    {
+//       inv->header(h_ReferredBy) = refer.header(h_ReferredBy);
+//    }
+
+//    const Uri& referTo = refer.header(h_ReferTo).uri();
+//    //19.1.5
+//    if (referTo.hasEmbedded() && referTo.embedded().exists(h_Replaces))
+//    {
+//       inv->header(h_Replaces) = referTo.embedded().header(h_Replaces);
+//    }
+
+//    return inv;
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, referTo), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, referTo), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), referTo), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), referTo), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* appDs)
-{
-   resip_assert(userProfile.get());
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, userProfile->getDefaultSubscriptionTime()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* appDs)
+// {
+//    resip_assert(userProfile.get());
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, userProfile->getDefaultSubscriptionTime()), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                     uint32_t subscriptionTime, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+//                                      uint32_t subscriptionTime, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                     uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime, refreshInterval), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+//                                      uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, userProfile, eventType, subscriptionTime, refreshInterval), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, getMasterProfile()->getDefaultSubscriptionTime()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, getMasterProfile()->getDefaultSubscriptionTime()), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
-                                     uint32_t subscriptionTime, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
+//                                      uint32_t subscriptionTime, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
-                                     uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
-{
-   return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime, refreshInterval), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeSubscription(const NameAddr& target, const Data& eventType,
+//                                      uint32_t subscriptionTime, int refreshInterval, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new SubscriptionCreator(*this, target, getMasterUserProfile(), eventType, subscriptionTime, refreshInterval), appDs);
+// }
 
 std::shared_ptr<SipMessage>
 DialogUsageManager::makeRegistration(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* appDs)
@@ -845,38 +845,38 @@ DialogUsageManager::makeRegistration(const NameAddr& target, uint32_t registrati
    return makeNewSession(new RegistrationCreator(*this, target, getMasterUserProfile(), registrationTime), appDs);
 }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makePublication(const NameAddr& targetDocument,
-                                    const std::shared_ptr<UserProfile>& userProfile,
-                                    const Contents& body,
-                                    const Data& eventType,
-                                    uint32_t expiresSeconds,
-                                    AppDialogSet* appDs)
-{
-   return makeNewSession(new PublicationCreator(*this, targetDocument, userProfile, body, eventType, expiresSeconds), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makePublication(const NameAddr& targetDocument,
+//                                     const std::shared_ptr<UserProfile>& userProfile,
+//                                     const Contents& body,
+//                                     const Data& eventType,
+//                                     uint32_t expiresSeconds,
+//                                     AppDialogSet* appDs)
+// {
+//    return makeNewSession(new PublicationCreator(*this, targetDocument, userProfile, body, eventType, expiresSeconds), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makePublication(const NameAddr& targetDocument,
-                                    const Contents& body,
-                                    const Data& eventType,
-                                    uint32_t expiresSeconds,
-                                    AppDialogSet* appDs)
-{
-   return makeNewSession(new PublicationCreator(*this, targetDocument, getMasterUserProfile(), body, eventType, expiresSeconds), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makePublication(const NameAddr& targetDocument,
+//                                     const Contents& body,
+//                                     const Data& eventType,
+//                                     uint32_t expiresSeconds,
+//                                     AppDialogSet* appDs)
+// {
+//    return makeNewSession(new PublicationCreator(*this, targetDocument, getMasterUserProfile(), body, eventType, expiresSeconds), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const MethodTypes meth, AppDialogSet* appDs)
-{
-   return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, userProfile), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const MethodTypes meth, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, userProfile), appDs);
+// }
 
-std::shared_ptr<SipMessage>
-DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const MethodTypes meth, AppDialogSet* appDs)
-{
-   return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, getMasterUserProfile()), appDs);
-}
+// std::shared_ptr<SipMessage>
+// DialogUsageManager::makeOutOfDialogRequest(const NameAddr& target, const MethodTypes meth, AppDialogSet* appDs)
+// {
+//    return makeNewSession(new OutOfDialogReqCreator(*this, meth, target, getMasterUserProfile()), appDs);
+// }
 
 ClientPagerMessageHandle
 DialogUsageManager::makePagerMessage(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* appDs)
@@ -1676,10 +1676,45 @@ DialogUsageManager::incomingProcess(std::unique_ptr<Message> msg)
             }
             if (sipMsg->header(h_From).exists(p_tag))
             {
-               if (mergeRequest(*sipMsg) )
+               // if (mergeRequest(*sipMsg) )
+               // {
+               //    InfoLog (<< "Merged request: " << *sipMsg);
+               //    return;
+               // }
+            }
+            if (sipMsg->header(h_RequestLine).method() == ACK
+               && ((!sipMsg->header(h_To).exists(p_tag))
+                     || (sipMsg->header(h_To).exists(p_tag) && sipMsg->header(h_To).param(p_tag) == "1533684873")
+                  )
+               )
+            {
+               auto it = mDialogSetMap.begin();
+               for (; it != mDialogSetMap.end(); it++)
                {
-                  InfoLog (<< "Merged request: " << *sipMsg);
-                  return;
+                  if (it->first.getCallId() == sipMsg->header(h_CallId).value())
+                  {
+                     break;
+                  }
+               }
+               if (it != mDialogSetMap.end())
+               {
+                  sipMsg->header(h_To).param(p_tag) = it->first.getLocalTag();
+               }
+            }
+            if (sipMsg->header(h_RequestLine).method() == INFO
+               && !sipMsg->header(h_To).exists(p_tag))
+            {
+               auto it = mDialogSetMap.begin();
+               for (; it != mDialogSetMap.end(); it++)
+               {
+                  if (it->first.getCallId() == sipMsg->header(h_CallId).value())
+                  {
+                     break;
+                  }
+               }
+               if (it != mDialogSetMap.end())
+               {
+                  sipMsg->header(h_To).param(p_tag) = it->first.getLocalTag();
                }
             }
             processRequest(*sipMsg);
@@ -2056,7 +2091,7 @@ DialogUsageManager::processRequest(const SipMessage& request)
 
    if (request.header(h_RequestLine).method() == PUBLISH)
    {
-      processPublish(request);
+      // processPublish(request);
       return;
    }
 
@@ -2244,65 +2279,65 @@ DialogUsageManager::processResponse(const SipMessage& response)
    }
 }
 
-void
-DialogUsageManager::processPublish(const SipMessage& request)
-{
-   if (!checkEventPackage(request))
-   {
-      InfoLog(<< "Rejecting request (unsupported package) " << request.brief());
-      return;
-   }
-
-   if (request.exists(h_SIPIfMatch))
-   {
-      ServerPublications::iterator i = mServerPublications.find(request.header(h_SIPIfMatch).value());
-      if (i != mServerPublications.end())
-      {
-         i->second->dispatch(request);
-      }
-      else
-      {
-         // Check if publication exists in PublicationDb - may have been sync'd over,
-         // or exists from a restart.  In this case, fabricate a new ServerSubcription 
-         // to handle this request.
-         if (mPublicationPersistenceManager &&
-             mPublicationPersistenceManager->documentExists(request.header(h_Event).value(), request.header(h_RequestLine).uri().getAor(), request.header(h_SIPIfMatch).value()))
-         {
-            ServerPublication* sp = new ServerPublication(*this, request.header(h_SIPIfMatch).value(), request);
-            mServerPublications[request.header(h_SIPIfMatch).value()] = sp;
-            sp->dispatch(request);
-         }
-         else
-         {
-            auto response = std::make_shared<SipMessage>();
-            makeResponse(*response, request, 412);
-            send(response);
-         }
-      }
-   }
-   else
-   {
-      Data etag = Random::getCryptoRandomHex(8);
-      while (mServerPublications.find(etag) != mServerPublications.end())
-      {
-         etag = Random::getCryptoRandomHex(8);
-      }
-
-      if (request.getContents())
-      {
-         ServerPublication* sp = new ServerPublication(*this, etag, request);
-         mServerPublications[etag] = sp;
-         sp->dispatch(request);
-      }
-      else
-      {
-         // per 3903 (sec 6.5), a PUB w/ no SIPIfMatch must have contents. .mjf.
-         auto response = std::make_shared<SipMessage>();
-         makeResponse(*response, request, 400);
-         send(response);
-      }
-   }
-}
+// void
+// DialogUsageManager::processPublish(const SipMessage& request)
+// {
+//    if (!checkEventPackage(request))
+//    {
+//       InfoLog(<< "Rejecting request (unsupported package) " << request.brief());
+//       return;
+//    }
+
+//    if (request.exists(h_SIPIfMatch))
+//    {
+//       ServerPublications::iterator i = mServerPublications.find(request.header(h_SIPIfMatch).value());
+//       if (i != mServerPublications.end())
+//       {
+//          i->second->dispatch(request);
+//       }
+//       else
+//       {
+//          // Check if publication exists in PublicationDb - may have been sync'd over,
+//          // or exists from a restart.  In this case, fabricate a new ServerSubcription 
+//          // to handle this request.
+//          if (mPublicationPersistenceManager &&
+//              mPublicationPersistenceManager->documentExists(request.header(h_Event).value(), request.header(h_RequestLine).uri().getAor(), request.header(h_SIPIfMatch).value()))
+//          {
+//             ServerPublication* sp = new ServerPublication(*this, request.header(h_SIPIfMatch).value(), request);
+//             mServerPublications[request.header(h_SIPIfMatch).value()] = sp;
+//             sp->dispatch(request);
+//          }
+//          else
+//          {
+//             auto response = std::make_shared<SipMessage>();
+//             makeResponse(*response, request, 412);
+//             send(response);
+//          }
+//       }
+//    }
+//    else
+//    {
+//       Data etag = Random::getCryptoRandomHex(8);
+//       while (mServerPublications.find(etag) != mServerPublications.end())
+//       {
+//          etag = Random::getCryptoRandomHex(8);
+//       }
+
+//       if (request.getContents())
+//       {
+//          ServerPublication* sp = new ServerPublication(*this, etag, request);
+//          mServerPublications[etag] = sp;
+//          sp->dispatch(request);
+//       }
+//       else
+//       {
+//          // per 3903 (sec 6.5), a PUB w/ no SIPIfMatch must have contents. .mjf.
+//          auto response = std::make_shared<SipMessage>();
+//          makeResponse(*response, request, 400);
+//          send(response);
+//       }
+//    }
+// }
 
 bool
 DialogUsageManager::checkEventPackage(const SipMessage& request)
@@ -2330,7 +2365,7 @@ DialogUsageManager::checkEventPackage(const SipMessage& request)
             }
             break;
          case NOTIFY:
-            if (!getClientSubscriptionHandler(request.header(h_Event).value()))
+            // if (!getClientSubscriptionHandler(request.header(h_Event).value()))
             {
                InfoLog (<< "No handler for event package for NOTIFY: " 
                         << request.header(h_Event).value());
@@ -2338,7 +2373,7 @@ DialogUsageManager::checkEventPackage(const SipMessage& request)
             }
             break;
          case PUBLISH:
-            if (!getServerPublicationHandler(request.header(h_Event).value()))
+            // if (!getServerPublicationHandler(request.header(h_Event).value()))
             {
                InfoLog (<< "No handler for event package for PUBLISH: " 
                         << request.header(h_Event).value());
@@ -2419,19 +2454,19 @@ DialogUsageManager::removeDialogSet(const DialogSetId& dsId)
    }
 }
 
-ClientSubscriptionHandler*
-DialogUsageManager::getClientSubscriptionHandler(const Data& eventType)
-{
-   map<Data, ClientSubscriptionHandler*>::iterator res = mClientSubscriptionHandlers.find(eventType);
-   if (res != mClientSubscriptionHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// ClientSubscriptionHandler*
+// DialogUsageManager::getClientSubscriptionHandler(const Data& eventType)
+// {
+//    map<Data, ClientSubscriptionHandler*>::iterator res = mClientSubscriptionHandlers.find(eventType);
+//    if (res != mClientSubscriptionHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
 ServerSubscriptionHandler*
 DialogUsageManager::getServerSubscriptionHandler(const Data& eventType)
@@ -2447,47 +2482,47 @@ DialogUsageManager::getServerSubscriptionHandler(const Data& eventType)
    }
 }
 
-ClientPublicationHandler*
-DialogUsageManager::getClientPublicationHandler(const Data& eventType)
-{
-   map<Data, ClientPublicationHandler*>::iterator res = mClientPublicationHandlers.find(eventType);
-   if (res != mClientPublicationHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// ClientPublicationHandler*
+// DialogUsageManager::getClientPublicationHandler(const Data& eventType)
+// {
+//    map<Data, ClientPublicationHandler*>::iterator res = mClientPublicationHandlers.find(eventType);
+//    if (res != mClientPublicationHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
-ServerPublicationHandler*
-DialogUsageManager::getServerPublicationHandler(const Data& eventType)
-{
-   map<Data, ServerPublicationHandler*>::iterator res = mServerPublicationHandlers.find(eventType);
-   if (res != mServerPublicationHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// ServerPublicationHandler*
+// DialogUsageManager::getServerPublicationHandler(const Data& eventType)
+// {
+//    map<Data, ServerPublicationHandler*>::iterator res = mServerPublicationHandlers.find(eventType);
+//    if (res != mServerPublicationHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
-OutOfDialogHandler*
-DialogUsageManager::getOutOfDialogHandler(const MethodTypes type)
-{
-   map<MethodTypes, OutOfDialogHandler*>::iterator res = mOutOfDialogHandlers.find(type);
-   if (res != mOutOfDialogHandlers.end())
-   {
-      return res->second;
-   }
-   else
-   {
-      return 0;
-   }
-}
+// OutOfDialogHandler*
+// DialogUsageManager::getOutOfDialogHandler(const MethodTypes type)
+// {
+//    map<MethodTypes, OutOfDialogHandler*>::iterator res = mOutOfDialogHandlers.find(type);
+//    if (res != mOutOfDialogHandlers.end())
+//    {
+//       return res->second;
+//    }
+//    else
+//    {
+//       return 0;
+//    }
+// }
 
 void 
 DialogUsageManager::addIncomingFeature(std::shared_ptr<DumFeature> feat)
@@ -2525,22 +2560,22 @@ DialogUsageManager::applyToAllServerSubscriptions(ServerSubscriptionFunctor* fun
    }
 }
 
-void
-DialogUsageManager::applyToAllClientSubscriptions(ClientSubscriptionFunctor* functor)
-{
-   resip_assert(functor);
-   for (DialogSetMap::iterator it = mDialogSetMap.begin(); it != mDialogSetMap.end(); ++it)
-   {
-      for (DialogSet::DialogMap::iterator i = it->second->mDialogs.begin(); i != it->second->mDialogs.end(); ++i)
-      {
-         std::vector<ClientSubscriptionHandle> clientSubs = i->second->getClientSubscriptions();
-         for (std::vector<ClientSubscriptionHandle>::iterator ics = clientSubs.begin(); ics != clientSubs.end(); ++ics)
-         {
-            functor->apply(*ics);
-         }
-      }
-   }
-}
+// void
+// DialogUsageManager::applyToAllClientSubscriptions(ClientSubscriptionFunctor* functor)
+// {
+//    resip_assert(functor);
+//    for (DialogSetMap::iterator it = mDialogSetMap.begin(); it != mDialogSetMap.end(); ++it)
+//    {
+//       for (DialogSet::DialogMap::iterator i = it->second->mDialogs.begin(); i != it->second->mDialogs.end(); ++i)
+//       {
+//          std::vector<ClientSubscriptionHandle> clientSubs = i->second->getClientSubscriptions();
+//          for (std::vector<ClientSubscriptionHandle>::iterator ics = clientSubs.begin(); ics != clientSubs.end(); ++ics)
+//          {
+//             functor->apply(*ics);
+//          }
+//       }
+//    }
+// }
 
 void 
 DialogUsageManager::endAllServerSubscriptions(TerminateReason reason)
@@ -2555,18 +2590,18 @@ DialogUsageManager::endAllServerSubscriptions(TerminateReason reason)
    }
 }
 
-void 
-DialogUsageManager::endAllServerPublications()
-{
-   // Make a copy of the map - since calling end can cause an immediate delete this on the publication and thus cause
-   // the object to remove itself from the mServerPublications map, messing up our iterator
-   ServerPublications tempPublications = mServerPublications;
-   ServerPublications::iterator it = tempPublications.begin();
-   for (; it != tempPublications.end(); it++)
-   {
-      it->second->end();
-   }
-}
+// void 
+// DialogUsageManager::endAllServerPublications()
+// {
+//    // Make a copy of the map - since calling end can cause an immediate delete this on the publication and thus cause
+//    // the object to remove itself from the mServerPublications map, messing up our iterator
+//    ServerPublications tempPublications = mServerPublications;
+//    ServerPublications::iterator it = tempPublications.begin();
+//    for (; it != tempPublications.end(); it++)
+//    {
+//       it->second->end();
+//    }
+// }
 
 void
 DialogUsageManager::registerForConnectionTermination(Postable* listener)
diff --git a/resip/dum/DialogUsageManager.hxx b/resip/dum/DialogUsageManager.hxx
old mode 100644
new mode 100755
index d6ea6207e..76b6b4fc5
--- a/resip/dum/DialogUsageManager.hxx
+++ b/resip/dum/DialogUsageManager.hxx
@@ -163,18 +163,18 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       void setClientRegistrationHandler(ClientRegistrationHandler*);
 
       /// If no such handler, UAS will respond to REGISTER with 405 Method Not Allowed
-      void setServerRegistrationHandler(ServerRegistrationHandler*);
+      // void setServerRegistrationHandler(ServerRegistrationHandler*);
 
       /// If there is no such handler, calling makeSubscription will throw
-      void addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler*);
+      // void addClientSubscriptionHandler(const Data& eventType, ClientSubscriptionHandler*);
 
       /// If there is no such handler, calling makePublication will throw
-      void addClientPublicationHandler(const Data& eventType, ClientPublicationHandler*);
+      // void addClientPublicationHandler(const Data& eventType, ClientPublicationHandler*);
       
       void addServerSubscriptionHandler(const Data& eventType, ServerSubscriptionHandler*);
-      void addServerPublicationHandler(const Data& eventType, ServerPublicationHandler*);
+      // void addServerPublicationHandler(const Data& eventType, ServerPublicationHandler*);
       
-      void addOutOfDialogHandler(MethodTypes, OutOfDialogHandler*);
+      // void addOutOfDialogHandler(MethodTypes, OutOfDialogHandler*);
 
       void setRequestValidationHandler(RequestValidationHandler*);
 
@@ -197,60 +197,60 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       // the future. If the caller wants to keep it, it should make a copy. The
       // memory will exist at least up until the point where the application
       // calls DialogUsageManager::send(msg);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const DialogSetId& dialogSetId, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, const DialogSetId& dialogSetId, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
       // Versions that add a replaces header
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const std::shared_ptr<UserProfile>& userProfile, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSession(const NameAddr& target, InviteSessionHandle sessionToReplace, const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* ads = nullptr);
       
       //will send a Notify(100)...currently can be decorated through the
       //OnReadyToSend callback.  Probably will change it's own callback/handler soon
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile,
-                                                       const Contents* initialOffer, AppDialogSet* appDs = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile, ServerSubscriptionHandle,
-                                                       const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile,
+      //                                                  const Contents* initialOffer, AppDialogSet* appDs = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeInviteSessionFromRefer(const SipMessage& refer, const std::shared_ptr<UserProfile>& userProfile, ServerSubscriptionHandle,
+      //                                                  const Contents* initialOffer, EncryptionLevel level = None, const Contents* alternative = nullptr, AppDialogSet* = nullptr);
       
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                             uint32_t subscriptionTime, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
-                                             uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, uint32_t subscriptionTime, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType,
-                                             uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+      //                                        uint32_t subscriptionTime, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const Data& eventType,
+      //                                        uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType, uint32_t subscriptionTime, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeSubscription(const NameAddr& target, const Data& eventType,
+      //                                        uint32_t subscriptionTime, int refreshInterval, AppDialogSet* = nullptr);
 
       //unsolicited refer
-      std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
-
-      std::shared_ptr<SipMessage> makePublication(const NameAddr& target,
-                                            const std::shared_ptr<UserProfile>& userProfile,
-                                            const Contents& body, 
-                                            const Data& eventType, 
-                                            uint32_t expiresSeconds, 
-                                            AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makePublication(const NameAddr& target,
-                                            const Contents& body, 
-                                            const Data& eventType, 
-                                            uint32_t expiresSeconds, 
-                                            AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeRefer(const NameAddr& target, const H_ReferTo::Type& referTo, AppDialogSet* = nullptr);
+
+      // std::shared_ptr<SipMessage> makePublication(const NameAddr& target,
+      //                                       const std::shared_ptr<UserProfile>& userProfile,
+      //                                       const Contents& body, 
+      //                                       const Data& eventType, 
+      //                                       uint32_t expiresSeconds, 
+      //                                       AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makePublication(const NameAddr& target,
+      //                                       const Contents& body, 
+      //                                       const Data& eventType, 
+      //                                       uint32_t expiresSeconds, 
+      //                                       AppDialogSet* = nullptr);
 
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* = nullptr);
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, uint32_t registrationTime, AppDialogSet* = nullptr);
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, AppDialogSet* = nullptr);
       std::shared_ptr<SipMessage> makeRegistration(const NameAddr& target, uint32_t registrationTime, AppDialogSet* = nullptr);
 
-      std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, MethodTypes meth, AppDialogSet* = nullptr);
-      std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, MethodTypes meth, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, MethodTypes meth, AppDialogSet* = nullptr);
+      // std::shared_ptr<SipMessage> makeOutOfDialogRequest(const NameAddr& target, MethodTypes meth, AppDialogSet* = nullptr);
 
       ClientPagerMessageHandle makePagerMessage(const NameAddr& target, const std::shared_ptr<UserProfile>& userProfile, AppDialogSet* = nullptr);
       ClientPagerMessageHandle makePagerMessage(const NameAddr& target, AppDialogSet* = nullptr);
@@ -305,10 +305,10 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       //if the handle is inValid, int represents the errorcode
       std::pair<InviteSessionHandle, int> findInviteSession(const CallId& replaces);
 
-      ClientPublicationHandler* getClientPublicationHandler(const Data& eventType);
-      ServerPublicationHandler* getServerPublicationHandler(const Data& eventType);
+      // ClientPublicationHandler* getClientPublicationHandler(const Data& eventType);
+      // ServerPublicationHandler* getServerPublicationHandler(const Data& eventType);
 
-      ClientSubscriptionHandler* getClientSubscriptionHandler(const Data& eventType);
+      // ClientSubscriptionHandler* getClientSubscriptionHandler(const Data& eventType);
       ServerSubscriptionHandler* getServerSubscriptionHandler(const Data& eventType);
 
       // will apply the specified functor(which takes a
@@ -350,11 +350,11 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       void internalProcess(std::unique_ptr<Message> msg);
       bool messageAvailable(void) { return mFifo.messageAvailable(); }
 
-      void applyToAllClientSubscriptions(ClientSubscriptionFunctor*);
+      // void applyToAllClientSubscriptions(ClientSubscriptionFunctor*);
       void applyToAllServerSubscriptions(ServerSubscriptionFunctor*);
 
       void endAllServerSubscriptions(TerminateReason reason = Deactivated);
-      void endAllServerPublications();
+      // void endAllServerPublications();
 
       /// Note:  Implementations of Postable must delete the message passed via post
       void registerForConnectionTermination(Postable*);
@@ -477,7 +477,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       
       bool mergeRequest(const SipMessage& request);
 
-      void processPublish(const SipMessage& publish);
+      // void processPublish(const SipMessage& publish);
 
       void removeDialogSet(const DialogSetId& );      
 
@@ -515,7 +515,7 @@ class DialogUsageManager : public HandleManager, public TransactionUser
     
       InviteSessionHandler* mInviteSessionHandler;
       ClientRegistrationHandler* mClientRegistrationHandler;
-      ServerRegistrationHandler* mServerRegistrationHandler;      
+      // ServerRegistrationHandler* mServerRegistrationHandler;      
       RedirectHandler* mRedirectHandler;
       DialogSetHandler* mDialogSetHandler;      
       RequestValidationHandler* mRequestValidationHandler;
@@ -523,13 +523,13 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       RegistrationPersistenceManager *mRegistrationPersistenceManager;
       PublicationPersistenceManager *mPublicationPersistenceManager;
 
-      OutOfDialogHandler* getOutOfDialogHandler(MethodTypes type);
+      // OutOfDialogHandler* getOutOfDialogHandler(MethodTypes type);
 
-      std::map<Data, ClientSubscriptionHandler*> mClientSubscriptionHandlers;
+      // std::map<Data, ClientSubscriptionHandler*> mClientSubscriptionHandlers;
       std::map<Data, ServerSubscriptionHandler*> mServerSubscriptionHandlers;
-      std::map<Data, ClientPublicationHandler*> mClientPublicationHandlers;
-      std::map<Data, ServerPublicationHandler*> mServerPublicationHandlers;
-      std::map<MethodTypes, OutOfDialogHandler*> mOutOfDialogHandlers;
+      // std::map<Data, ClientPublicationHandler*> mClientPublicationHandlers;
+      // std::map<Data, ServerPublicationHandler*> mServerPublicationHandlers;
+      // std::map<MethodTypes, OutOfDialogHandler*> mOutOfDialogHandlers;
       std::unique_ptr<KeepAliveManager> mKeepAliveManager;
       bool mIsDefaultServerReferHandler;
 
@@ -556,8 +556,8 @@ class DialogUsageManager : public HandleManager, public TransactionUser
       ShutdownState mShutdownState;
 
       // from ETag -> ServerPublication
-      typedef std::map<Data, ServerPublication*> ServerPublications;
-      ServerPublications mServerPublications;
+      // typedef std::map<Data, ServerPublication*> ServerPublications;
+      // ServerPublications mServerPublications;
       typedef std::map<Data, SipMessage*> RequiresCerts;
       RequiresCerts mRequiresCerts;      
       // from Event-Type+document-aor -> ServerSubscription
diff --git a/resip/dum/InviteSession.cxx b/resip/dum/InviteSession.cxx
old mode 100644
new mode 100755
index e4a4f23c4..e6d0a134a
--- a/resip/dum/InviteSession.cxx
+++ b/resip/dum/InviteSession.cxx
@@ -2512,16 +2512,16 @@ InviteSession::start491Timer()
 {
    unsigned int seq = mLastLocalSessionModification->header(h_CSeq).sequence();
 
-   if (dynamic_cast<ClientInviteSession*>(this))
-   {
-      int timer = Random::getRandom() % (4000 - 2100);
-      timer += 2100;
-      timer -= timer % 10;
+   // if (dynamic_cast<ClientInviteSession*>(this))
+   // {
+   //    int timer = Random::getRandom() % (4000 - 2100);
+   //    timer += 2100;
+   //    timer -= timer % 10;
       
-      DebugLog(<< "491 timer value: " << timer << "ms" << endl);
-      mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
-   }
-   else
+   //    DebugLog(<< "491 timer value: " << timer << "ms" << endl);
+   //    mDum.addTimerMs(DumTimeout::Glare, timer, getBaseHandle(), seq);
+   // }
+   // else
    {
       int timer = Random::getRandom() % 2000;
       timer -= timer % 10;
@@ -2629,7 +2629,7 @@ InviteSession::setSessionTimerPreferences()
       mSessionRefresher = dynamic_cast<ServerInviteSession*>(this) != NULL; // Default refresher is callee
       break;
    case Profile::PreferCallerRefreshes:
-      mSessionRefresher = dynamic_cast<ClientInviteSession*>(this) != NULL; // Default refresher is caller
+      // mSessionRefresher = dynamic_cast<ClientInviteSession*>(this) != NULL; // Default refresher is caller
       break;
    }
 }
diff --git a/resip/dum/InviteSessionHandler.hxx b/resip/dum/InviteSessionHandler.hxx
old mode 100644
new mode 100755
index 844a79bcb..b2a5b0bcf
--- a/resip/dum/InviteSessionHandler.hxx
+++ b/resip/dum/InviteSessionHandler.hxx
@@ -45,21 +45,21 @@ class InviteSessionHandler
       virtual bool isGenericOfferAnswer() { return mGenericOfferAnswer; }
 
       /// called when an initial INVITE or the intial response to an outoing invite  
-      virtual void onNewSession(ClientInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
+      // virtual void onNewSession(ClientInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
       virtual void onNewSession(ServerInviteSessionHandle, InviteSession::OfferAnswerType oat, const SipMessage& msg)=0;
 
       /// Received a failure response from UAS
-      virtual void onFailure(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onFailure(ClientInviteSessionHandle, const SipMessage& msg)=0;
       
       /// called when an in-dialog provisional response is received that contains a body
-      virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const SdpContents&)=0;
+      // virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const SdpContents&)=0;
       virtual void onEarlyMedia(ClientInviteSessionHandle, const SipMessage&, const Contents&);
 
       /// called when dialog enters the Early state - typically after getting 18x
-      virtual void onProvisional(ClientInviteSessionHandle, const SipMessage&)=0;
+      // virtual void onProvisional(ClientInviteSessionHandle, const SipMessage&)=0;
 
       /// called when a dialog initiated as a UAC enters the connected state
-      virtual void onConnected(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onConnected(ClientInviteSessionHandle, const SipMessage& msg)=0;
 
       /// called when a dialog initiated as a UAS enters the connected state
       virtual void onConnected(InviteSessionHandle, const SipMessage& msg)=0;
@@ -101,7 +101,7 @@ class InviteSessionHandler
 
       /// called when a fork that was created through a 1xx never receives a 2xx
       /// because another fork answered and this fork was canceled by a proxy. 
-      virtual void onForkDestroyed(ClientInviteSessionHandle)=0;
+      // virtual void onForkDestroyed(ClientInviteSessionHandle)=0;
 
       /// called when a 3xx with valid targets is encountered in an early dialog     
       /// This is different then getting a 3xx in onTerminated, as another
@@ -109,7 +109,7 @@ class InviteSessionHandler
       /// Basically an onTermintated that conveys more information.
       /// checking for 3xx respones in onTerminated will not work as there may
       /// be no valid targets.
-      virtual void onRedirected(ClientInviteSessionHandle, const SipMessage& msg)=0;
+      // virtual void onRedirected(ClientInviteSessionHandle, const SipMessage& msg)=0;
 
       /// called to allow app to adorn a message. default is to send immediately
       virtual void onReadyToSend(InviteSessionHandle, SipMessage& msg);
diff --git a/resip/stack/CMakeLists.txt b/resip/stack/CMakeLists.txt
old mode 100644
new mode 100755
index d7c2f4c46..e9b5bd158
--- a/resip/stack/CMakeLists.txt
+++ b/resip/stack/CMakeLists.txt
@@ -94,7 +94,7 @@ set(INCLUDES
    Pidf.hxx
    Pkcs7Contents.hxx
    Pkcs8Contents.hxx
-   PlainContents.hxx
+   #PlainContents.hxx
    PollStatistics.hxx
    PrivacyCategory.hxx
    QuotedDataParameter.hxx
@@ -158,7 +158,7 @@ set(INCLUDES
    TransportSelector.hxx
    TransportThread.hxx
    TrickleIceContents.hxx
-   TuIM.hxx
+   #TuIM.hxx
    Tuple.hxx
    TupleMarkManager.hxx
    TuSelector.hxx
@@ -273,7 +273,7 @@ add_library(resip
    Pidf.cxx
    Pkcs7Contents.cxx
    Pkcs8Contents.cxx
-   PlainContents.cxx
+   #PlainContents.cxx
    PrivacyCategory.cxx
    QuotedDataParameter.cxx
    RAckCategory.cxx
@@ -315,7 +315,7 @@ add_library(resip
    TransportFailure.cxx
    TransportSelector.cxx
    TrickleIceContents.cxx
-   TuIM.cxx
+   #TuIM.cxx
    TuSelector.cxx
    UdpTransport.cxx
    UnknownParameter.cxx
@@ -410,7 +410,7 @@ version_libname(resip)
 set_target_properties(resip PROPERTIES FOLDER resip)
 
 install(TARGETS resip DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/stack ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/resip/stack ${INCLUDES})
 
 if(BUILD_TESTING)
     add_subdirectory(test)
diff --git a/resip/stack/SdpContents.cxx b/resip/stack/SdpContents.cxx
old mode 100644
new mode 100755
index 37f75d8a0..685739970
--- a/resip/stack/SdpContents.cxx
+++ b/resip/stack/SdpContents.cxx
@@ -1526,7 +1526,8 @@ SdpContents::Session::Medium::Medium()
    : mSession(0),
      mPort(0),
      mMulticast(1),
-     mRtpMapDone(false)
+     mRtpMapDone(false),
+     mSSRC(0)
 {}
 
 SdpContents::Session::Medium::Medium(const Medium& rhs)
@@ -1544,7 +1545,8 @@ SdpContents::Session::Medium::Medium(const Medium& rhs)
      mEncryption(rhs.mEncryption),
      mAttributeHelper(rhs.mAttributeHelper),
      mRtpMapDone(rhs.mRtpMapDone),
-     mRtpMap(rhs.mRtpMap)
+     mRtpMap(rhs.mRtpMap),
+     mSSRC(rhs.mSSRC)
 {
 }
 
@@ -1706,6 +1708,14 @@ SdpContents::Session::Medium::parse(ParseBuffer& pb)
    }
 
    mAttributeHelper.parse(pb);
+
+   if (!pb.eof() && *pb.position() == 'y')
+   {
+      pb.skipChar('y');
+      pb.skipChar(Symbols::EQUALS[0]);
+      mSSRC = pb.uInt32();
+      skipEol(pb);
+   }
 }
 
 EncodeStream&
@@ -1788,6 +1798,10 @@ SdpContents::Session::Medium::encode(EncodeStream& s) const
 
    mAttributeHelper.encode(s);
 
+   char y[16] = {0};
+   snprintf(y, sizeof(y), "%010u", mSSRC);
+   s << "y=" << y << Symbols::CRLF;
+
    return s;
 }
 
diff --git a/resip/stack/SdpContents.hxx b/resip/stack/SdpContents.hxx
old mode 100644
new mode 100755
index acf793f5a..3cd219b94
--- a/resip/stack/SdpContents.hxx
+++ b/resip/stack/SdpContents.hxx
@@ -843,6 +843,9 @@ class SdpContents : public Contents
                   const Direction& getDirection() const;
                   const Direction& getDirection(const Direction& sessionDefault) const;
 
+                  uint32_t ssrc() const {return mSSRC;}
+                  uint32_t& ssrc() { return mSSRC;}
+
                private:
                   void setSession(Session* session);
                   Session* mSession;
@@ -864,6 +867,8 @@ class SdpContents : public Contents
                   typedef HashMap<int, Codec> RtpMap;
                   RtpMap mRtpMap;
 
+                  uint32_t mSSRC;
+
                   friend class Session;
             };
 
diff --git a/rutil/CMakeLists.txt b/rutil/CMakeLists.txt
old mode 100644
new mode 100755
index 7ed566263..da74fd473
--- a/rutil/CMakeLists.txt
+++ b/rutil/CMakeLists.txt
@@ -262,7 +262,7 @@ set_target_properties(rutil PROPERTIES FOLDER rutil)
 version_libname(rutil)
 
 install(TARGETS rutil DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/rutil ${INCLUDES})
+#install_and_preserve_hierarchy(${CMAKE_INSTALL_INCLUDEDIR}/rutil ${INCLUDES})
 
 if(NOT WITH_C_ARES)
    add_subdirectory(dns/ares)
diff --git a/rutil/Log.cxx b/rutil/Log.cxx
old mode 100644
new mode 100755
index efd4a89dd..41a82f6aa
--- a/rutil/Log.cxx
+++ b/rutil/Log.cxx
@@ -1,3 +1,5 @@
+#if 0
+
 #include "rutil/Socket.hxx"
 
 #include "rutil/ResipAssert.h"
@@ -1315,6 +1317,8 @@ Log::ThreadData::droppingPrivileges(uid_t uid, pid_t pid)
 }
 #endif
 
+#endif
+
 /* ====================================================================
  * The Vovida Software License, Version 1.0 
  * 
diff --git a/rutil/Log.hxx b/rutil/Log.hxx
old mode 100644
new mode 100755
index 0a0175411..ada3079bf
--- a/rutil/Log.hxx
+++ b/rutil/Log.hxx
@@ -1,6 +1,8 @@
 #ifndef RESIP_Log_hxx
 #define RESIP_Log_hxx
 
+#if 0
+
 #include "rutil/Data.hxx"
 
 #ifndef WIN32
@@ -480,6 +482,63 @@ static LogStaticInitializer _staticLogInit;
 
 }
 
+#else
+
+#include "rutil/Data.hxx"
+
+#ifndef WIN32
+#include <syslog.h>
+#include <unistd.h>
+#endif
+
+#include <set>
+
+#include "rutil/ConfigParse.hxx"
+// #include "rutil/Mutex.hxx"
+// #include "rutil/Lock.hxx"
+// #include "rutil/HashMap.hxx"
+#include "rutil/ThreadIf.hxx"
+#include <iostream>
+
+namespace resip
+{
+
+class Log
+{
+public:
+   enum Level
+   {
+      None = -1,
+#ifdef WIN32
+      Crit = 2,
+      Err = 3,
+      Warning = 4,
+      Info = 6,
+      Debug = 7,
+#else
+      Crit = LOG_CRIT,
+// #ifdef ERR // ncurses defines a macro called ERR 
+//          SIP2_ERR = LOG_ERR,
+// #else
+//          ERR = LOG_ERR,
+// #endif
+      Err,
+      Warning = LOG_WARNING,
+      Info = LOG_INFO,
+      Debug = LOG_DEBUG,
+#endif
+      Stack = 8,
+      StdErr = 9,
+      Bogus = 666
+   };
+   static void reset() {}
+   static void droppingPrivileges(uid_t uid, pid_t pid) {}
+};
+
+}
+
+#endif
+
 #endif
 
 /* ====================================================================
diff --git a/rutil/Logger.hxx b/rutil/Logger.hxx
old mode 100644
new mode 100755
index cab079977..c8566071e
--- a/rutil/Logger.hxx
+++ b/rutil/Logger.hxx
@@ -115,7 +115,7 @@
 #define DELIM 
 
 
-
+#if 0
 // unconditionally output to cerr -- easily change back and forth
 #define CerrLog(args_)                                                  \
 	resip::Log::tags(resip::Log::StdErr, RESIPROCATE_SUBSYSTEM,           \
@@ -171,6 +171,31 @@ namespace resip
 typedef Log GenericLogImpl;
 }
 
+#else
+
+#define CerrLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define StackLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define DebugLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define InfoLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define WarningLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define ErrLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#define CritLog(args_) \
+   std::cout << __FILE__ << ":" << __LINE__ << " | " args_ << std::endl
+
+#endif
+
 #endif
 
 /* ====================================================================
diff --git a/rutil/Subsystem.cxx b/rutil/Subsystem.cxx
old mode 100644
new mode 100755
index 69472623b..a218b055d
--- a/rutil/Subsystem.cxx
+++ b/rutil/Subsystem.cxx
@@ -2,23 +2,23 @@
 
 using namespace resip;
 
-Subsystem Subsystem::APP("RESIP:APP");
-Subsystem Subsystem::CONTENTS("RESIP:CONTENTS");
-Subsystem Subsystem::DNS("RESIP:DNS");
-Subsystem Subsystem::DUM("RESIP:DUM");
-Subsystem Subsystem::EEP("RESIP:EEP");
-Subsystem Subsystem::MEDIA("RESIP:MEDIA");
-Subsystem Subsystem::PRESENCE("RESIP:PRESENCE");
-Subsystem Subsystem::PYTHON("RESIP:PYTHON");
-Subsystem Subsystem::SDP("RESIP:SDP");
-Subsystem Subsystem::SIP("RESIP");    // SIP Stack / Parser
-Subsystem Subsystem::TEST("RESIP:TEST");
+// Subsystem Subsystem::APP("RESIP:APP");
+// Subsystem Subsystem::CONTENTS("RESIP:CONTENTS");
+// Subsystem Subsystem::DNS("RESIP:DNS");
+// Subsystem Subsystem::DUM("RESIP:DUM");
+// Subsystem Subsystem::EEP("RESIP:EEP");
+// Subsystem Subsystem::MEDIA("RESIP:MEDIA");
+// Subsystem Subsystem::PRESENCE("RESIP:PRESENCE");
+// Subsystem Subsystem::PYTHON("RESIP:PYTHON");
+// Subsystem Subsystem::SDP("RESIP:SDP");
+// Subsystem Subsystem::SIP("RESIP");    // SIP Stack / Parser
+// Subsystem Subsystem::TEST("RESIP:TEST");
 Subsystem Subsystem::TRANSACTION("RESIP:TRANSACTION");
-Subsystem Subsystem::TRANSPORT("RESIP:TRANSPORT");
-Subsystem Subsystem::STATS("RESIP:STATS");
-Subsystem Subsystem::REPRO("REPRO:APP");
-Subsystem Subsystem::QPIDPROTON("QPIDPROTON");
-Subsystem Subsystem::NONE("UNDEFINED");
+// Subsystem Subsystem::TRANSPORT("RESIP:TRANSPORT");
+// Subsystem Subsystem::STATS("RESIP:STATS");
+// Subsystem Subsystem::REPRO("REPRO:APP");
+// Subsystem Subsystem::QPIDPROTON("QPIDPROTON");
+// Subsystem Subsystem::NONE("UNDEFINED");
 
 const Data& Subsystem::getSubsystem() const
 {
@@ -32,7 +32,6 @@ resip::operator<<(EncodeStream& strm, const Subsystem& ss)
    return strm;
 }
 
-
 /* ====================================================================
  * The Vovida Software License, Version 1.0 
  * 
diff --git a/rutil/Subsystem.hxx b/rutil/Subsystem.hxx
old mode 100644
new mode 100755
index 16d9324b2..557a99407
--- a/rutil/Subsystem.hxx
+++ b/rutil/Subsystem.hxx
@@ -34,23 +34,23 @@ class Subsystem
 {
    public:
       // Add new systems below
-      static Subsystem APP;
-      static Subsystem CONTENTS;
-      static Subsystem DNS;
-      static Subsystem DUM;
-      static Subsystem EEP;
-      static Subsystem MEDIA;
-      static Subsystem NONE; // default subsystem
-      static Subsystem PRESENCE;
-      static Subsystem PYTHON;
-      static Subsystem SDP;
-      static Subsystem SIP;    // SIP Stack / Parser
-      static Subsystem TEST;   
+      // static Subsystem APP;
+      // static Subsystem CONTENTS;
+      // static Subsystem DNS;
+      // static Subsystem DUM;
+      // static Subsystem EEP;
+      // static Subsystem MEDIA;
+      // static Subsystem NONE; // default subsystem
+      // static Subsystem PRESENCE;
+      // static Subsystem PYTHON;
+      // static Subsystem SDP;
+      // static Subsystem SIP;    // SIP Stack / Parser
+      // static Subsystem TEST;   
       static Subsystem TRANSACTION;
-      static Subsystem TRANSPORT;
-      static Subsystem STATS;
-      static Subsystem REPRO;
-      static Subsystem QPIDPROTON;
+      // static Subsystem TRANSPORT;
+      // static Subsystem STATS;
+      // static Subsystem REPRO;
+      // static Subsystem QPIDPROTON;
       
       const Data& getSubsystem() const;
       Log::Level getLevel() const { return mLevel; }
diff --git a/rutil/dns/ares/CMakeLists.txt b/rutil/dns/ares/CMakeLists.txt
old mode 100644
new mode 100755
index 021b8cf28..8cb0002c1
--- a/rutil/dns/ares/CMakeLists.txt
+++ b/rutil/dns/ares/CMakeLists.txt
@@ -57,7 +57,7 @@ version_libname(resipares)
 set_target_properties(resipares PROPERTIES FOLDER rutil/ares)
 
 install(TARGETS resipares DESTINATION ${CMAKE_INSTALL_LIBDIR})
-install(FILES ${INCLUDES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/rutil/dns/ares)
+#install(FILES ${INCLUDES} DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/rutil/dns/ares)
 
 add_executable(ahost EXCLUDE_FROM_ALL ahost.c)
 add_executable(adig EXCLUDE_FROM_ALL adig.c)
